(function () { const r = document.createElement("link").relList; if (r && r.supports && r.supports("modulepreload")) return; for (const l of document.querySelectorAll('link[rel="modulepreload"]')) s(l); new MutationObserver(l => { for (const f of l) if (f.type === "childList") for (const c of f.addedNodes) c.tagName === "LINK" && c.rel === "modulepreload" && s(c) }).observe(document, { childList: !0, subtree: !0 }); function o(l) { const f = {}; return l.integrity && (f.integrity = l.integrity), l.referrerPolicy && (f.referrerPolicy = l.referrerPolicy), l.crossOrigin === "use-credentials" ? f.credentials = "include" : l.crossOrigin === "anonymous" ? f.credentials = "omit" : f.credentials = "same-origin", f } function s(l) { if (l.ep) return; l.ep = !0; const f = o(l); fetch(l.href, f) } })(); var Nl = { exports: {} }, Mi = {}, Dl = { exports: {} }, de = {};/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var uh; function t0() { if (uh) return de; uh = 1; var n = Symbol.for("react.element"), r = Symbol.for("react.portal"), o = Symbol.for("react.fragment"), s = Symbol.for("react.strict_mode"), l = Symbol.for("react.profiler"), f = Symbol.for("react.provider"), c = Symbol.for("react.context"), h = Symbol.for("react.forward_ref"), p = Symbol.for("react.suspense"), g = Symbol.for("react.memo"), y = Symbol.for("react.lazy"), v = Symbol.iterator; function x(T) { return T === null || typeof T != "object" ? null : (T = v && T[v] || T["@@iterator"], typeof T == "function" ? T : null) } var C = { isMounted: function () { return !1 }, enqueueForceUpdate: function () { }, enqueueReplaceState: function () { }, enqueueSetState: function () { } }, M = Object.assign, N = {}; function A(T, I, ne) { this.props = T, this.context = I, this.refs = N, this.updater = ne || C } A.prototype.isReactComponent = {}, A.prototype.setState = function (T, I) { if (typeof T != "object" && typeof T != "function" && T != null) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables."); this.updater.enqueueSetState(this, T, I, "setState") }, A.prototype.forceUpdate = function (T) { this.updater.enqueueForceUpdate(this, T, "forceUpdate") }; function V() { } V.prototype = A.prototype; function b(T, I, ne) { this.props = T, this.context = I, this.refs = N, this.updater = ne || C } var j = b.prototype = new V; j.constructor = b, M(j, A.prototype), j.isPureReactComponent = !0; var W = Array.isArray, U = Object.prototype.hasOwnProperty, J = { current: null }, se = { key: !0, ref: !0, __self: !0, __source: !0 }; function O(T, I, ne) { var oe, he = {}, pe = null, ue = null; if (I != null) for (oe in I.ref !== void 0 && (ue = I.ref), I.key !== void 0 && (pe = "" + I.key), I) U.call(I, oe) && !se.hasOwnProperty(oe) && (he[oe] = I[oe]); var ge = arguments.length - 2; if (ge === 1) he.children = ne; else if (1 < ge) { for (var xe = Array(ge), He = 0; He < ge; He++)xe[He] = arguments[He + 2]; he.children = xe } if (T && T.defaultProps) for (oe in ge = T.defaultProps, ge) he[oe] === void 0 && (he[oe] = ge[oe]); return { $$typeof: n, type: T, key: pe, ref: ue, props: he, _owner: J.current } } function ce(T, I) { return { $$typeof: n, type: T.type, key: I, ref: T.ref, props: T.props, _owner: T._owner } } function ve(T) { return typeof T == "object" && T !== null && T.$$typeof === n } function Xe(T) { var I = { "=": "=0", ":": "=2" }; return "$" + T.replace(/[=:]/g, function (ne) { return I[ne] }) } var Ue = /\/+/g; function $e(T, I) { return typeof T == "object" && T !== null && T.key != null ? Xe("" + T.key) : I.toString(36) } function We(T, I, ne, oe, he) { var pe = typeof T; (pe === "undefined" || pe === "boolean") && (T = null); var ue = !1; if (T === null) ue = !0; else switch (pe) { case "string": case "number": ue = !0; break; case "object": switch (T.$$typeof) { case n: case r: ue = !0 } }if (ue) return ue = T, he = he(ue), T = oe === "" ? "." + $e(ue, 0) : oe, W(he) ? (ne = "", T != null && (ne = T.replace(Ue, "$&/") + "/"), We(he, I, ne, "", function (He) { return He })) : he != null && (ve(he) && (he = ce(he, ne + (!he.key || ue && ue.key === he.key ? "" : ("" + he.key).replace(Ue, "$&/") + "/") + T)), I.push(he)), 1; if (ue = 0, oe = oe === "" ? "." : oe + ":", W(T)) for (var ge = 0; ge < T.length; ge++) { pe = T[ge]; var xe = oe + $e(pe, ge); ue += We(pe, I, ne, xe, he) } else if (xe = x(T), typeof xe == "function") for (T = xe.call(T), ge = 0; !(pe = T.next()).done;)pe = pe.value, xe = oe + $e(pe, ge++), ue += We(pe, I, ne, xe, he); else if (pe === "object") throw I = String(T), Error("Objects are not valid as a React child (found: " + (I === "[object Object]" ? "object with keys {" + Object.keys(T).join(", ") + "}" : I) + "). If you meant to render a collection of children, use an array instead."); return ue } function _e(T, I, ne) { if (T == null) return T; var oe = [], he = 0; return We(T, oe, "", "", function (pe) { return I.call(ne, pe, he++) }), oe } function Ce(T) { if (T._status === -1) { var I = T._result; I = I(), I.then(function (ne) { (T._status === 0 || T._status === -1) && (T._status = 1, T._result = ne) }, function (ne) { (T._status === 0 || T._status === -1) && (T._status = 2, T._result = ne) }), T._status === -1 && (T._status = 0, T._result = I) } if (T._status === 1) return T._result.default; throw T._result } var ae = { current: null }, _ = { transition: null }, ee = { ReactCurrentDispatcher: ae, ReactCurrentBatchConfig: _, ReactCurrentOwner: J }; function H() { throw Error("act(...) is not supported in production builds of React.") } return de.Children = { map: _e, forEach: function (T, I, ne) { _e(T, function () { I.apply(this, arguments) }, ne) }, count: function (T) { var I = 0; return _e(T, function () { I++ }), I }, toArray: function (T) { return _e(T, function (I) { return I }) || [] }, only: function (T) { if (!ve(T)) throw Error("React.Children.only expected to receive a single React element child."); return T } }, de.Component = A, de.Fragment = o, de.Profiler = l, de.PureComponent = b, de.StrictMode = s, de.Suspense = p, de.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ee, de.act = H, de.cloneElement = function (T, I, ne) { if (T == null) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + T + "."); var oe = M({}, T.props), he = T.key, pe = T.ref, ue = T._owner; if (I != null) { if (I.ref !== void 0 && (pe = I.ref, ue = J.current), I.key !== void 0 && (he = "" + I.key), T.type && T.type.defaultProps) var ge = T.type.defaultProps; for (xe in I) U.call(I, xe) && !se.hasOwnProperty(xe) && (oe[xe] = I[xe] === void 0 && ge !== void 0 ? ge[xe] : I[xe]) } var xe = arguments.length - 2; if (xe === 1) oe.children = ne; else if (1 < xe) { ge = Array(xe); for (var He = 0; He < xe; He++)ge[He] = arguments[He + 2]; oe.children = ge } return { $$typeof: n, type: T.type, key: he, ref: pe, props: oe, _owner: ue } }, de.createContext = function (T) { return T = { $$typeof: c, _currentValue: T, _currentValue2: T, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }, T.Provider = { $$typeof: f, _context: T }, T.Consumer = T }, de.createElement = O, de.createFactory = function (T) { var I = O.bind(null, T); return I.type = T, I }, de.createRef = function () { return { current: null } }, de.forwardRef = function (T) { return { $$typeof: h, render: T } }, de.isValidElement = ve, de.lazy = function (T) { return { $$typeof: y, _payload: { _status: -1, _result: T }, _init: Ce } }, de.memo = function (T, I) { return { $$typeof: g, type: T, compare: I === void 0 ? null : I } }, de.startTransition = function (T) { var I = _.transition; _.transition = {}; try { T() } finally { _.transition = I } }, de.unstable_act = H, de.useCallback = function (T, I) { return ae.current.useCallback(T, I) }, de.useContext = function (T) { return ae.current.useContext(T) }, de.useDebugValue = function () { }, de.useDeferredValue = function (T) { return ae.current.useDeferredValue(T) }, de.useEffect = function (T, I) { return ae.current.useEffect(T, I) }, de.useId = function () { return ae.current.useId() }, de.useImperativeHandle = function (T, I, ne) { return ae.current.useImperativeHandle(T, I, ne) }, de.useInsertionEffect = function (T, I) { return ae.current.useInsertionEffect(T, I) }, de.useLayoutEffect = function (T, I) { return ae.current.useLayoutEffect(T, I) }, de.useMemo = function (T, I) { return ae.current.useMemo(T, I) }, de.useReducer = function (T, I, ne) { return ae.current.useReducer(T, I, ne) }, de.useRef = function (T) { return ae.current.useRef(T) }, de.useState = function (T) { return ae.current.useState(T) }, de.useSyncExternalStore = function (T, I, ne) { return ae.current.useSyncExternalStore(T, I, ne) }, de.useTransition = function () { return ae.current.useTransition() }, de.version = "18.3.1", de } var ch; function Du() { return ch || (ch = 1, Dl.exports = t0()), Dl.exports }/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var fh; function n0() { if (fh) return Mi; fh = 1; var n = Du(), r = Symbol.for("react.element"), o = Symbol.for("react.fragment"), s = Object.prototype.hasOwnProperty, l = n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, f = { key: !0, ref: !0, __self: !0, __source: !0 }; function c(h, p, g) { var y, v = {}, x = null, C = null; g !== void 0 && (x = "" + g), p.key !== void 0 && (x = "" + p.key), p.ref !== void 0 && (C = p.ref); for (y in p) s.call(p, y) && !f.hasOwnProperty(y) && (v[y] = p[y]); if (h && h.defaultProps) for (y in p = h.defaultProps, p) v[y] === void 0 && (v[y] = p[y]); return { $$typeof: r, type: h, key: x, ref: C, props: v, _owner: l.current } } return Mi.Fragment = o, Mi.jsx = c, Mi.jsxs = c, Mi } var dh; function r0() { return dh || (dh = 1, Nl.exports = n0()), Nl.exports } var E = r0(), as = {}, jl = { exports: {} }, ht = {}, Vl = { exports: {} }, _l = {};/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var hh; function i0() { return hh || (hh = 1, (function (n) { function r(_, ee) { var H = _.length; _.push(ee); e: for (; 0 < H;) { var T = H - 1 >>> 1, I = _[T]; if (0 < l(I, ee)) _[T] = ee, _[H] = I, H = T; else break e } } function o(_) { return _.length === 0 ? null : _[0] } function s(_) { if (_.length === 0) return null; var ee = _[0], H = _.pop(); if (H !== ee) { _[0] = H; e: for (var T = 0, I = _.length, ne = I >>> 1; T < ne;) { var oe = 2 * (T + 1) - 1, he = _[oe], pe = oe + 1, ue = _[pe]; if (0 > l(he, H)) pe < I && 0 > l(ue, he) ? (_[T] = ue, _[pe] = H, T = pe) : (_[T] = he, _[oe] = H, T = oe); else if (pe < I && 0 > l(ue, H)) _[T] = ue, _[pe] = H, T = pe; else break e } } return ee } function l(_, ee) { var H = _.sortIndex - ee.sortIndex; return H !== 0 ? H : _.id - ee.id } if (typeof performance == "object" && typeof performance.now == "function") { var f = performance; n.unstable_now = function () { return f.now() } } else { var c = Date, h = c.now(); n.unstable_now = function () { return c.now() - h } } var p = [], g = [], y = 1, v = null, x = 3, C = !1, M = !1, N = !1, A = typeof setTimeout == "function" ? setTimeout : null, V = typeof clearTimeout == "function" ? clearTimeout : null, b = typeof setImmediate < "u" ? setImmediate : null; typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling); function j(_) { for (var ee = o(g); ee !== null;) { if (ee.callback === null) s(g); else if (ee.startTime <= _) s(g), ee.sortIndex = ee.expirationTime, r(p, ee); else break; ee = o(g) } } function W(_) { if (N = !1, j(_), !M) if (o(p) !== null) M = !0, Ce(U); else { var ee = o(g); ee !== null && ae(W, ee.startTime - _) } } function U(_, ee) { M = !1, N && (N = !1, V(O), O = -1), C = !0; var H = x; try { for (j(ee), v = o(p); v !== null && (!(v.expirationTime > ee) || _ && !Xe());) { var T = v.callback; if (typeof T == "function") { v.callback = null, x = v.priorityLevel; var I = T(v.expirationTime <= ee); ee = n.unstable_now(), typeof I == "function" ? v.callback = I : v === o(p) && s(p), j(ee) } else s(p); v = o(p) } if (v !== null) var ne = !0; else { var oe = o(g); oe !== null && ae(W, oe.startTime - ee), ne = !1 } return ne } finally { v = null, x = H, C = !1 } } var J = !1, se = null, O = -1, ce = 5, ve = -1; function Xe() { return !(n.unstable_now() - ve < ce) } function Ue() { if (se !== null) { var _ = n.unstable_now(); ve = _; var ee = !0; try { ee = se(!0, _) } finally { ee ? $e() : (J = !1, se = null) } } else J = !1 } var $e; if (typeof b == "function") $e = function () { b(Ue) }; else if (typeof MessageChannel < "u") { var We = new MessageChannel, _e = We.port2; We.port1.onmessage = Ue, $e = function () { _e.postMessage(null) } } else $e = function () { A(Ue, 0) }; function Ce(_) { se = _, J || (J = !0, $e()) } function ae(_, ee) { O = A(function () { _(n.unstable_now()) }, ee) } n.unstable_IdlePriority = 5, n.unstable_ImmediatePriority = 1, n.unstable_LowPriority = 4, n.unstable_NormalPriority = 3, n.unstable_Profiling = null, n.unstable_UserBlockingPriority = 2, n.unstable_cancelCallback = function (_) { _.callback = null }, n.unstable_continueExecution = function () { M || C || (M = !0, Ce(U)) }, n.unstable_forceFrameRate = function (_) { 0 > _ || 125 < _ ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : ce = 0 < _ ? Math.floor(1e3 / _) : 5 }, n.unstable_getCurrentPriorityLevel = function () { return x }, n.unstable_getFirstCallbackNode = function () { return o(p) }, n.unstable_next = function (_) { switch (x) { case 1: case 2: case 3: var ee = 3; break; default: ee = x }var H = x; x = ee; try { return _() } finally { x = H } }, n.unstable_pauseExecution = function () { }, n.unstable_requestPaint = function () { }, n.unstable_runWithPriority = function (_, ee) { switch (_) { case 1: case 2: case 3: case 4: case 5: break; default: _ = 3 }var H = x; x = _; try { return ee() } finally { x = H } }, n.unstable_scheduleCallback = function (_, ee, H) { var T = n.unstable_now(); switch (typeof H == "object" && H !== null ? (H = H.delay, H = typeof H == "number" && 0 < H ? T + H : T) : H = T, _) { case 1: var I = -1; break; case 2: I = 250; break; case 5: I = 1073741823; break; case 4: I = 1e4; break; default: I = 5e3 }return I = H + I, _ = { id: y++, callback: ee, priorityLevel: _, startTime: H, expirationTime: I, sortIndex: -1 }, H > T ? (_.sortIndex = H, r(g, _), o(p) === null && _ === o(g) && (N ? (V(O), O = -1) : N = !0, ae(W, H - T))) : (_.sortIndex = I, r(p, _), M || C || (M = !0, Ce(U))), _ }, n.unstable_shouldYield = Xe, n.unstable_wrapCallback = function (_) { var ee = x; return function () { var H = x; x = ee; try { return _.apply(this, arguments) } finally { x = H } } } })(_l)), _l } var ph; function o0() { return ph || (ph = 1, Vl.exports = i0()), Vl.exports }/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var mh; function s0() {
    if (mh) return ht; mh = 1; var n = Du(), r = o0(); function o(e) { for (var t = "https://reactjs.org/docs/error-decoder.html?invariant=" + e, i = 1; i < arguments.length; i++)t += "&args[]=" + encodeURIComponent(arguments[i]); return "Minified React error #" + e + "; visit " + t + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings." } var s = new Set, l = {}; function f(e, t) { c(e, t), c(e + "Capture", t) } function c(e, t) { for (l[e] = t, e = 0; e < t.length; e++)s.add(t[e]) } var h = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), p = Object.prototype.hasOwnProperty, g = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, y = {}, v = {}; function x(e) { return p.call(v, e) ? !0 : p.call(y, e) ? !1 : g.test(e) ? v[e] = !0 : (y[e] = !0, !1) } function C(e, t, i, a) { if (i !== null && i.type === 0) return !1; switch (typeof t) { case "function": case "symbol": return !0; case "boolean": return a ? !1 : i !== null ? !i.acceptsBooleans : (e = e.toLowerCase().slice(0, 5), e !== "data-" && e !== "aria-"); default: return !1 } } function M(e, t, i, a) { if (t === null || typeof t > "u" || C(e, t, i, a)) return !0; if (a) return !1; if (i !== null) switch (i.type) { case 3: return !t; case 4: return t === !1; case 5: return isNaN(t); case 6: return isNaN(t) || 1 > t }return !1 } function N(e, t, i, a, u, d, m) { this.acceptsBooleans = t === 2 || t === 3 || t === 4, this.attributeName = a, this.attributeNamespace = u, this.mustUseProperty = i, this.propertyName = e, this.type = t, this.sanitizeURL = d, this.removeEmptyString = m } var A = {}; "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function (e) { A[e] = new N(e, 0, !1, e, null, !1, !1) }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function (e) { var t = e[0]; A[t] = new N(t, 1, !1, e[1], null, !1, !1) }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function (e) { A[e] = new N(e, 2, !1, e.toLowerCase(), null, !1, !1) }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function (e) { A[e] = new N(e, 2, !1, e, null, !1, !1) }), "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function (e) { A[e] = new N(e, 3, !1, e.toLowerCase(), null, !1, !1) }), ["checked", "multiple", "muted", "selected"].forEach(function (e) { A[e] = new N(e, 3, !0, e, null, !1, !1) }), ["capture", "download"].forEach(function (e) { A[e] = new N(e, 4, !1, e, null, !1, !1) }), ["cols", "rows", "size", "span"].forEach(function (e) { A[e] = new N(e, 6, !1, e, null, !1, !1) }), ["rowSpan", "start"].forEach(function (e) { A[e] = new N(e, 5, !1, e.toLowerCase(), null, !1, !1) }); var V = /[\-:]([a-z])/g; function b(e) { return e[1].toUpperCase() } "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function (e) { var t = e.replace(V, b); A[t] = new N(t, 1, !1, e, null, !1, !1) }), "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function (e) { var t = e.replace(V, b); A[t] = new N(t, 1, !1, e, "http://www.w3.org/1999/xlink", !1, !1) }), ["xml:base", "xml:lang", "xml:space"].forEach(function (e) { var t = e.replace(V, b); A[t] = new N(t, 1, !1, e, "http://www.w3.org/XML/1998/namespace", !1, !1) }), ["tabIndex", "crossOrigin"].forEach(function (e) { A[e] = new N(e, 1, !1, e.toLowerCase(), null, !1, !1) }), A.xlinkHref = new N("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1), ["src", "href", "action", "formAction"].forEach(function (e) { A[e] = new N(e, 1, !1, e.toLowerCase(), null, !0, !0) }); function j(e, t, i, a) { var u = A.hasOwnProperty(t) ? A[t] : null; (u !== null ? u.type !== 0 : a || !(2 < t.length) || t[0] !== "o" && t[0] !== "O" || t[1] !== "n" && t[1] !== "N") && (M(t, i, u, a) && (i = null), a || u === null ? x(t) && (i === null ? e.removeAttribute(t) : e.setAttribute(t, "" + i)) : u.mustUseProperty ? e[u.propertyName] = i === null ? u.type === 3 ? !1 : "" : i : (t = u.attributeName, a = u.attributeNamespace, i === null ? e.removeAttribute(t) : (u = u.type, i = u === 3 || u === 4 && i === !0 ? "" : "" + i, a ? e.setAttributeNS(a, t, i) : e.setAttribute(t, i)))) } var W = n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, U = Symbol.for("react.element"), J = Symbol.for("react.portal"), se = Symbol.for("react.fragment"), O = Symbol.for("react.strict_mode"), ce = Symbol.for("react.profiler"), ve = Symbol.for("react.provider"), Xe = Symbol.for("react.context"), Ue = Symbol.for("react.forward_ref"), $e = Symbol.for("react.suspense"), We = Symbol.for("react.suspense_list"), _e = Symbol.for("react.memo"), Ce = Symbol.for("react.lazy"), ae = Symbol.for("react.offscreen"), _ = Symbol.iterator; function ee(e) { return e === null || typeof e != "object" ? null : (e = _ && e[_] || e["@@iterator"], typeof e == "function" ? e : null) } var H = Object.assign, T; function I(e) {
        if (T === void 0) try { throw Error() } catch (i) { var t = i.stack.trim().match(/\n( *(at )?)/); T = t && t[1] || "" } return `
`+ T + e
    } var ne = !1; function oe(e, t) {
        if (!e || ne) return ""; ne = !0; var i = Error.prepareStackTrace; Error.prepareStackTrace = void 0; try { if (t) if (t = function () { throw Error() }, Object.defineProperty(t.prototype, "props", { set: function () { throw Error() } }), typeof Reflect == "object" && Reflect.construct) { try { Reflect.construct(t, []) } catch (D) { var a = D } Reflect.construct(e, [], t) } else { try { t.call() } catch (D) { a = D } e.call(t.prototype) } else { try { throw Error() } catch (D) { a = D } e() } } catch (D) {
            if (D && a && typeof D.stack == "string") {
                for (var u = D.stack.split(`
`), d = a.stack.split(`
`), m = u.length - 1, w = d.length - 1; 1 <= m && 0 <= w && u[m] !== d[w];)w--; for (; 1 <= m && 0 <= w; m--, w--)if (u[m] !== d[w]) {
                    if (m !== 1 || w !== 1) do if (m--, w--, 0 > w || u[m] !== d[w]) {
                        var S = `
`+ u[m].replace(" at new ", " at "); return e.displayName && S.includes("<anonymous>") && (S = S.replace("<anonymous>", e.displayName)), S
                    } while (1 <= m && 0 <= w); break
                }
            }
        } finally { ne = !1, Error.prepareStackTrace = i } return (e = e ? e.displayName || e.name : "") ? I(e) : ""
    } function he(e) { switch (e.tag) { case 5: return I(e.type); case 16: return I("Lazy"); case 13: return I("Suspense"); case 19: return I("SuspenseList"); case 0: case 2: case 15: return e = oe(e.type, !1), e; case 11: return e = oe(e.type.render, !1), e; case 1: return e = oe(e.type, !0), e; default: return "" } } function pe(e) { if (e == null) return null; if (typeof e == "function") return e.displayName || e.name || null; if (typeof e == "string") return e; switch (e) { case se: return "Fragment"; case J: return "Portal"; case ce: return "Profiler"; case O: return "StrictMode"; case $e: return "Suspense"; case We: return "SuspenseList" }if (typeof e == "object") switch (e.$$typeof) { case Xe: return (e.displayName || "Context") + ".Consumer"; case ve: return (e._context.displayName || "Context") + ".Provider"; case Ue: var t = e.render; return e = e.displayName, e || (e = t.displayName || t.name || "", e = e !== "" ? "ForwardRef(" + e + ")" : "ForwardRef"), e; case _e: return t = e.displayName || null, t !== null ? t : pe(e.type) || "Memo"; case Ce: t = e._payload, e = e._init; try { return pe(e(t)) } catch { } }return null } function ue(e) { var t = e.type; switch (e.tag) { case 24: return "Cache"; case 9: return (t.displayName || "Context") + ".Consumer"; case 10: return (t._context.displayName || "Context") + ".Provider"; case 18: return "DehydratedFragment"; case 11: return e = t.render, e = e.displayName || e.name || "", t.displayName || (e !== "" ? "ForwardRef(" + e + ")" : "ForwardRef"); case 7: return "Fragment"; case 5: return t; case 4: return "Portal"; case 3: return "Root"; case 6: return "Text"; case 16: return pe(t); case 8: return t === O ? "StrictMode" : "Mode"; case 22: return "Offscreen"; case 12: return "Profiler"; case 21: return "Scope"; case 13: return "Suspense"; case 19: return "SuspenseList"; case 25: return "TracingMarker"; case 1: case 0: case 17: case 2: case 14: case 15: if (typeof t == "function") return t.displayName || t.name || null; if (typeof t == "string") return t }return null } function ge(e) { switch (typeof e) { case "boolean": case "number": case "string": case "undefined": return e; case "object": return e; default: return "" } } function xe(e) { var t = e.type; return (e = e.nodeName) && e.toLowerCase() === "input" && (t === "checkbox" || t === "radio") } function He(e) { var t = xe(e) ? "checked" : "value", i = Object.getOwnPropertyDescriptor(e.constructor.prototype, t), a = "" + e[t]; if (!e.hasOwnProperty(t) && typeof i < "u" && typeof i.get == "function" && typeof i.set == "function") { var u = i.get, d = i.set; return Object.defineProperty(e, t, { configurable: !0, get: function () { return u.call(this) }, set: function (m) { a = "" + m, d.call(this, m) } }), Object.defineProperty(e, t, { enumerable: i.enumerable }), { getValue: function () { return a }, setValue: function (m) { a = "" + m }, stopTracking: function () { e._valueTracker = null, delete e[t] } } } } function an(e) { e._valueTracker || (e._valueTracker = He(e)) } function _n(e) { if (!e) return !1; var t = e._valueTracker; if (!t) return !0; var i = t.getValue(), a = ""; return e && (a = xe(e) ? e.checked ? "true" : "false" : e.value), e = a, e !== i ? (t.setValue(e), !0) : !1 } function Zi(e) { if (e = e || (typeof document < "u" ? document : void 0), typeof e > "u") return null; try { return e.activeElement || e.body } catch { return e.body } } function Fs(e, t) { var i = t.checked; return H({}, t, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: i ?? e._wrapperState.initialChecked }) } function mc(e, t) { var i = t.defaultValue == null ? "" : t.defaultValue, a = t.checked != null ? t.checked : t.defaultChecked; i = ge(t.value != null ? t.value : i), e._wrapperState = { initialChecked: a, initialValue: i, controlled: t.type === "checkbox" || t.type === "radio" ? t.checked != null : t.value != null } } function gc(e, t) { t = t.checked, t != null && j(e, "checked", t, !1) } function zs(e, t) { gc(e, t); var i = ge(t.value), a = t.type; if (i != null) a === "number" ? (i === 0 && e.value === "" || e.value != i) && (e.value = "" + i) : e.value !== "" + i && (e.value = "" + i); else if (a === "submit" || a === "reset") { e.removeAttribute("value"); return } t.hasOwnProperty("value") ? Os(e, t.type, i) : t.hasOwnProperty("defaultValue") && Os(e, t.type, ge(t.defaultValue)), t.checked == null && t.defaultChecked != null && (e.defaultChecked = !!t.defaultChecked) } function yc(e, t, i) { if (t.hasOwnProperty("value") || t.hasOwnProperty("defaultValue")) { var a = t.type; if (!(a !== "submit" && a !== "reset" || t.value !== void 0 && t.value !== null)) return; t = "" + e._wrapperState.initialValue, i || t === e.value || (e.value = t), e.defaultValue = t } i = e.name, i !== "" && (e.name = ""), e.defaultChecked = !!e._wrapperState.initialChecked, i !== "" && (e.name = i) } function Os(e, t, i) { (t !== "number" || Zi(e.ownerDocument) !== e) && (i == null ? e.defaultValue = "" + e._wrapperState.initialValue : e.defaultValue !== "" + i && (e.defaultValue = "" + i)) } var $r = Array.isArray; function nr(e, t, i, a) { if (e = e.options, t) { t = {}; for (var u = 0; u < i.length; u++)t["$" + i[u]] = !0; for (i = 0; i < e.length; i++)u = t.hasOwnProperty("$" + e[i].value), e[i].selected !== u && (e[i].selected = u), u && a && (e[i].defaultSelected = !0) } else { for (i = "" + ge(i), t = null, u = 0; u < e.length; u++) { if (e[u].value === i) { e[u].selected = !0, a && (e[u].defaultSelected = !0); return } t !== null || e[u].disabled || (t = e[u]) } t !== null && (t.selected = !0) } } function Bs(e, t) { if (t.dangerouslySetInnerHTML != null) throw Error(o(91)); return H({}, t, { value: void 0, defaultValue: void 0, children: "" + e._wrapperState.initialValue }) } function vc(e, t) { var i = t.value; if (i == null) { if (i = t.children, t = t.defaultValue, i != null) { if (t != null) throw Error(o(92)); if ($r(i)) { if (1 < i.length) throw Error(o(93)); i = i[0] } t = i } t == null && (t = ""), i = t } e._wrapperState = { initialValue: ge(i) } } function xc(e, t) { var i = ge(t.value), a = ge(t.defaultValue); i != null && (i = "" + i, i !== e.value && (e.value = i), t.defaultValue == null && e.defaultValue !== i && (e.defaultValue = i)), a != null && (e.defaultValue = "" + a) } function wc(e) { var t = e.textContent; t === e._wrapperState.initialValue && t !== "" && t !== null && (e.value = t) } function Sc(e) { switch (e) { case "svg": return "http://www.w3.org/2000/svg"; case "math": return "http://www.w3.org/1998/Math/MathML"; default: return "http://www.w3.org/1999/xhtml" } } function Us(e, t) { return e == null || e === "http://www.w3.org/1999/xhtml" ? Sc(t) : e === "http://www.w3.org/2000/svg" && t === "foreignObject" ? "http://www.w3.org/1999/xhtml" : e } var qi, kc = (function (e) { return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function (t, i, a, u) { MSApp.execUnsafeLocalFunction(function () { return e(t, i, a, u) }) } : e })(function (e, t) { if (e.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in e) e.innerHTML = t; else { for (qi = qi || document.createElement("div"), qi.innerHTML = "<svg>" + t.valueOf().toString() + "</svg>", t = qi.firstChild; e.firstChild;)e.removeChild(e.firstChild); for (; t.firstChild;)e.appendChild(t.firstChild) } }); function Wr(e, t) { if (t) { var i = e.firstChild; if (i && i === e.lastChild && i.nodeType === 3) { i.nodeValue = t; return } } e.textContent = t } var Hr = { animationIterationCount: !0, aspectRatio: !0, borderImageOutset: !0, borderImageSlice: !0, borderImageWidth: !0, boxFlex: !0, boxFlexGroup: !0, boxOrdinalGroup: !0, columnCount: !0, columns: !0, flex: !0, flexGrow: !0, flexPositive: !0, flexShrink: !0, flexNegative: !0, flexOrder: !0, gridArea: !0, gridRow: !0, gridRowEnd: !0, gridRowSpan: !0, gridRowStart: !0, gridColumn: !0, gridColumnEnd: !0, gridColumnSpan: !0, gridColumnStart: !0, fontWeight: !0, lineClamp: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, tabSize: !0, widows: !0, zIndex: !0, zoom: !0, fillOpacity: !0, floodOpacity: !0, stopOpacity: !0, strokeDasharray: !0, strokeDashoffset: !0, strokeMiterlimit: !0, strokeOpacity: !0, strokeWidth: !0 }, oy = ["Webkit", "ms", "Moz", "O"]; Object.keys(Hr).forEach(function (e) { oy.forEach(function (t) { t = t + e.charAt(0).toUpperCase() + e.substring(1), Hr[t] = Hr[e] }) }); function Cc(e, t, i) { return t == null || typeof t == "boolean" || t === "" ? "" : i || typeof t != "number" || t === 0 || Hr.hasOwnProperty(e) && Hr[e] ? ("" + t).trim() : t + "px" } function Ec(e, t) { e = e.style; for (var i in t) if (t.hasOwnProperty(i)) { var a = i.indexOf("--") === 0, u = Cc(i, t[i], a); i === "float" && (i = "cssFloat"), a ? e.setProperty(i, u) : e[i] = u } } var sy = H({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 }); function $s(e, t) { if (t) { if (sy[e] && (t.children != null || t.dangerouslySetInnerHTML != null)) throw Error(o(137, e)); if (t.dangerouslySetInnerHTML != null) { if (t.children != null) throw Error(o(60)); if (typeof t.dangerouslySetInnerHTML != "object" || !("__html" in t.dangerouslySetInnerHTML)) throw Error(o(61)) } if (t.style != null && typeof t.style != "object") throw Error(o(62)) } } function Ws(e, t) { if (e.indexOf("-") === -1) return typeof t.is == "string"; switch (e) { case "annotation-xml": case "color-profile": case "font-face": case "font-face-src": case "font-face-uri": case "font-face-format": case "font-face-name": case "missing-glyph": return !1; default: return !0 } } var Hs = null; function Ks(e) { return e = e.target || e.srcElement || window, e.correspondingUseElement && (e = e.correspondingUseElement), e.nodeType === 3 ? e.parentNode : e } var Gs = null, rr = null, ir = null; function Tc(e) { if (e = hi(e)) { if (typeof Gs != "function") throw Error(o(280)); var t = e.stateNode; t && (t = ko(t), Gs(e.stateNode, e.type, t)) } } function Pc(e) { rr ? ir ? ir.push(e) : ir = [e] : rr = e } function Rc() { if (rr) { var e = rr, t = ir; if (ir = rr = null, Tc(e), t) for (e = 0; e < t.length; e++)Tc(t[e]) } } function Mc(e, t) { return e(t) } function Ac() { } var Ys = !1; function Lc(e, t, i) { if (Ys) return e(t, i); Ys = !0; try { return Mc(e, t, i) } finally { Ys = !1, (rr !== null || ir !== null) && (Ac(), Rc()) } } function Kr(e, t) { var i = e.stateNode; if (i === null) return null; var a = ko(i); if (a === null) return null; i = a[t]; e: switch (t) { case "onClick": case "onClickCapture": case "onDoubleClick": case "onDoubleClickCapture": case "onMouseDown": case "onMouseDownCapture": case "onMouseMove": case "onMouseMoveCapture": case "onMouseUp": case "onMouseUpCapture": case "onMouseEnter": (a = !a.disabled) || (e = e.type, a = !(e === "button" || e === "input" || e === "select" || e === "textarea")), e = !a; break e; default: e = !1 }if (e) return null; if (i && typeof i != "function") throw Error(o(231, t, typeof i)); return i } var Xs = !1; if (h) try { var Gr = {}; Object.defineProperty(Gr, "passive", { get: function () { Xs = !0 } }), window.addEventListener("test", Gr, Gr), window.removeEventListener("test", Gr, Gr) } catch { Xs = !1 } function ay(e, t, i, a, u, d, m, w, S) { var D = Array.prototype.slice.call(arguments, 3); try { t.apply(i, D) } catch (z) { this.onError(z) } } var Yr = !1, Ji = null, eo = !1, Qs = null, ly = { onError: function (e) { Yr = !0, Ji = e } }; function uy(e, t, i, a, u, d, m, w, S) { Yr = !1, Ji = null, ay.apply(ly, arguments) } function cy(e, t, i, a, u, d, m, w, S) { if (uy.apply(this, arguments), Yr) { if (Yr) { var D = Ji; Yr = !1, Ji = null } else throw Error(o(198)); eo || (eo = !0, Qs = D) } } function bn(e) { var t = e, i = e; if (e.alternate) for (; t.return;)t = t.return; else { e = t; do t = e, (t.flags & 4098) !== 0 && (i = t.return), e = t.return; while (e) } return t.tag === 3 ? i : null } function Nc(e) { if (e.tag === 13) { var t = e.memoizedState; if (t === null && (e = e.alternate, e !== null && (t = e.memoizedState)), t !== null) return t.dehydrated } return null } function Dc(e) { if (bn(e) !== e) throw Error(o(188)) } function fy(e) { var t = e.alternate; if (!t) { if (t = bn(e), t === null) throw Error(o(188)); return t !== e ? null : e } for (var i = e, a = t; ;) { var u = i.return; if (u === null) break; var d = u.alternate; if (d === null) { if (a = u.return, a !== null) { i = a; continue } break } if (u.child === d.child) { for (d = u.child; d;) { if (d === i) return Dc(u), e; if (d === a) return Dc(u), t; d = d.sibling } throw Error(o(188)) } if (i.return !== a.return) i = u, a = d; else { for (var m = !1, w = u.child; w;) { if (w === i) { m = !0, i = u, a = d; break } if (w === a) { m = !0, a = u, i = d; break } w = w.sibling } if (!m) { for (w = d.child; w;) { if (w === i) { m = !0, i = d, a = u; break } if (w === a) { m = !0, a = d, i = u; break } w = w.sibling } if (!m) throw Error(o(189)) } } if (i.alternate !== a) throw Error(o(190)) } if (i.tag !== 3) throw Error(o(188)); return i.stateNode.current === i ? e : t } function jc(e) { return e = fy(e), e !== null ? Vc(e) : null } function Vc(e) { if (e.tag === 5 || e.tag === 6) return e; for (e = e.child; e !== null;) { var t = Vc(e); if (t !== null) return t; e = e.sibling } return null } var _c = r.unstable_scheduleCallback, bc = r.unstable_cancelCallback, dy = r.unstable_shouldYield, hy = r.unstable_requestPaint, je = r.unstable_now, py = r.unstable_getCurrentPriorityLevel, Zs = r.unstable_ImmediatePriority, Ic = r.unstable_UserBlockingPriority, to = r.unstable_NormalPriority, my = r.unstable_LowPriority, Fc = r.unstable_IdlePriority, no = null, Ft = null; function gy(e) { if (Ft && typeof Ft.onCommitFiberRoot == "function") try { Ft.onCommitFiberRoot(no, e, void 0, (e.current.flags & 128) === 128) } catch { } } var Rt = Math.clz32 ? Math.clz32 : xy, yy = Math.log, vy = Math.LN2; function xy(e) { return e >>>= 0, e === 0 ? 32 : 31 - (yy(e) / vy | 0) | 0 } var ro = 64, io = 4194304; function Xr(e) { switch (e & -e) { case 1: return 1; case 2: return 2; case 4: return 4; case 8: return 8; case 16: return 16; case 32: return 32; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return e & 4194240; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return e & 130023424; case 134217728: return 134217728; case 268435456: return 268435456; case 536870912: return 536870912; case 1073741824: return 1073741824; default: return e } } function oo(e, t) { var i = e.pendingLanes; if (i === 0) return 0; var a = 0, u = e.suspendedLanes, d = e.pingedLanes, m = i & 268435455; if (m !== 0) { var w = m & ~u; w !== 0 ? a = Xr(w) : (d &= m, d !== 0 && (a = Xr(d))) } else m = i & ~u, m !== 0 ? a = Xr(m) : d !== 0 && (a = Xr(d)); if (a === 0) return 0; if (t !== 0 && t !== a && (t & u) === 0 && (u = a & -a, d = t & -t, u >= d || u === 16 && (d & 4194240) !== 0)) return t; if ((a & 4) !== 0 && (a |= i & 16), t = e.entangledLanes, t !== 0) for (e = e.entanglements, t &= a; 0 < t;)i = 31 - Rt(t), u = 1 << i, a |= e[i], t &= ~u; return a } function wy(e, t) { switch (e) { case 1: case 2: case 4: return t + 250; case 8: case 16: case 32: case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return t + 5e3; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return -1; case 134217728: case 268435456: case 536870912: case 1073741824: return -1; default: return -1 } } function Sy(e, t) { for (var i = e.suspendedLanes, a = e.pingedLanes, u = e.expirationTimes, d = e.pendingLanes; 0 < d;) { var m = 31 - Rt(d), w = 1 << m, S = u[m]; S === -1 ? ((w & i) === 0 || (w & a) !== 0) && (u[m] = wy(w, t)) : S <= t && (e.expiredLanes |= w), d &= ~w } } function qs(e) { return e = e.pendingLanes & -1073741825, e !== 0 ? e : e & 1073741824 ? 1073741824 : 0 } function zc() { var e = ro; return ro <<= 1, (ro & 4194240) === 0 && (ro = 64), e } function Js(e) { for (var t = [], i = 0; 31 > i; i++)t.push(e); return t } function Qr(e, t, i) { e.pendingLanes |= t, t !== 536870912 && (e.suspendedLanes = 0, e.pingedLanes = 0), e = e.eventTimes, t = 31 - Rt(t), e[t] = i } function ky(e, t) { var i = e.pendingLanes & ~t; e.pendingLanes = t, e.suspendedLanes = 0, e.pingedLanes = 0, e.expiredLanes &= t, e.mutableReadLanes &= t, e.entangledLanes &= t, t = e.entanglements; var a = e.eventTimes; for (e = e.expirationTimes; 0 < i;) { var u = 31 - Rt(i), d = 1 << u; t[u] = 0, a[u] = -1, e[u] = -1, i &= ~d } } function ea(e, t) { var i = e.entangledLanes |= t; for (e = e.entanglements; i;) { var a = 31 - Rt(i), u = 1 << a; u & t | e[a] & t && (e[a] |= t), i &= ~u } } var we = 0; function Oc(e) { return e &= -e, 1 < e ? 4 < e ? (e & 268435455) !== 0 ? 16 : 536870912 : 4 : 1 } var Bc, ta, Uc, $c, Wc, na = !1, so = [], ln = null, un = null, cn = null, Zr = new Map, qr = new Map, fn = [], Cy = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" "); function Hc(e, t) { switch (e) { case "focusin": case "focusout": ln = null; break; case "dragenter": case "dragleave": un = null; break; case "mouseover": case "mouseout": cn = null; break; case "pointerover": case "pointerout": Zr.delete(t.pointerId); break; case "gotpointercapture": case "lostpointercapture": qr.delete(t.pointerId) } } function Jr(e, t, i, a, u, d) { return e === null || e.nativeEvent !== d ? (e = { blockedOn: t, domEventName: i, eventSystemFlags: a, nativeEvent: d, targetContainers: [u] }, t !== null && (t = hi(t), t !== null && ta(t)), e) : (e.eventSystemFlags |= a, t = e.targetContainers, u !== null && t.indexOf(u) === -1 && t.push(u), e) } function Ey(e, t, i, a, u) { switch (t) { case "focusin": return ln = Jr(ln, e, t, i, a, u), !0; case "dragenter": return un = Jr(un, e, t, i, a, u), !0; case "mouseover": return cn = Jr(cn, e, t, i, a, u), !0; case "pointerover": var d = u.pointerId; return Zr.set(d, Jr(Zr.get(d) || null, e, t, i, a, u)), !0; case "gotpointercapture": return d = u.pointerId, qr.set(d, Jr(qr.get(d) || null, e, t, i, a, u)), !0 }return !1 } function Kc(e) { var t = In(e.target); if (t !== null) { var i = bn(t); if (i !== null) { if (t = i.tag, t === 13) { if (t = Nc(i), t !== null) { e.blockedOn = t, Wc(e.priority, function () { Uc(i) }); return } } else if (t === 3 && i.stateNode.current.memoizedState.isDehydrated) { e.blockedOn = i.tag === 3 ? i.stateNode.containerInfo : null; return } } } e.blockedOn = null } function ao(e) { if (e.blockedOn !== null) return !1; for (var t = e.targetContainers; 0 < t.length;) { var i = ia(e.domEventName, e.eventSystemFlags, t[0], e.nativeEvent); if (i === null) { i = e.nativeEvent; var a = new i.constructor(i.type, i); Hs = a, i.target.dispatchEvent(a), Hs = null } else return t = hi(i), t !== null && ta(t), e.blockedOn = i, !1; t.shift() } return !0 } function Gc(e, t, i) { ao(e) && i.delete(t) } function Ty() { na = !1, ln !== null && ao(ln) && (ln = null), un !== null && ao(un) && (un = null), cn !== null && ao(cn) && (cn = null), Zr.forEach(Gc), qr.forEach(Gc) } function ei(e, t) { e.blockedOn === t && (e.blockedOn = null, na || (na = !0, r.unstable_scheduleCallback(r.unstable_NormalPriority, Ty))) } function ti(e) { function t(u) { return ei(u, e) } if (0 < so.length) { ei(so[0], e); for (var i = 1; i < so.length; i++) { var a = so[i]; a.blockedOn === e && (a.blockedOn = null) } } for (ln !== null && ei(ln, e), un !== null && ei(un, e), cn !== null && ei(cn, e), Zr.forEach(t), qr.forEach(t), i = 0; i < fn.length; i++)a = fn[i], a.blockedOn === e && (a.blockedOn = null); for (; 0 < fn.length && (i = fn[0], i.blockedOn === null);)Kc(i), i.blockedOn === null && fn.shift() } var or = W.ReactCurrentBatchConfig, lo = !0; function Py(e, t, i, a) { var u = we, d = or.transition; or.transition = null; try { we = 1, ra(e, t, i, a) } finally { we = u, or.transition = d } } function Ry(e, t, i, a) { var u = we, d = or.transition; or.transition = null; try { we = 4, ra(e, t, i, a) } finally { we = u, or.transition = d } } function ra(e, t, i, a) { if (lo) { var u = ia(e, t, i, a); if (u === null) Sa(e, t, a, uo, i), Hc(e, a); else if (Ey(u, e, t, i, a)) a.stopPropagation(); else if (Hc(e, a), t & 4 && -1 < Cy.indexOf(e)) { for (; u !== null;) { var d = hi(u); if (d !== null && Bc(d), d = ia(e, t, i, a), d === null && Sa(e, t, a, uo, i), d === u) break; u = d } u !== null && a.stopPropagation() } else Sa(e, t, a, null, i) } } var uo = null; function ia(e, t, i, a) { if (uo = null, e = Ks(a), e = In(e), e !== null) if (t = bn(e), t === null) e = null; else if (i = t.tag, i === 13) { if (e = Nc(t), e !== null) return e; e = null } else if (i === 3) { if (t.stateNode.current.memoizedState.isDehydrated) return t.tag === 3 ? t.stateNode.containerInfo : null; e = null } else t !== e && (e = null); return uo = e, null } function Yc(e) { switch (e) { case "cancel": case "click": case "close": case "contextmenu": case "copy": case "cut": case "auxclick": case "dblclick": case "dragend": case "dragstart": case "drop": case "focusin": case "focusout": case "input": case "invalid": case "keydown": case "keypress": case "keyup": case "mousedown": case "mouseup": case "paste": case "pause": case "play": case "pointercancel": case "pointerdown": case "pointerup": case "ratechange": case "reset": case "resize": case "seeked": case "submit": case "touchcancel": case "touchend": case "touchstart": case "volumechange": case "change": case "selectionchange": case "textInput": case "compositionstart": case "compositionend": case "compositionupdate": case "beforeblur": case "afterblur": case "beforeinput": case "blur": case "fullscreenchange": case "focus": case "hashchange": case "popstate": case "select": case "selectstart": return 1; case "drag": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "mousemove": case "mouseout": case "mouseover": case "pointermove": case "pointerout": case "pointerover": case "scroll": case "toggle": case "touchmove": case "wheel": case "mouseenter": case "mouseleave": case "pointerenter": case "pointerleave": return 4; case "message": switch (py()) { case Zs: return 1; case Ic: return 4; case to: case my: return 16; case Fc: return 536870912; default: return 16 }default: return 16 } } var dn = null, oa = null, co = null; function Xc() { if (co) return co; var e, t = oa, i = t.length, a, u = "value" in dn ? dn.value : dn.textContent, d = u.length; for (e = 0; e < i && t[e] === u[e]; e++); var m = i - e; for (a = 1; a <= m && t[i - a] === u[d - a]; a++); return co = u.slice(e, 1 < a ? 1 - a : void 0) } function fo(e) { var t = e.keyCode; return "charCode" in e ? (e = e.charCode, e === 0 && t === 13 && (e = 13)) : e = t, e === 10 && (e = 13), 32 <= e || e === 13 ? e : 0 } function ho() { return !0 } function Qc() { return !1 } function pt(e) { function t(i, a, u, d, m) { this._reactName = i, this._targetInst = u, this.type = a, this.nativeEvent = d, this.target = m, this.currentTarget = null; for (var w in e) e.hasOwnProperty(w) && (i = e[w], this[w] = i ? i(d) : d[w]); return this.isDefaultPrevented = (d.defaultPrevented != null ? d.defaultPrevented : d.returnValue === !1) ? ho : Qc, this.isPropagationStopped = Qc, this } return H(t.prototype, { preventDefault: function () { this.defaultPrevented = !0; var i = this.nativeEvent; i && (i.preventDefault ? i.preventDefault() : typeof i.returnValue != "unknown" && (i.returnValue = !1), this.isDefaultPrevented = ho) }, stopPropagation: function () { var i = this.nativeEvent; i && (i.stopPropagation ? i.stopPropagation() : typeof i.cancelBubble != "unknown" && (i.cancelBubble = !0), this.isPropagationStopped = ho) }, persist: function () { }, isPersistent: ho }), t } var sr = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function (e) { return e.timeStamp || Date.now() }, defaultPrevented: 0, isTrusted: 0 }, sa = pt(sr), ni = H({}, sr, { view: 0, detail: 0 }), My = pt(ni), aa, la, ri, po = H({}, ni, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: ca, button: 0, buttons: 0, relatedTarget: function (e) { return e.relatedTarget === void 0 ? e.fromElement === e.srcElement ? e.toElement : e.fromElement : e.relatedTarget }, movementX: function (e) { return "movementX" in e ? e.movementX : (e !== ri && (ri && e.type === "mousemove" ? (aa = e.screenX - ri.screenX, la = e.screenY - ri.screenY) : la = aa = 0, ri = e), aa) }, movementY: function (e) { return "movementY" in e ? e.movementY : la } }), Zc = pt(po), Ay = H({}, po, { dataTransfer: 0 }), Ly = pt(Ay), Ny = H({}, ni, { relatedTarget: 0 }), ua = pt(Ny), Dy = H({}, sr, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), jy = pt(Dy), Vy = H({}, sr, { clipboardData: function (e) { return "clipboardData" in e ? e.clipboardData : window.clipboardData } }), _y = pt(Vy), by = H({}, sr, { data: 0 }), qc = pt(by), Iy = { Esc: "Escape", Spacebar: " ", Left: "ArrowLeft", Up: "ArrowUp", Right: "ArrowRight", Down: "ArrowDown", Del: "Delete", Win: "OS", Menu: "ContextMenu", Apps: "ContextMenu", Scroll: "ScrollLock", MozPrintableKey: "Unidentified" }, Fy = { 8: "Backspace", 9: "Tab", 12: "Clear", 13: "Enter", 16: "Shift", 17: "Control", 18: "Alt", 19: "Pause", 20: "CapsLock", 27: "Escape", 32: " ", 33: "PageUp", 34: "PageDown", 35: "End", 36: "Home", 37: "ArrowLeft", 38: "ArrowUp", 39: "ArrowRight", 40: "ArrowDown", 45: "Insert", 46: "Delete", 112: "F1", 113: "F2", 114: "F3", 115: "F4", 116: "F5", 117: "F6", 118: "F7", 119: "F8", 120: "F9", 121: "F10", 122: "F11", 123: "F12", 144: "NumLock", 145: "ScrollLock", 224: "Meta" }, zy = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" }; function Oy(e) { var t = this.nativeEvent; return t.getModifierState ? t.getModifierState(e) : (e = zy[e]) ? !!t[e] : !1 } function ca() { return Oy } var By = H({}, ni, { key: function (e) { if (e.key) { var t = Iy[e.key] || e.key; if (t !== "Unidentified") return t } return e.type === "keypress" ? (e = fo(e), e === 13 ? "Enter" : String.fromCharCode(e)) : e.type === "keydown" || e.type === "keyup" ? Fy[e.keyCode] || "Unidentified" : "" }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: ca, charCode: function (e) { return e.type === "keypress" ? fo(e) : 0 }, keyCode: function (e) { return e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0 }, which: function (e) { return e.type === "keypress" ? fo(e) : e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0 } }), Uy = pt(By), $y = H({}, po, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Jc = pt($y), Wy = H({}, ni, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: ca }), Hy = pt(Wy), Ky = H({}, sr, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Gy = pt(Ky), Yy = H({}, po, { deltaX: function (e) { return "deltaX" in e ? e.deltaX : "wheelDeltaX" in e ? -e.wheelDeltaX : 0 }, deltaY: function (e) { return "deltaY" in e ? e.deltaY : "wheelDeltaY" in e ? -e.wheelDeltaY : "wheelDelta" in e ? -e.wheelDelta : 0 }, deltaZ: 0, deltaMode: 0 }), Xy = pt(Yy), Qy = [9, 13, 27, 32], fa = h && "CompositionEvent" in window, ii = null; h && "documentMode" in document && (ii = document.documentMode); var Zy = h && "TextEvent" in window && !ii, ef = h && (!fa || ii && 8 < ii && 11 >= ii), tf = " ", nf = !1; function rf(e, t) { switch (e) { case "keyup": return Qy.indexOf(t.keyCode) !== -1; case "keydown": return t.keyCode !== 229; case "keypress": case "mousedown": case "focusout": return !0; default: return !1 } } function of(e) { return e = e.detail, typeof e == "object" && "data" in e ? e.data : null } var ar = !1; function qy(e, t) { switch (e) { case "compositionend": return of(t); case "keypress": return t.which !== 32 ? null : (nf = !0, tf); case "textInput": return e = t.data, e === tf && nf ? null : e; default: return null } } function Jy(e, t) { if (ar) return e === "compositionend" || !fa && rf(e, t) ? (e = Xc(), co = oa = dn = null, ar = !1, e) : null; switch (e) { case "paste": return null; case "keypress": if (!(t.ctrlKey || t.altKey || t.metaKey) || t.ctrlKey && t.altKey) { if (t.char && 1 < t.char.length) return t.char; if (t.which) return String.fromCharCode(t.which) } return null; case "compositionend": return ef && t.locale !== "ko" ? null : t.data; default: return null } } var ev = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 }; function sf(e) { var t = e && e.nodeName && e.nodeName.toLowerCase(); return t === "input" ? !!ev[e.type] : t === "textarea" } function af(e, t, i, a) { Pc(a), t = xo(t, "onChange"), 0 < t.length && (i = new sa("onChange", "change", null, i, a), e.push({ event: i, listeners: t })) } var oi = null, si = null; function tv(e) { Tf(e, 0) } function mo(e) { var t = dr(e); if (_n(t)) return e } function nv(e, t) { if (e === "change") return t } var lf = !1; if (h) { var da; if (h) { var ha = "oninput" in document; if (!ha) { var uf = document.createElement("div"); uf.setAttribute("oninput", "return;"), ha = typeof uf.oninput == "function" } da = ha } else da = !1; lf = da && (!document.documentMode || 9 < document.documentMode) } function cf() { oi && (oi.detachEvent("onpropertychange", ff), si = oi = null) } function ff(e) { if (e.propertyName === "value" && mo(si)) { var t = []; af(t, si, e, Ks(e)), Lc(tv, t) } } function rv(e, t, i) { e === "focusin" ? (cf(), oi = t, si = i, oi.attachEvent("onpropertychange", ff)) : e === "focusout" && cf() } function iv(e) { if (e === "selectionchange" || e === "keyup" || e === "keydown") return mo(si) } function ov(e, t) { if (e === "click") return mo(t) } function sv(e, t) { if (e === "input" || e === "change") return mo(t) } function av(e, t) { return e === t && (e !== 0 || 1 / e === 1 / t) || e !== e && t !== t } var Mt = typeof Object.is == "function" ? Object.is : av; function ai(e, t) { if (Mt(e, t)) return !0; if (typeof e != "object" || e === null || typeof t != "object" || t === null) return !1; var i = Object.keys(e), a = Object.keys(t); if (i.length !== a.length) return !1; for (a = 0; a < i.length; a++) { var u = i[a]; if (!p.call(t, u) || !Mt(e[u], t[u])) return !1 } return !0 } function df(e) { for (; e && e.firstChild;)e = e.firstChild; return e } function hf(e, t) { var i = df(e); e = 0; for (var a; i;) { if (i.nodeType === 3) { if (a = e + i.textContent.length, e <= t && a >= t) return { node: i, offset: t - e }; e = a } e: { for (; i;) { if (i.nextSibling) { i = i.nextSibling; break e } i = i.parentNode } i = void 0 } i = df(i) } } function pf(e, t) { return e && t ? e === t ? !0 : e && e.nodeType === 3 ? !1 : t && t.nodeType === 3 ? pf(e, t.parentNode) : "contains" in e ? e.contains(t) : e.compareDocumentPosition ? !!(e.compareDocumentPosition(t) & 16) : !1 : !1 } function mf() { for (var e = window, t = Zi(); t instanceof e.HTMLIFrameElement;) { try { var i = typeof t.contentWindow.location.href == "string" } catch { i = !1 } if (i) e = t.contentWindow; else break; t = Zi(e.document) } return t } function pa(e) { var t = e && e.nodeName && e.nodeName.toLowerCase(); return t && (t === "input" && (e.type === "text" || e.type === "search" || e.type === "tel" || e.type === "url" || e.type === "password") || t === "textarea" || e.contentEditable === "true") } function lv(e) { var t = mf(), i = e.focusedElem, a = e.selectionRange; if (t !== i && i && i.ownerDocument && pf(i.ownerDocument.documentElement, i)) { if (a !== null && pa(i)) { if (t = a.start, e = a.end, e === void 0 && (e = t), "selectionStart" in i) i.selectionStart = t, i.selectionEnd = Math.min(e, i.value.length); else if (e = (t = i.ownerDocument || document) && t.defaultView || window, e.getSelection) { e = e.getSelection(); var u = i.textContent.length, d = Math.min(a.start, u); a = a.end === void 0 ? d : Math.min(a.end, u), !e.extend && d > a && (u = a, a = d, d = u), u = hf(i, d); var m = hf(i, a); u && m && (e.rangeCount !== 1 || e.anchorNode !== u.node || e.anchorOffset !== u.offset || e.focusNode !== m.node || e.focusOffset !== m.offset) && (t = t.createRange(), t.setStart(u.node, u.offset), e.removeAllRanges(), d > a ? (e.addRange(t), e.extend(m.node, m.offset)) : (t.setEnd(m.node, m.offset), e.addRange(t))) } } for (t = [], e = i; e = e.parentNode;)e.nodeType === 1 && t.push({ element: e, left: e.scrollLeft, top: e.scrollTop }); for (typeof i.focus == "function" && i.focus(), i = 0; i < t.length; i++)e = t[i], e.element.scrollLeft = e.left, e.element.scrollTop = e.top } } var uv = h && "documentMode" in document && 11 >= document.documentMode, lr = null, ma = null, li = null, ga = !1; function gf(e, t, i) { var a = i.window === i ? i.document : i.nodeType === 9 ? i : i.ownerDocument; ga || lr == null || lr !== Zi(a) || (a = lr, "selectionStart" in a && pa(a) ? a = { start: a.selectionStart, end: a.selectionEnd } : (a = (a.ownerDocument && a.ownerDocument.defaultView || window).getSelection(), a = { anchorNode: a.anchorNode, anchorOffset: a.anchorOffset, focusNode: a.focusNode, focusOffset: a.focusOffset }), li && ai(li, a) || (li = a, a = xo(ma, "onSelect"), 0 < a.length && (t = new sa("onSelect", "select", null, t, i), e.push({ event: t, listeners: a }), t.target = lr))) } function go(e, t) { var i = {}; return i[e.toLowerCase()] = t.toLowerCase(), i["Webkit" + e] = "webkit" + t, i["Moz" + e] = "moz" + t, i } var ur = { animationend: go("Animation", "AnimationEnd"), animationiteration: go("Animation", "AnimationIteration"), animationstart: go("Animation", "AnimationStart"), transitionend: go("Transition", "TransitionEnd") }, ya = {}, yf = {}; h && (yf = document.createElement("div").style, "AnimationEvent" in window || (delete ur.animationend.animation, delete ur.animationiteration.animation, delete ur.animationstart.animation), "TransitionEvent" in window || delete ur.transitionend.transition); function yo(e) { if (ya[e]) return ya[e]; if (!ur[e]) return e; var t = ur[e], i; for (i in t) if (t.hasOwnProperty(i) && i in yf) return ya[e] = t[i]; return e } var vf = yo("animationend"), xf = yo("animationiteration"), wf = yo("animationstart"), Sf = yo("transitionend"), kf = new Map, Cf = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" "); function hn(e, t) { kf.set(e, t), f(t, [e]) } for (var va = 0; va < Cf.length; va++) { var xa = Cf[va], cv = xa.toLowerCase(), fv = xa[0].toUpperCase() + xa.slice(1); hn(cv, "on" + fv) } hn(vf, "onAnimationEnd"), hn(xf, "onAnimationIteration"), hn(wf, "onAnimationStart"), hn("dblclick", "onDoubleClick"), hn("focusin", "onFocus"), hn("focusout", "onBlur"), hn(Sf, "onTransitionEnd"), c("onMouseEnter", ["mouseout", "mouseover"]), c("onMouseLeave", ["mouseout", "mouseover"]), c("onPointerEnter", ["pointerout", "pointerover"]), c("onPointerLeave", ["pointerout", "pointerover"]), f("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")), f("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")), f("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), f("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")), f("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")), f("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" ")); var ui = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), dv = new Set("cancel close invalid load scroll toggle".split(" ").concat(ui)); function Ef(e, t, i) { var a = e.type || "unknown-event"; e.currentTarget = i, cy(a, t, void 0, e), e.currentTarget = null } function Tf(e, t) { t = (t & 4) !== 0; for (var i = 0; i < e.length; i++) { var a = e[i], u = a.event; a = a.listeners; e: { var d = void 0; if (t) for (var m = a.length - 1; 0 <= m; m--) { var w = a[m], S = w.instance, D = w.currentTarget; if (w = w.listener, S !== d && u.isPropagationStopped()) break e; Ef(u, w, D), d = S } else for (m = 0; m < a.length; m++) { if (w = a[m], S = w.instance, D = w.currentTarget, w = w.listener, S !== d && u.isPropagationStopped()) break e; Ef(u, w, D), d = S } } } if (eo) throw e = Qs, eo = !1, Qs = null, e } function Ee(e, t) { var i = t[Ra]; i === void 0 && (i = t[Ra] = new Set); var a = e + "__bubble"; i.has(a) || (Pf(t, e, 2, !1), i.add(a)) } function wa(e, t, i) { var a = 0; t && (a |= 4), Pf(i, e, a, t) } var vo = "_reactListening" + Math.random().toString(36).slice(2); function ci(e) { if (!e[vo]) { e[vo] = !0, s.forEach(function (i) { i !== "selectionchange" && (dv.has(i) || wa(i, !1, e), wa(i, !0, e)) }); var t = e.nodeType === 9 ? e : e.ownerDocument; t === null || t[vo] || (t[vo] = !0, wa("selectionchange", !1, t)) } } function Pf(e, t, i, a) { switch (Yc(t)) { case 1: var u = Py; break; case 4: u = Ry; break; default: u = ra }i = u.bind(null, t, i, e), u = void 0, !Xs || t !== "touchstart" && t !== "touchmove" && t !== "wheel" || (u = !0), a ? u !== void 0 ? e.addEventListener(t, i, { capture: !0, passive: u }) : e.addEventListener(t, i, !0) : u !== void 0 ? e.addEventListener(t, i, { passive: u }) : e.addEventListener(t, i, !1) } function Sa(e, t, i, a, u) { var d = a; if ((t & 1) === 0 && (t & 2) === 0 && a !== null) e: for (; ;) { if (a === null) return; var m = a.tag; if (m === 3 || m === 4) { var w = a.stateNode.containerInfo; if (w === u || w.nodeType === 8 && w.parentNode === u) break; if (m === 4) for (m = a.return; m !== null;) { var S = m.tag; if ((S === 3 || S === 4) && (S = m.stateNode.containerInfo, S === u || S.nodeType === 8 && S.parentNode === u)) return; m = m.return } for (; w !== null;) { if (m = In(w), m === null) return; if (S = m.tag, S === 5 || S === 6) { a = d = m; continue e } w = w.parentNode } } a = a.return } Lc(function () { var D = d, z = Ks(i), B = []; e: { var F = kf.get(e); if (F !== void 0) { var K = sa, Y = e; switch (e) { case "keypress": if (fo(i) === 0) break e; case "keydown": case "keyup": K = Uy; break; case "focusin": Y = "focus", K = ua; break; case "focusout": Y = "blur", K = ua; break; case "beforeblur": case "afterblur": K = ua; break; case "click": if (i.button === 2) break e; case "auxclick": case "dblclick": case "mousedown": case "mousemove": case "mouseup": case "mouseout": case "mouseover": case "contextmenu": K = Zc; break; case "drag": case "dragend": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "dragstart": case "drop": K = Ly; break; case "touchcancel": case "touchend": case "touchmove": case "touchstart": K = Hy; break; case vf: case xf: case wf: K = jy; break; case Sf: K = Gy; break; case "scroll": K = My; break; case "wheel": K = Xy; break; case "copy": case "cut": case "paste": K = _y; break; case "gotpointercapture": case "lostpointercapture": case "pointercancel": case "pointerdown": case "pointermove": case "pointerout": case "pointerover": case "pointerup": K = Jc }var q = (t & 4) !== 0, Ve = !q && e === "scroll", R = q ? F !== null ? F + "Capture" : null : F; q = []; for (var k = D, L; k !== null;) { L = k; var $ = L.stateNode; if (L.tag === 5 && $ !== null && (L = $, R !== null && ($ = Kr(k, R), $ != null && q.push(fi(k, $, L)))), Ve) break; k = k.return } 0 < q.length && (F = new K(F, Y, null, i, z), B.push({ event: F, listeners: q })) } } if ((t & 7) === 0) { e: { if (F = e === "mouseover" || e === "pointerover", K = e === "mouseout" || e === "pointerout", F && i !== Hs && (Y = i.relatedTarget || i.fromElement) && (In(Y) || Y[Gt])) break e; if ((K || F) && (F = z.window === z ? z : (F = z.ownerDocument) ? F.defaultView || F.parentWindow : window, K ? (Y = i.relatedTarget || i.toElement, K = D, Y = Y ? In(Y) : null, Y !== null && (Ve = bn(Y), Y !== Ve || Y.tag !== 5 && Y.tag !== 6) && (Y = null)) : (K = null, Y = D), K !== Y)) { if (q = Zc, $ = "onMouseLeave", R = "onMouseEnter", k = "mouse", (e === "pointerout" || e === "pointerover") && (q = Jc, $ = "onPointerLeave", R = "onPointerEnter", k = "pointer"), Ve = K == null ? F : dr(K), L = Y == null ? F : dr(Y), F = new q($, k + "leave", K, i, z), F.target = Ve, F.relatedTarget = L, $ = null, In(z) === D && (q = new q(R, k + "enter", Y, i, z), q.target = L, q.relatedTarget = Ve, $ = q), Ve = $, K && Y) t: { for (q = K, R = Y, k = 0, L = q; L; L = cr(L))k++; for (L = 0, $ = R; $; $ = cr($))L++; for (; 0 < k - L;)q = cr(q), k--; for (; 0 < L - k;)R = cr(R), L--; for (; k--;) { if (q === R || R !== null && q === R.alternate) break t; q = cr(q), R = cr(R) } q = null } else q = null; K !== null && Rf(B, F, K, q, !1), Y !== null && Ve !== null && Rf(B, Ve, Y, q, !0) } } e: { if (F = D ? dr(D) : window, K = F.nodeName && F.nodeName.toLowerCase(), K === "select" || K === "input" && F.type === "file") var te = nv; else if (sf(F)) if (lf) te = sv; else { te = iv; var re = rv } else (K = F.nodeName) && K.toLowerCase() === "input" && (F.type === "checkbox" || F.type === "radio") && (te = ov); if (te && (te = te(e, D))) { af(B, te, i, z); break e } re && re(e, F, D), e === "focusout" && (re = F._wrapperState) && re.controlled && F.type === "number" && Os(F, "number", F.value) } switch (re = D ? dr(D) : window, e) { case "focusin": (sf(re) || re.contentEditable === "true") && (lr = re, ma = D, li = null); break; case "focusout": li = ma = lr = null; break; case "mousedown": ga = !0; break; case "contextmenu": case "mouseup": case "dragend": ga = !1, gf(B, i, z); break; case "selectionchange": if (uv) break; case "keydown": case "keyup": gf(B, i, z) }var ie; if (fa) e: { switch (e) { case "compositionstart": var le = "onCompositionStart"; break e; case "compositionend": le = "onCompositionEnd"; break e; case "compositionupdate": le = "onCompositionUpdate"; break e }le = void 0 } else ar ? rf(e, i) && (le = "onCompositionEnd") : e === "keydown" && i.keyCode === 229 && (le = "onCompositionStart"); le && (ef && i.locale !== "ko" && (ar || le !== "onCompositionStart" ? le === "onCompositionEnd" && ar && (ie = Xc()) : (dn = z, oa = "value" in dn ? dn.value : dn.textContent, ar = !0)), re = xo(D, le), 0 < re.length && (le = new qc(le, e, null, i, z), B.push({ event: le, listeners: re }), ie ? le.data = ie : (ie = of(i), ie !== null && (le.data = ie)))), (ie = Zy ? qy(e, i) : Jy(e, i)) && (D = xo(D, "onBeforeInput"), 0 < D.length && (z = new qc("onBeforeInput", "beforeinput", null, i, z), B.push({ event: z, listeners: D }), z.data = ie)) } Tf(B, t) }) } function fi(e, t, i) { return { instance: e, listener: t, currentTarget: i } } function xo(e, t) { for (var i = t + "Capture", a = []; e !== null;) { var u = e, d = u.stateNode; u.tag === 5 && d !== null && (u = d, d = Kr(e, i), d != null && a.unshift(fi(e, d, u)), d = Kr(e, t), d != null && a.push(fi(e, d, u))), e = e.return } return a } function cr(e) { if (e === null) return null; do e = e.return; while (e && e.tag !== 5); return e || null } function Rf(e, t, i, a, u) { for (var d = t._reactName, m = []; i !== null && i !== a;) { var w = i, S = w.alternate, D = w.stateNode; if (S !== null && S === a) break; w.tag === 5 && D !== null && (w = D, u ? (S = Kr(i, d), S != null && m.unshift(fi(i, S, w))) : u || (S = Kr(i, d), S != null && m.push(fi(i, S, w)))), i = i.return } m.length !== 0 && e.push({ event: t, listeners: m }) } var hv = /\r\n?/g, pv = /\u0000|\uFFFD/g; function Mf(e) {
        return (typeof e == "string" ? e : "" + e).replace(hv, `
`).replace(pv, "")
    } function wo(e, t, i) { if (t = Mf(t), Mf(e) !== t && i) throw Error(o(425)) } function So() { } var ka = null, Ca = null; function Ea(e, t) { return e === "textarea" || e === "noscript" || typeof t.children == "string" || typeof t.children == "number" || typeof t.dangerouslySetInnerHTML == "object" && t.dangerouslySetInnerHTML !== null && t.dangerouslySetInnerHTML.__html != null } var Ta = typeof setTimeout == "function" ? setTimeout : void 0, mv = typeof clearTimeout == "function" ? clearTimeout : void 0, Af = typeof Promise == "function" ? Promise : void 0, gv = typeof queueMicrotask == "function" ? queueMicrotask : typeof Af < "u" ? function (e) { return Af.resolve(null).then(e).catch(yv) } : Ta; function yv(e) { setTimeout(function () { throw e }) } function Pa(e, t) { var i = t, a = 0; do { var u = i.nextSibling; if (e.removeChild(i), u && u.nodeType === 8) if (i = u.data, i === "/$") { if (a === 0) { e.removeChild(u), ti(t); return } a-- } else i !== "$" && i !== "$?" && i !== "$!" || a++; i = u } while (i); ti(t) } function pn(e) { for (; e != null; e = e.nextSibling) { var t = e.nodeType; if (t === 1 || t === 3) break; if (t === 8) { if (t = e.data, t === "$" || t === "$!" || t === "$?") break; if (t === "/$") return null } } return e } function Lf(e) { e = e.previousSibling; for (var t = 0; e;) { if (e.nodeType === 8) { var i = e.data; if (i === "$" || i === "$!" || i === "$?") { if (t === 0) return e; t-- } else i === "/$" && t++ } e = e.previousSibling } return null } var fr = Math.random().toString(36).slice(2), zt = "__reactFiber$" + fr, di = "__reactProps$" + fr, Gt = "__reactContainer$" + fr, Ra = "__reactEvents$" + fr, vv = "__reactListeners$" + fr, xv = "__reactHandles$" + fr; function In(e) { var t = e[zt]; if (t) return t; for (var i = e.parentNode; i;) { if (t = i[Gt] || i[zt]) { if (i = t.alternate, t.child !== null || i !== null && i.child !== null) for (e = Lf(e); e !== null;) { if (i = e[zt]) return i; e = Lf(e) } return t } e = i, i = e.parentNode } return null } function hi(e) { return e = e[zt] || e[Gt], !e || e.tag !== 5 && e.tag !== 6 && e.tag !== 13 && e.tag !== 3 ? null : e } function dr(e) { if (e.tag === 5 || e.tag === 6) return e.stateNode; throw Error(o(33)) } function ko(e) { return e[di] || null } var Ma = [], hr = -1; function mn(e) { return { current: e } } function Te(e) { 0 > hr || (e.current = Ma[hr], Ma[hr] = null, hr--) } function Se(e, t) { hr++, Ma[hr] = e.current, e.current = t } var gn = {}, Je = mn(gn), lt = mn(!1), Fn = gn; function pr(e, t) { var i = e.type.contextTypes; if (!i) return gn; var a = e.stateNode; if (a && a.__reactInternalMemoizedUnmaskedChildContext === t) return a.__reactInternalMemoizedMaskedChildContext; var u = {}, d; for (d in i) u[d] = t[d]; return a && (e = e.stateNode, e.__reactInternalMemoizedUnmaskedChildContext = t, e.__reactInternalMemoizedMaskedChildContext = u), u } function ut(e) { return e = e.childContextTypes, e != null } function Co() { Te(lt), Te(Je) } function Nf(e, t, i) { if (Je.current !== gn) throw Error(o(168)); Se(Je, t), Se(lt, i) } function Df(e, t, i) { var a = e.stateNode; if (t = t.childContextTypes, typeof a.getChildContext != "function") return i; a = a.getChildContext(); for (var u in a) if (!(u in t)) throw Error(o(108, ue(e) || "Unknown", u)); return H({}, i, a) } function Eo(e) { return e = (e = e.stateNode) && e.__reactInternalMemoizedMergedChildContext || gn, Fn = Je.current, Se(Je, e), Se(lt, lt.current), !0 } function jf(e, t, i) { var a = e.stateNode; if (!a) throw Error(o(169)); i ? (e = Df(e, t, Fn), a.__reactInternalMemoizedMergedChildContext = e, Te(lt), Te(Je), Se(Je, e)) : Te(lt), Se(lt, i) } var Yt = null, To = !1, Aa = !1; function Vf(e) { Yt === null ? Yt = [e] : Yt.push(e) } function wv(e) { To = !0, Vf(e) } function yn() { if (!Aa && Yt !== null) { Aa = !0; var e = 0, t = we; try { var i = Yt; for (we = 1; e < i.length; e++) { var a = i[e]; do a = a(!0); while (a !== null) } Yt = null, To = !1 } catch (u) { throw Yt !== null && (Yt = Yt.slice(e + 1)), _c(Zs, yn), u } finally { we = t, Aa = !1 } } return null } var mr = [], gr = 0, Po = null, Ro = 0, vt = [], xt = 0, zn = null, Xt = 1, Qt = ""; function On(e, t) { mr[gr++] = Ro, mr[gr++] = Po, Po = e, Ro = t } function _f(e, t, i) { vt[xt++] = Xt, vt[xt++] = Qt, vt[xt++] = zn, zn = e; var a = Xt; e = Qt; var u = 32 - Rt(a) - 1; a &= ~(1 << u), i += 1; var d = 32 - Rt(t) + u; if (30 < d) { var m = u - u % 5; d = (a & (1 << m) - 1).toString(32), a >>= m, u -= m, Xt = 1 << 32 - Rt(t) + u | i << u | a, Qt = d + e } else Xt = 1 << d | i << u | a, Qt = e } function La(e) { e.return !== null && (On(e, 1), _f(e, 1, 0)) } function Na(e) { for (; e === Po;)Po = mr[--gr], mr[gr] = null, Ro = mr[--gr], mr[gr] = null; for (; e === zn;)zn = vt[--xt], vt[xt] = null, Qt = vt[--xt], vt[xt] = null, Xt = vt[--xt], vt[xt] = null } var mt = null, gt = null, Pe = !1, At = null; function bf(e, t) { var i = Ct(5, null, null, 0); i.elementType = "DELETED", i.stateNode = t, i.return = e, t = e.deletions, t === null ? (e.deletions = [i], e.flags |= 16) : t.push(i) } function If(e, t) { switch (e.tag) { case 5: var i = e.type; return t = t.nodeType !== 1 || i.toLowerCase() !== t.nodeName.toLowerCase() ? null : t, t !== null ? (e.stateNode = t, mt = e, gt = pn(t.firstChild), !0) : !1; case 6: return t = e.pendingProps === "" || t.nodeType !== 3 ? null : t, t !== null ? (e.stateNode = t, mt = e, gt = null, !0) : !1; case 13: return t = t.nodeType !== 8 ? null : t, t !== null ? (i = zn !== null ? { id: Xt, overflow: Qt } : null, e.memoizedState = { dehydrated: t, treeContext: i, retryLane: 1073741824 }, i = Ct(18, null, null, 0), i.stateNode = t, i.return = e, e.child = i, mt = e, gt = null, !0) : !1; default: return !1 } } function Da(e) { return (e.mode & 1) !== 0 && (e.flags & 128) === 0 } function ja(e) { if (Pe) { var t = gt; if (t) { var i = t; if (!If(e, t)) { if (Da(e)) throw Error(o(418)); t = pn(i.nextSibling); var a = mt; t && If(e, t) ? bf(a, i) : (e.flags = e.flags & -4097 | 2, Pe = !1, mt = e) } } else { if (Da(e)) throw Error(o(418)); e.flags = e.flags & -4097 | 2, Pe = !1, mt = e } } } function Ff(e) { for (e = e.return; e !== null && e.tag !== 5 && e.tag !== 3 && e.tag !== 13;)e = e.return; mt = e } function Mo(e) { if (e !== mt) return !1; if (!Pe) return Ff(e), Pe = !0, !1; var t; if ((t = e.tag !== 3) && !(t = e.tag !== 5) && (t = e.type, t = t !== "head" && t !== "body" && !Ea(e.type, e.memoizedProps)), t && (t = gt)) { if (Da(e)) throw zf(), Error(o(418)); for (; t;)bf(e, t), t = pn(t.nextSibling) } if (Ff(e), e.tag === 13) { if (e = e.memoizedState, e = e !== null ? e.dehydrated : null, !e) throw Error(o(317)); e: { for (e = e.nextSibling, t = 0; e;) { if (e.nodeType === 8) { var i = e.data; if (i === "/$") { if (t === 0) { gt = pn(e.nextSibling); break e } t-- } else i !== "$" && i !== "$!" && i !== "$?" || t++ } e = e.nextSibling } gt = null } } else gt = mt ? pn(e.stateNode.nextSibling) : null; return !0 } function zf() { for (var e = gt; e;)e = pn(e.nextSibling) } function yr() { gt = mt = null, Pe = !1 } function Va(e) { At === null ? At = [e] : At.push(e) } var Sv = W.ReactCurrentBatchConfig; function pi(e, t, i) { if (e = i.ref, e !== null && typeof e != "function" && typeof e != "object") { if (i._owner) { if (i = i._owner, i) { if (i.tag !== 1) throw Error(o(309)); var a = i.stateNode } if (!a) throw Error(o(147, e)); var u = a, d = "" + e; return t !== null && t.ref !== null && typeof t.ref == "function" && t.ref._stringRef === d ? t.ref : (t = function (m) { var w = u.refs; m === null ? delete w[d] : w[d] = m }, t._stringRef = d, t) } if (typeof e != "string") throw Error(o(284)); if (!i._owner) throw Error(o(290, e)) } return e } function Ao(e, t) { throw e = Object.prototype.toString.call(t), Error(o(31, e === "[object Object]" ? "object with keys {" + Object.keys(t).join(", ") + "}" : e)) } function Of(e) { var t = e._init; return t(e._payload) } function Bf(e) { function t(R, k) { if (e) { var L = R.deletions; L === null ? (R.deletions = [k], R.flags |= 16) : L.push(k) } } function i(R, k) { if (!e) return null; for (; k !== null;)t(R, k), k = k.sibling; return null } function a(R, k) { for (R = new Map; k !== null;)k.key !== null ? R.set(k.key, k) : R.set(k.index, k), k = k.sibling; return R } function u(R, k) { return R = Tn(R, k), R.index = 0, R.sibling = null, R } function d(R, k, L) { return R.index = L, e ? (L = R.alternate, L !== null ? (L = L.index, L < k ? (R.flags |= 2, k) : L) : (R.flags |= 2, k)) : (R.flags |= 1048576, k) } function m(R) { return e && R.alternate === null && (R.flags |= 2), R } function w(R, k, L, $) { return k === null || k.tag !== 6 ? (k = Tl(L, R.mode, $), k.return = R, k) : (k = u(k, L), k.return = R, k) } function S(R, k, L, $) { var te = L.type; return te === se ? z(R, k, L.props.children, $, L.key) : k !== null && (k.elementType === te || typeof te == "object" && te !== null && te.$$typeof === Ce && Of(te) === k.type) ? ($ = u(k, L.props), $.ref = pi(R, k, L), $.return = R, $) : ($ = Jo(L.type, L.key, L.props, null, R.mode, $), $.ref = pi(R, k, L), $.return = R, $) } function D(R, k, L, $) { return k === null || k.tag !== 4 || k.stateNode.containerInfo !== L.containerInfo || k.stateNode.implementation !== L.implementation ? (k = Pl(L, R.mode, $), k.return = R, k) : (k = u(k, L.children || []), k.return = R, k) } function z(R, k, L, $, te) { return k === null || k.tag !== 7 ? (k = Yn(L, R.mode, $, te), k.return = R, k) : (k = u(k, L), k.return = R, k) } function B(R, k, L) { if (typeof k == "string" && k !== "" || typeof k == "number") return k = Tl("" + k, R.mode, L), k.return = R, k; if (typeof k == "object" && k !== null) { switch (k.$$typeof) { case U: return L = Jo(k.type, k.key, k.props, null, R.mode, L), L.ref = pi(R, null, k), L.return = R, L; case J: return k = Pl(k, R.mode, L), k.return = R, k; case Ce: var $ = k._init; return B(R, $(k._payload), L) }if ($r(k) || ee(k)) return k = Yn(k, R.mode, L, null), k.return = R, k; Ao(R, k) } return null } function F(R, k, L, $) { var te = k !== null ? k.key : null; if (typeof L == "string" && L !== "" || typeof L == "number") return te !== null ? null : w(R, k, "" + L, $); if (typeof L == "object" && L !== null) { switch (L.$$typeof) { case U: return L.key === te ? S(R, k, L, $) : null; case J: return L.key === te ? D(R, k, L, $) : null; case Ce: return te = L._init, F(R, k, te(L._payload), $) }if ($r(L) || ee(L)) return te !== null ? null : z(R, k, L, $, null); Ao(R, L) } return null } function K(R, k, L, $, te) { if (typeof $ == "string" && $ !== "" || typeof $ == "number") return R = R.get(L) || null, w(k, R, "" + $, te); if (typeof $ == "object" && $ !== null) { switch ($.$$typeof) { case U: return R = R.get($.key === null ? L : $.key) || null, S(k, R, $, te); case J: return R = R.get($.key === null ? L : $.key) || null, D(k, R, $, te); case Ce: var re = $._init; return K(R, k, L, re($._payload), te) }if ($r($) || ee($)) return R = R.get(L) || null, z(k, R, $, te, null); Ao(k, $) } return null } function Y(R, k, L, $) { for (var te = null, re = null, ie = k, le = k = 0, Ye = null; ie !== null && le < L.length; le++) { ie.index > le ? (Ye = ie, ie = null) : Ye = ie.sibling; var ye = F(R, ie, L[le], $); if (ye === null) { ie === null && (ie = Ye); break } e && ie && ye.alternate === null && t(R, ie), k = d(ye, k, le), re === null ? te = ye : re.sibling = ye, re = ye, ie = Ye } if (le === L.length) return i(R, ie), Pe && On(R, le), te; if (ie === null) { for (; le < L.length; le++)ie = B(R, L[le], $), ie !== null && (k = d(ie, k, le), re === null ? te = ie : re.sibling = ie, re = ie); return Pe && On(R, le), te } for (ie = a(R, ie); le < L.length; le++)Ye = K(ie, R, le, L[le], $), Ye !== null && (e && Ye.alternate !== null && ie.delete(Ye.key === null ? le : Ye.key), k = d(Ye, k, le), re === null ? te = Ye : re.sibling = Ye, re = Ye); return e && ie.forEach(function (Pn) { return t(R, Pn) }), Pe && On(R, le), te } function q(R, k, L, $) { var te = ee(L); if (typeof te != "function") throw Error(o(150)); if (L = te.call(L), L == null) throw Error(o(151)); for (var re = te = null, ie = k, le = k = 0, Ye = null, ye = L.next(); ie !== null && !ye.done; le++, ye = L.next()) { ie.index > le ? (Ye = ie, ie = null) : Ye = ie.sibling; var Pn = F(R, ie, ye.value, $); if (Pn === null) { ie === null && (ie = Ye); break } e && ie && Pn.alternate === null && t(R, ie), k = d(Pn, k, le), re === null ? te = Pn : re.sibling = Pn, re = Pn, ie = Ye } if (ye.done) return i(R, ie), Pe && On(R, le), te; if (ie === null) { for (; !ye.done; le++, ye = L.next())ye = B(R, ye.value, $), ye !== null && (k = d(ye, k, le), re === null ? te = ye : re.sibling = ye, re = ye); return Pe && On(R, le), te } for (ie = a(R, ie); !ye.done; le++, ye = L.next())ye = K(ie, R, le, ye.value, $), ye !== null && (e && ye.alternate !== null && ie.delete(ye.key === null ? le : ye.key), k = d(ye, k, le), re === null ? te = ye : re.sibling = ye, re = ye); return e && ie.forEach(function (e0) { return t(R, e0) }), Pe && On(R, le), te } function Ve(R, k, L, $) { if (typeof L == "object" && L !== null && L.type === se && L.key === null && (L = L.props.children), typeof L == "object" && L !== null) { switch (L.$$typeof) { case U: e: { for (var te = L.key, re = k; re !== null;) { if (re.key === te) { if (te = L.type, te === se) { if (re.tag === 7) { i(R, re.sibling), k = u(re, L.props.children), k.return = R, R = k; break e } } else if (re.elementType === te || typeof te == "object" && te !== null && te.$$typeof === Ce && Of(te) === re.type) { i(R, re.sibling), k = u(re, L.props), k.ref = pi(R, re, L), k.return = R, R = k; break e } i(R, re); break } else t(R, re); re = re.sibling } L.type === se ? (k = Yn(L.props.children, R.mode, $, L.key), k.return = R, R = k) : ($ = Jo(L.type, L.key, L.props, null, R.mode, $), $.ref = pi(R, k, L), $.return = R, R = $) } return m(R); case J: e: { for (re = L.key; k !== null;) { if (k.key === re) if (k.tag === 4 && k.stateNode.containerInfo === L.containerInfo && k.stateNode.implementation === L.implementation) { i(R, k.sibling), k = u(k, L.children || []), k.return = R, R = k; break e } else { i(R, k); break } else t(R, k); k = k.sibling } k = Pl(L, R.mode, $), k.return = R, R = k } return m(R); case Ce: return re = L._init, Ve(R, k, re(L._payload), $) }if ($r(L)) return Y(R, k, L, $); if (ee(L)) return q(R, k, L, $); Ao(R, L) } return typeof L == "string" && L !== "" || typeof L == "number" ? (L = "" + L, k !== null && k.tag === 6 ? (i(R, k.sibling), k = u(k, L), k.return = R, R = k) : (i(R, k), k = Tl(L, R.mode, $), k.return = R, R = k), m(R)) : i(R, k) } return Ve } var vr = Bf(!0), Uf = Bf(!1), Lo = mn(null), No = null, xr = null, _a = null; function ba() { _a = xr = No = null } function Ia(e) { var t = Lo.current; Te(Lo), e._currentValue = t } function Fa(e, t, i) { for (; e !== null;) { var a = e.alternate; if ((e.childLanes & t) !== t ? (e.childLanes |= t, a !== null && (a.childLanes |= t)) : a !== null && (a.childLanes & t) !== t && (a.childLanes |= t), e === i) break; e = e.return } } function wr(e, t) { No = e, _a = xr = null, e = e.dependencies, e !== null && e.firstContext !== null && ((e.lanes & t) !== 0 && (ct = !0), e.firstContext = null) } function wt(e) { var t = e._currentValue; if (_a !== e) if (e = { context: e, memoizedValue: t, next: null }, xr === null) { if (No === null) throw Error(o(308)); xr = e, No.dependencies = { lanes: 0, firstContext: e } } else xr = xr.next = e; return t } var Bn = null; function za(e) { Bn === null ? Bn = [e] : Bn.push(e) } function $f(e, t, i, a) { var u = t.interleaved; return u === null ? (i.next = i, za(t)) : (i.next = u.next, u.next = i), t.interleaved = i, Zt(e, a) } function Zt(e, t) { e.lanes |= t; var i = e.alternate; for (i !== null && (i.lanes |= t), i = e, e = e.return; e !== null;)e.childLanes |= t, i = e.alternate, i !== null && (i.childLanes |= t), i = e, e = e.return; return i.tag === 3 ? i.stateNode : null } var vn = !1; function Oa(e) { e.updateQueue = { baseState: e.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null } } function Wf(e, t) { e = e.updateQueue, t.updateQueue === e && (t.updateQueue = { baseState: e.baseState, firstBaseUpdate: e.firstBaseUpdate, lastBaseUpdate: e.lastBaseUpdate, shared: e.shared, effects: e.effects }) } function qt(e, t) { return { eventTime: e, lane: t, tag: 0, payload: null, callback: null, next: null } } function xn(e, t, i) { var a = e.updateQueue; if (a === null) return null; if (a = a.shared, (me & 2) !== 0) { var u = a.pending; return u === null ? t.next = t : (t.next = u.next, u.next = t), a.pending = t, Zt(e, i) } return u = a.interleaved, u === null ? (t.next = t, za(a)) : (t.next = u.next, u.next = t), a.interleaved = t, Zt(e, i) } function Do(e, t, i) { if (t = t.updateQueue, t !== null && (t = t.shared, (i & 4194240) !== 0)) { var a = t.lanes; a &= e.pendingLanes, i |= a, t.lanes = i, ea(e, i) } } function Hf(e, t) { var i = e.updateQueue, a = e.alternate; if (a !== null && (a = a.updateQueue, i === a)) { var u = null, d = null; if (i = i.firstBaseUpdate, i !== null) { do { var m = { eventTime: i.eventTime, lane: i.lane, tag: i.tag, payload: i.payload, callback: i.callback, next: null }; d === null ? u = d = m : d = d.next = m, i = i.next } while (i !== null); d === null ? u = d = t : d = d.next = t } else u = d = t; i = { baseState: a.baseState, firstBaseUpdate: u, lastBaseUpdate: d, shared: a.shared, effects: a.effects }, e.updateQueue = i; return } e = i.lastBaseUpdate, e === null ? i.firstBaseUpdate = t : e.next = t, i.lastBaseUpdate = t } function jo(e, t, i, a) { var u = e.updateQueue; vn = !1; var d = u.firstBaseUpdate, m = u.lastBaseUpdate, w = u.shared.pending; if (w !== null) { u.shared.pending = null; var S = w, D = S.next; S.next = null, m === null ? d = D : m.next = D, m = S; var z = e.alternate; z !== null && (z = z.updateQueue, w = z.lastBaseUpdate, w !== m && (w === null ? z.firstBaseUpdate = D : w.next = D, z.lastBaseUpdate = S)) } if (d !== null) { var B = u.baseState; m = 0, z = D = S = null, w = d; do { var F = w.lane, K = w.eventTime; if ((a & F) === F) { z !== null && (z = z.next = { eventTime: K, lane: 0, tag: w.tag, payload: w.payload, callback: w.callback, next: null }); e: { var Y = e, q = w; switch (F = t, K = i, q.tag) { case 1: if (Y = q.payload, typeof Y == "function") { B = Y.call(K, B, F); break e } B = Y; break e; case 3: Y.flags = Y.flags & -65537 | 128; case 0: if (Y = q.payload, F = typeof Y == "function" ? Y.call(K, B, F) : Y, F == null) break e; B = H({}, B, F); break e; case 2: vn = !0 } } w.callback !== null && w.lane !== 0 && (e.flags |= 64, F = u.effects, F === null ? u.effects = [w] : F.push(w)) } else K = { eventTime: K, lane: F, tag: w.tag, payload: w.payload, callback: w.callback, next: null }, z === null ? (D = z = K, S = B) : z = z.next = K, m |= F; if (w = w.next, w === null) { if (w = u.shared.pending, w === null) break; F = w, w = F.next, F.next = null, u.lastBaseUpdate = F, u.shared.pending = null } } while (!0); if (z === null && (S = B), u.baseState = S, u.firstBaseUpdate = D, u.lastBaseUpdate = z, t = u.shared.interleaved, t !== null) { u = t; do m |= u.lane, u = u.next; while (u !== t) } else d === null && (u.shared.lanes = 0); Wn |= m, e.lanes = m, e.memoizedState = B } } function Kf(e, t, i) { if (e = t.effects, t.effects = null, e !== null) for (t = 0; t < e.length; t++) { var a = e[t], u = a.callback; if (u !== null) { if (a.callback = null, a = i, typeof u != "function") throw Error(o(191, u)); u.call(a) } } } var mi = {}, Ot = mn(mi), gi = mn(mi), yi = mn(mi); function Un(e) { if (e === mi) throw Error(o(174)); return e } function Ba(e, t) { switch (Se(yi, t), Se(gi, e), Se(Ot, mi), e = t.nodeType, e) { case 9: case 11: t = (t = t.documentElement) ? t.namespaceURI : Us(null, ""); break; default: e = e === 8 ? t.parentNode : t, t = e.namespaceURI || null, e = e.tagName, t = Us(t, e) }Te(Ot), Se(Ot, t) } function Sr() { Te(Ot), Te(gi), Te(yi) } function Gf(e) { Un(yi.current); var t = Un(Ot.current), i = Us(t, e.type); t !== i && (Se(gi, e), Se(Ot, i)) } function Ua(e) { gi.current === e && (Te(Ot), Te(gi)) } var Re = mn(0); function Vo(e) { for (var t = e; t !== null;) { if (t.tag === 13) { var i = t.memoizedState; if (i !== null && (i = i.dehydrated, i === null || i.data === "$?" || i.data === "$!")) return t } else if (t.tag === 19 && t.memoizedProps.revealOrder !== void 0) { if ((t.flags & 128) !== 0) return t } else if (t.child !== null) { t.child.return = t, t = t.child; continue } if (t === e) break; for (; t.sibling === null;) { if (t.return === null || t.return === e) return null; t = t.return } t.sibling.return = t.return, t = t.sibling } return null } var $a = []; function Wa() { for (var e = 0; e < $a.length; e++)$a[e]._workInProgressVersionPrimary = null; $a.length = 0 } var _o = W.ReactCurrentDispatcher, Ha = W.ReactCurrentBatchConfig, $n = 0, Me = null, Fe = null, Ke = null, bo = !1, vi = !1, xi = 0, kv = 0; function et() { throw Error(o(321)) } function Ka(e, t) { if (t === null) return !1; for (var i = 0; i < t.length && i < e.length; i++)if (!Mt(e[i], t[i])) return !1; return !0 } function Ga(e, t, i, a, u, d) { if ($n = d, Me = t, t.memoizedState = null, t.updateQueue = null, t.lanes = 0, _o.current = e === null || e.memoizedState === null ? Pv : Rv, e = i(a, u), vi) { d = 0; do { if (vi = !1, xi = 0, 25 <= d) throw Error(o(301)); d += 1, Ke = Fe = null, t.updateQueue = null, _o.current = Mv, e = i(a, u) } while (vi) } if (_o.current = zo, t = Fe !== null && Fe.next !== null, $n = 0, Ke = Fe = Me = null, bo = !1, t) throw Error(o(300)); return e } function Ya() { var e = xi !== 0; return xi = 0, e } function Bt() { var e = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null }; return Ke === null ? Me.memoizedState = Ke = e : Ke = Ke.next = e, Ke } function St() { if (Fe === null) { var e = Me.alternate; e = e !== null ? e.memoizedState : null } else e = Fe.next; var t = Ke === null ? Me.memoizedState : Ke.next; if (t !== null) Ke = t, Fe = e; else { if (e === null) throw Error(o(310)); Fe = e, e = { memoizedState: Fe.memoizedState, baseState: Fe.baseState, baseQueue: Fe.baseQueue, queue: Fe.queue, next: null }, Ke === null ? Me.memoizedState = Ke = e : Ke = Ke.next = e } return Ke } function wi(e, t) { return typeof t == "function" ? t(e) : t } function Xa(e) { var t = St(), i = t.queue; if (i === null) throw Error(o(311)); i.lastRenderedReducer = e; var a = Fe, u = a.baseQueue, d = i.pending; if (d !== null) { if (u !== null) { var m = u.next; u.next = d.next, d.next = m } a.baseQueue = u = d, i.pending = null } if (u !== null) { d = u.next, a = a.baseState; var w = m = null, S = null, D = d; do { var z = D.lane; if (($n & z) === z) S !== null && (S = S.next = { lane: 0, action: D.action, hasEagerState: D.hasEagerState, eagerState: D.eagerState, next: null }), a = D.hasEagerState ? D.eagerState : e(a, D.action); else { var B = { lane: z, action: D.action, hasEagerState: D.hasEagerState, eagerState: D.eagerState, next: null }; S === null ? (w = S = B, m = a) : S = S.next = B, Me.lanes |= z, Wn |= z } D = D.next } while (D !== null && D !== d); S === null ? m = a : S.next = w, Mt(a, t.memoizedState) || (ct = !0), t.memoizedState = a, t.baseState = m, t.baseQueue = S, i.lastRenderedState = a } if (e = i.interleaved, e !== null) { u = e; do d = u.lane, Me.lanes |= d, Wn |= d, u = u.next; while (u !== e) } else u === null && (i.lanes = 0); return [t.memoizedState, i.dispatch] } function Qa(e) { var t = St(), i = t.queue; if (i === null) throw Error(o(311)); i.lastRenderedReducer = e; var a = i.dispatch, u = i.pending, d = t.memoizedState; if (u !== null) { i.pending = null; var m = u = u.next; do d = e(d, m.action), m = m.next; while (m !== u); Mt(d, t.memoizedState) || (ct = !0), t.memoizedState = d, t.baseQueue === null && (t.baseState = d), i.lastRenderedState = d } return [d, a] } function Yf() { } function Xf(e, t) { var i = Me, a = St(), u = t(), d = !Mt(a.memoizedState, u); if (d && (a.memoizedState = u, ct = !0), a = a.queue, Za(qf.bind(null, i, a, e), [e]), a.getSnapshot !== t || d || Ke !== null && Ke.memoizedState.tag & 1) { if (i.flags |= 2048, Si(9, Zf.bind(null, i, a, u, t), void 0, null), Ge === null) throw Error(o(349)); ($n & 30) !== 0 || Qf(i, t, u) } return u } function Qf(e, t, i) { e.flags |= 16384, e = { getSnapshot: t, value: i }, t = Me.updateQueue, t === null ? (t = { lastEffect: null, stores: null }, Me.updateQueue = t, t.stores = [e]) : (i = t.stores, i === null ? t.stores = [e] : i.push(e)) } function Zf(e, t, i, a) { t.value = i, t.getSnapshot = a, Jf(t) && ed(e) } function qf(e, t, i) { return i(function () { Jf(t) && ed(e) }) } function Jf(e) { var t = e.getSnapshot; e = e.value; try { var i = t(); return !Mt(e, i) } catch { return !0 } } function ed(e) { var t = Zt(e, 1); t !== null && jt(t, e, 1, -1) } function td(e) { var t = Bt(); return typeof e == "function" && (e = e()), t.memoizedState = t.baseState = e, e = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: wi, lastRenderedState: e }, t.queue = e, e = e.dispatch = Tv.bind(null, Me, e), [t.memoizedState, e] } function Si(e, t, i, a) { return e = { tag: e, create: t, destroy: i, deps: a, next: null }, t = Me.updateQueue, t === null ? (t = { lastEffect: null, stores: null }, Me.updateQueue = t, t.lastEffect = e.next = e) : (i = t.lastEffect, i === null ? t.lastEffect = e.next = e : (a = i.next, i.next = e, e.next = a, t.lastEffect = e)), e } function nd() { return St().memoizedState } function Io(e, t, i, a) { var u = Bt(); Me.flags |= e, u.memoizedState = Si(1 | t, i, void 0, a === void 0 ? null : a) } function Fo(e, t, i, a) { var u = St(); a = a === void 0 ? null : a; var d = void 0; if (Fe !== null) { var m = Fe.memoizedState; if (d = m.destroy, a !== null && Ka(a, m.deps)) { u.memoizedState = Si(t, i, d, a); return } } Me.flags |= e, u.memoizedState = Si(1 | t, i, d, a) } function rd(e, t) { return Io(8390656, 8, e, t) } function Za(e, t) { return Fo(2048, 8, e, t) } function id(e, t) { return Fo(4, 2, e, t) } function od(e, t) { return Fo(4, 4, e, t) } function sd(e, t) { if (typeof t == "function") return e = e(), t(e), function () { t(null) }; if (t != null) return e = e(), t.current = e, function () { t.current = null } } function ad(e, t, i) { return i = i != null ? i.concat([e]) : null, Fo(4, 4, sd.bind(null, t, e), i) } function qa() { } function ld(e, t) { var i = St(); t = t === void 0 ? null : t; var a = i.memoizedState; return a !== null && t !== null && Ka(t, a[1]) ? a[0] : (i.memoizedState = [e, t], e) } function ud(e, t) { var i = St(); t = t === void 0 ? null : t; var a = i.memoizedState; return a !== null && t !== null && Ka(t, a[1]) ? a[0] : (e = e(), i.memoizedState = [e, t], e) } function cd(e, t, i) { return ($n & 21) === 0 ? (e.baseState && (e.baseState = !1, ct = !0), e.memoizedState = i) : (Mt(i, t) || (i = zc(), Me.lanes |= i, Wn |= i, e.baseState = !0), t) } function Cv(e, t) { var i = we; we = i !== 0 && 4 > i ? i : 4, e(!0); var a = Ha.transition; Ha.transition = {}; try { e(!1), t() } finally { we = i, Ha.transition = a } } function fd() { return St().memoizedState } function Ev(e, t, i) { var a = Cn(e); if (i = { lane: a, action: i, hasEagerState: !1, eagerState: null, next: null }, dd(e)) hd(t, i); else if (i = $f(e, t, i, a), i !== null) { var u = ot(); jt(i, e, a, u), pd(i, t, a) } } function Tv(e, t, i) { var a = Cn(e), u = { lane: a, action: i, hasEagerState: !1, eagerState: null, next: null }; if (dd(e)) hd(t, u); else { var d = e.alternate; if (e.lanes === 0 && (d === null || d.lanes === 0) && (d = t.lastRenderedReducer, d !== null)) try { var m = t.lastRenderedState, w = d(m, i); if (u.hasEagerState = !0, u.eagerState = w, Mt(w, m)) { var S = t.interleaved; S === null ? (u.next = u, za(t)) : (u.next = S.next, S.next = u), t.interleaved = u; return } } catch { } finally { } i = $f(e, t, u, a), i !== null && (u = ot(), jt(i, e, a, u), pd(i, t, a)) } } function dd(e) { var t = e.alternate; return e === Me || t !== null && t === Me } function hd(e, t) { vi = bo = !0; var i = e.pending; i === null ? t.next = t : (t.next = i.next, i.next = t), e.pending = t } function pd(e, t, i) { if ((i & 4194240) !== 0) { var a = t.lanes; a &= e.pendingLanes, i |= a, t.lanes = i, ea(e, i) } } var zo = { readContext: wt, useCallback: et, useContext: et, useEffect: et, useImperativeHandle: et, useInsertionEffect: et, useLayoutEffect: et, useMemo: et, useReducer: et, useRef: et, useState: et, useDebugValue: et, useDeferredValue: et, useTransition: et, useMutableSource: et, useSyncExternalStore: et, useId: et, unstable_isNewReconciler: !1 }, Pv = { readContext: wt, useCallback: function (e, t) { return Bt().memoizedState = [e, t === void 0 ? null : t], e }, useContext: wt, useEffect: rd, useImperativeHandle: function (e, t, i) { return i = i != null ? i.concat([e]) : null, Io(4194308, 4, sd.bind(null, t, e), i) }, useLayoutEffect: function (e, t) { return Io(4194308, 4, e, t) }, useInsertionEffect: function (e, t) { return Io(4, 2, e, t) }, useMemo: function (e, t) { var i = Bt(); return t = t === void 0 ? null : t, e = e(), i.memoizedState = [e, t], e }, useReducer: function (e, t, i) { var a = Bt(); return t = i !== void 0 ? i(t) : t, a.memoizedState = a.baseState = t, e = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: e, lastRenderedState: t }, a.queue = e, e = e.dispatch = Ev.bind(null, Me, e), [a.memoizedState, e] }, useRef: function (e) { var t = Bt(); return e = { current: e }, t.memoizedState = e }, useState: td, useDebugValue: qa, useDeferredValue: function (e) { return Bt().memoizedState = e }, useTransition: function () { var e = td(!1), t = e[0]; return e = Cv.bind(null, e[1]), Bt().memoizedState = e, [t, e] }, useMutableSource: function () { }, useSyncExternalStore: function (e, t, i) { var a = Me, u = Bt(); if (Pe) { if (i === void 0) throw Error(o(407)); i = i() } else { if (i = t(), Ge === null) throw Error(o(349)); ($n & 30) !== 0 || Qf(a, t, i) } u.memoizedState = i; var d = { value: i, getSnapshot: t }; return u.queue = d, rd(qf.bind(null, a, d, e), [e]), a.flags |= 2048, Si(9, Zf.bind(null, a, d, i, t), void 0, null), i }, useId: function () { var e = Bt(), t = Ge.identifierPrefix; if (Pe) { var i = Qt, a = Xt; i = (a & ~(1 << 32 - Rt(a) - 1)).toString(32) + i, t = ":" + t + "R" + i, i = xi++, 0 < i && (t += "H" + i.toString(32)), t += ":" } else i = kv++, t = ":" + t + "r" + i.toString(32) + ":"; return e.memoizedState = t }, unstable_isNewReconciler: !1 }, Rv = { readContext: wt, useCallback: ld, useContext: wt, useEffect: Za, useImperativeHandle: ad, useInsertionEffect: id, useLayoutEffect: od, useMemo: ud, useReducer: Xa, useRef: nd, useState: function () { return Xa(wi) }, useDebugValue: qa, useDeferredValue: function (e) { var t = St(); return cd(t, Fe.memoizedState, e) }, useTransition: function () { var e = Xa(wi)[0], t = St().memoizedState; return [e, t] }, useMutableSource: Yf, useSyncExternalStore: Xf, useId: fd, unstable_isNewReconciler: !1 }, Mv = { readContext: wt, useCallback: ld, useContext: wt, useEffect: Za, useImperativeHandle: ad, useInsertionEffect: id, useLayoutEffect: od, useMemo: ud, useReducer: Qa, useRef: nd, useState: function () { return Qa(wi) }, useDebugValue: qa, useDeferredValue: function (e) { var t = St(); return Fe === null ? t.memoizedState = e : cd(t, Fe.memoizedState, e) }, useTransition: function () { var e = Qa(wi)[0], t = St().memoizedState; return [e, t] }, useMutableSource: Yf, useSyncExternalStore: Xf, useId: fd, unstable_isNewReconciler: !1 }; function Lt(e, t) { if (e && e.defaultProps) { t = H({}, t), e = e.defaultProps; for (var i in e) t[i] === void 0 && (t[i] = e[i]); return t } return t } function Ja(e, t, i, a) { t = e.memoizedState, i = i(a, t), i = i == null ? t : H({}, t, i), e.memoizedState = i, e.lanes === 0 && (e.updateQueue.baseState = i) } var Oo = { isMounted: function (e) { return (e = e._reactInternals) ? bn(e) === e : !1 }, enqueueSetState: function (e, t, i) { e = e._reactInternals; var a = ot(), u = Cn(e), d = qt(a, u); d.payload = t, i != null && (d.callback = i), t = xn(e, d, u), t !== null && (jt(t, e, u, a), Do(t, e, u)) }, enqueueReplaceState: function (e, t, i) { e = e._reactInternals; var a = ot(), u = Cn(e), d = qt(a, u); d.tag = 1, d.payload = t, i != null && (d.callback = i), t = xn(e, d, u), t !== null && (jt(t, e, u, a), Do(t, e, u)) }, enqueueForceUpdate: function (e, t) { e = e._reactInternals; var i = ot(), a = Cn(e), u = qt(i, a); u.tag = 2, t != null && (u.callback = t), t = xn(e, u, a), t !== null && (jt(t, e, a, i), Do(t, e, a)) } }; function md(e, t, i, a, u, d, m) { return e = e.stateNode, typeof e.shouldComponentUpdate == "function" ? e.shouldComponentUpdate(a, d, m) : t.prototype && t.prototype.isPureReactComponent ? !ai(i, a) || !ai(u, d) : !0 } function gd(e, t, i) { var a = !1, u = gn, d = t.contextType; return typeof d == "object" && d !== null ? d = wt(d) : (u = ut(t) ? Fn : Je.current, a = t.contextTypes, d = (a = a != null) ? pr(e, u) : gn), t = new t(i, d), e.memoizedState = t.state !== null && t.state !== void 0 ? t.state : null, t.updater = Oo, e.stateNode = t, t._reactInternals = e, a && (e = e.stateNode, e.__reactInternalMemoizedUnmaskedChildContext = u, e.__reactInternalMemoizedMaskedChildContext = d), t } function yd(e, t, i, a) { e = t.state, typeof t.componentWillReceiveProps == "function" && t.componentWillReceiveProps(i, a), typeof t.UNSAFE_componentWillReceiveProps == "function" && t.UNSAFE_componentWillReceiveProps(i, a), t.state !== e && Oo.enqueueReplaceState(t, t.state, null) } function el(e, t, i, a) { var u = e.stateNode; u.props = i, u.state = e.memoizedState, u.refs = {}, Oa(e); var d = t.contextType; typeof d == "object" && d !== null ? u.context = wt(d) : (d = ut(t) ? Fn : Je.current, u.context = pr(e, d)), u.state = e.memoizedState, d = t.getDerivedStateFromProps, typeof d == "function" && (Ja(e, t, d, i), u.state = e.memoizedState), typeof t.getDerivedStateFromProps == "function" || typeof u.getSnapshotBeforeUpdate == "function" || typeof u.UNSAFE_componentWillMount != "function" && typeof u.componentWillMount != "function" || (t = u.state, typeof u.componentWillMount == "function" && u.componentWillMount(), typeof u.UNSAFE_componentWillMount == "function" && u.UNSAFE_componentWillMount(), t !== u.state && Oo.enqueueReplaceState(u, u.state, null), jo(e, i, u, a), u.state = e.memoizedState), typeof u.componentDidMount == "function" && (e.flags |= 4194308) } function kr(e, t) {
        try { var i = "", a = t; do i += he(a), a = a.return; while (a); var u = i } catch (d) {
            u = `
Error generating stack: `+ d.message + `
`+ d.stack
        } return { value: e, source: t, stack: u, digest: null }
    } function tl(e, t, i) { return { value: e, source: null, stack: i ?? null, digest: t ?? null } } function nl(e, t) { try { console.error(t.value) } catch (i) { setTimeout(function () { throw i }) } } var Av = typeof WeakMap == "function" ? WeakMap : Map; function vd(e, t, i) { i = qt(-1, i), i.tag = 3, i.payload = { element: null }; var a = t.value; return i.callback = function () { Go || (Go = !0, yl = a), nl(e, t) }, i } function xd(e, t, i) { i = qt(-1, i), i.tag = 3; var a = e.type.getDerivedStateFromError; if (typeof a == "function") { var u = t.value; i.payload = function () { return a(u) }, i.callback = function () { nl(e, t) } } var d = e.stateNode; return d !== null && typeof d.componentDidCatch == "function" && (i.callback = function () { nl(e, t), typeof a != "function" && (Sn === null ? Sn = new Set([this]) : Sn.add(this)); var m = t.stack; this.componentDidCatch(t.value, { componentStack: m !== null ? m : "" }) }), i } function wd(e, t, i) { var a = e.pingCache; if (a === null) { a = e.pingCache = new Av; var u = new Set; a.set(t, u) } else u = a.get(t), u === void 0 && (u = new Set, a.set(t, u)); u.has(i) || (u.add(i), e = $v.bind(null, e, t, i), t.then(e, e)) } function Sd(e) { do { var t; if ((t = e.tag === 13) && (t = e.memoizedState, t = t !== null ? t.dehydrated !== null : !0), t) return e; e = e.return } while (e !== null); return null } function kd(e, t, i, a, u) { return (e.mode & 1) === 0 ? (e === t ? e.flags |= 65536 : (e.flags |= 128, i.flags |= 131072, i.flags &= -52805, i.tag === 1 && (i.alternate === null ? i.tag = 17 : (t = qt(-1, 1), t.tag = 2, xn(i, t, 1))), i.lanes |= 1), e) : (e.flags |= 65536, e.lanes = u, e) } var Lv = W.ReactCurrentOwner, ct = !1; function it(e, t, i, a) { t.child = e === null ? Uf(t, null, i, a) : vr(t, e.child, i, a) } function Cd(e, t, i, a, u) { i = i.render; var d = t.ref; return wr(t, u), a = Ga(e, t, i, a, d, u), i = Ya(), e !== null && !ct ? (t.updateQueue = e.updateQueue, t.flags &= -2053, e.lanes &= ~u, Jt(e, t, u)) : (Pe && i && La(t), t.flags |= 1, it(e, t, a, u), t.child) } function Ed(e, t, i, a, u) { if (e === null) { var d = i.type; return typeof d == "function" && !El(d) && d.defaultProps === void 0 && i.compare === null && i.defaultProps === void 0 ? (t.tag = 15, t.type = d, Td(e, t, d, a, u)) : (e = Jo(i.type, null, a, t, t.mode, u), e.ref = t.ref, e.return = t, t.child = e) } if (d = e.child, (e.lanes & u) === 0) { var m = d.memoizedProps; if (i = i.compare, i = i !== null ? i : ai, i(m, a) && e.ref === t.ref) return Jt(e, t, u) } return t.flags |= 1, e = Tn(d, a), e.ref = t.ref, e.return = t, t.child = e } function Td(e, t, i, a, u) { if (e !== null) { var d = e.memoizedProps; if (ai(d, a) && e.ref === t.ref) if (ct = !1, t.pendingProps = a = d, (e.lanes & u) !== 0) (e.flags & 131072) !== 0 && (ct = !0); else return t.lanes = e.lanes, Jt(e, t, u) } return rl(e, t, i, a, u) } function Pd(e, t, i) { var a = t.pendingProps, u = a.children, d = e !== null ? e.memoizedState : null; if (a.mode === "hidden") if ((t.mode & 1) === 0) t.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, Se(Er, yt), yt |= i; else { if ((i & 1073741824) === 0) return e = d !== null ? d.baseLanes | i : i, t.lanes = t.childLanes = 1073741824, t.memoizedState = { baseLanes: e, cachePool: null, transitions: null }, t.updateQueue = null, Se(Er, yt), yt |= e, null; t.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, a = d !== null ? d.baseLanes : i, Se(Er, yt), yt |= a } else d !== null ? (a = d.baseLanes | i, t.memoizedState = null) : a = i, Se(Er, yt), yt |= a; return it(e, t, u, i), t.child } function Rd(e, t) { var i = t.ref; (e === null && i !== null || e !== null && e.ref !== i) && (t.flags |= 512, t.flags |= 2097152) } function rl(e, t, i, a, u) { var d = ut(i) ? Fn : Je.current; return d = pr(t, d), wr(t, u), i = Ga(e, t, i, a, d, u), a = Ya(), e !== null && !ct ? (t.updateQueue = e.updateQueue, t.flags &= -2053, e.lanes &= ~u, Jt(e, t, u)) : (Pe && a && La(t), t.flags |= 1, it(e, t, i, u), t.child) } function Md(e, t, i, a, u) { if (ut(i)) { var d = !0; Eo(t) } else d = !1; if (wr(t, u), t.stateNode === null) Uo(e, t), gd(t, i, a), el(t, i, a, u), a = !0; else if (e === null) { var m = t.stateNode, w = t.memoizedProps; m.props = w; var S = m.context, D = i.contextType; typeof D == "object" && D !== null ? D = wt(D) : (D = ut(i) ? Fn : Je.current, D = pr(t, D)); var z = i.getDerivedStateFromProps, B = typeof z == "function" || typeof m.getSnapshotBeforeUpdate == "function"; B || typeof m.UNSAFE_componentWillReceiveProps != "function" && typeof m.componentWillReceiveProps != "function" || (w !== a || S !== D) && yd(t, m, a, D), vn = !1; var F = t.memoizedState; m.state = F, jo(t, a, m, u), S = t.memoizedState, w !== a || F !== S || lt.current || vn ? (typeof z == "function" && (Ja(t, i, z, a), S = t.memoizedState), (w = vn || md(t, i, w, a, F, S, D)) ? (B || typeof m.UNSAFE_componentWillMount != "function" && typeof m.componentWillMount != "function" || (typeof m.componentWillMount == "function" && m.componentWillMount(), typeof m.UNSAFE_componentWillMount == "function" && m.UNSAFE_componentWillMount()), typeof m.componentDidMount == "function" && (t.flags |= 4194308)) : (typeof m.componentDidMount == "function" && (t.flags |= 4194308), t.memoizedProps = a, t.memoizedState = S), m.props = a, m.state = S, m.context = D, a = w) : (typeof m.componentDidMount == "function" && (t.flags |= 4194308), a = !1) } else { m = t.stateNode, Wf(e, t), w = t.memoizedProps, D = t.type === t.elementType ? w : Lt(t.type, w), m.props = D, B = t.pendingProps, F = m.context, S = i.contextType, typeof S == "object" && S !== null ? S = wt(S) : (S = ut(i) ? Fn : Je.current, S = pr(t, S)); var K = i.getDerivedStateFromProps; (z = typeof K == "function" || typeof m.getSnapshotBeforeUpdate == "function") || typeof m.UNSAFE_componentWillReceiveProps != "function" && typeof m.componentWillReceiveProps != "function" || (w !== B || F !== S) && yd(t, m, a, S), vn = !1, F = t.memoizedState, m.state = F, jo(t, a, m, u); var Y = t.memoizedState; w !== B || F !== Y || lt.current || vn ? (typeof K == "function" && (Ja(t, i, K, a), Y = t.memoizedState), (D = vn || md(t, i, D, a, F, Y, S) || !1) ? (z || typeof m.UNSAFE_componentWillUpdate != "function" && typeof m.componentWillUpdate != "function" || (typeof m.componentWillUpdate == "function" && m.componentWillUpdate(a, Y, S), typeof m.UNSAFE_componentWillUpdate == "function" && m.UNSAFE_componentWillUpdate(a, Y, S)), typeof m.componentDidUpdate == "function" && (t.flags |= 4), typeof m.getSnapshotBeforeUpdate == "function" && (t.flags |= 1024)) : (typeof m.componentDidUpdate != "function" || w === e.memoizedProps && F === e.memoizedState || (t.flags |= 4), typeof m.getSnapshotBeforeUpdate != "function" || w === e.memoizedProps && F === e.memoizedState || (t.flags |= 1024), t.memoizedProps = a, t.memoizedState = Y), m.props = a, m.state = Y, m.context = S, a = D) : (typeof m.componentDidUpdate != "function" || w === e.memoizedProps && F === e.memoizedState || (t.flags |= 4), typeof m.getSnapshotBeforeUpdate != "function" || w === e.memoizedProps && F === e.memoizedState || (t.flags |= 1024), a = !1) } return il(e, t, i, a, d, u) } function il(e, t, i, a, u, d) { Rd(e, t); var m = (t.flags & 128) !== 0; if (!a && !m) return u && jf(t, i, !1), Jt(e, t, d); a = t.stateNode, Lv.current = t; var w = m && typeof i.getDerivedStateFromError != "function" ? null : a.render(); return t.flags |= 1, e !== null && m ? (t.child = vr(t, e.child, null, d), t.child = vr(t, null, w, d)) : it(e, t, w, d), t.memoizedState = a.state, u && jf(t, i, !0), t.child } function Ad(e) { var t = e.stateNode; t.pendingContext ? Nf(e, t.pendingContext, t.pendingContext !== t.context) : t.context && Nf(e, t.context, !1), Ba(e, t.containerInfo) } function Ld(e, t, i, a, u) { return yr(), Va(u), t.flags |= 256, it(e, t, i, a), t.child } var ol = { dehydrated: null, treeContext: null, retryLane: 0 }; function sl(e) { return { baseLanes: e, cachePool: null, transitions: null } } function Nd(e, t, i) { var a = t.pendingProps, u = Re.current, d = !1, m = (t.flags & 128) !== 0, w; if ((w = m) || (w = e !== null && e.memoizedState === null ? !1 : (u & 2) !== 0), w ? (d = !0, t.flags &= -129) : (e === null || e.memoizedState !== null) && (u |= 1), Se(Re, u & 1), e === null) return ja(t), e = t.memoizedState, e !== null && (e = e.dehydrated, e !== null) ? ((t.mode & 1) === 0 ? t.lanes = 1 : e.data === "$!" ? t.lanes = 8 : t.lanes = 1073741824, null) : (m = a.children, e = a.fallback, d ? (a = t.mode, d = t.child, m = { mode: "hidden", children: m }, (a & 1) === 0 && d !== null ? (d.childLanes = 0, d.pendingProps = m) : d = es(m, a, 0, null), e = Yn(e, a, i, null), d.return = t, e.return = t, d.sibling = e, t.child = d, t.child.memoizedState = sl(i), t.memoizedState = ol, e) : al(t, m)); if (u = e.memoizedState, u !== null && (w = u.dehydrated, w !== null)) return Nv(e, t, m, a, w, u, i); if (d) { d = a.fallback, m = t.mode, u = e.child, w = u.sibling; var S = { mode: "hidden", children: a.children }; return (m & 1) === 0 && t.child !== u ? (a = t.child, a.childLanes = 0, a.pendingProps = S, t.deletions = null) : (a = Tn(u, S), a.subtreeFlags = u.subtreeFlags & 14680064), w !== null ? d = Tn(w, d) : (d = Yn(d, m, i, null), d.flags |= 2), d.return = t, a.return = t, a.sibling = d, t.child = a, a = d, d = t.child, m = e.child.memoizedState, m = m === null ? sl(i) : { baseLanes: m.baseLanes | i, cachePool: null, transitions: m.transitions }, d.memoizedState = m, d.childLanes = e.childLanes & ~i, t.memoizedState = ol, a } return d = e.child, e = d.sibling, a = Tn(d, { mode: "visible", children: a.children }), (t.mode & 1) === 0 && (a.lanes = i), a.return = t, a.sibling = null, e !== null && (i = t.deletions, i === null ? (t.deletions = [e], t.flags |= 16) : i.push(e)), t.child = a, t.memoizedState = null, a } function al(e, t) { return t = es({ mode: "visible", children: t }, e.mode, 0, null), t.return = e, e.child = t } function Bo(e, t, i, a) { return a !== null && Va(a), vr(t, e.child, null, i), e = al(t, t.pendingProps.children), e.flags |= 2, t.memoizedState = null, e } function Nv(e, t, i, a, u, d, m) { if (i) return t.flags & 256 ? (t.flags &= -257, a = tl(Error(o(422))), Bo(e, t, m, a)) : t.memoizedState !== null ? (t.child = e.child, t.flags |= 128, null) : (d = a.fallback, u = t.mode, a = es({ mode: "visible", children: a.children }, u, 0, null), d = Yn(d, u, m, null), d.flags |= 2, a.return = t, d.return = t, a.sibling = d, t.child = a, (t.mode & 1) !== 0 && vr(t, e.child, null, m), t.child.memoizedState = sl(m), t.memoizedState = ol, d); if ((t.mode & 1) === 0) return Bo(e, t, m, null); if (u.data === "$!") { if (a = u.nextSibling && u.nextSibling.dataset, a) var w = a.dgst; return a = w, d = Error(o(419)), a = tl(d, a, void 0), Bo(e, t, m, a) } if (w = (m & e.childLanes) !== 0, ct || w) { if (a = Ge, a !== null) { switch (m & -m) { case 4: u = 2; break; case 16: u = 8; break; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: u = 32; break; case 536870912: u = 268435456; break; default: u = 0 }u = (u & (a.suspendedLanes | m)) !== 0 ? 0 : u, u !== 0 && u !== d.retryLane && (d.retryLane = u, Zt(e, u), jt(a, e, u, -1)) } return Cl(), a = tl(Error(o(421))), Bo(e, t, m, a) } return u.data === "$?" ? (t.flags |= 128, t.child = e.child, t = Wv.bind(null, e), u._reactRetry = t, null) : (e = d.treeContext, gt = pn(u.nextSibling), mt = t, Pe = !0, At = null, e !== null && (vt[xt++] = Xt, vt[xt++] = Qt, vt[xt++] = zn, Xt = e.id, Qt = e.overflow, zn = t), t = al(t, a.children), t.flags |= 4096, t) } function Dd(e, t, i) { e.lanes |= t; var a = e.alternate; a !== null && (a.lanes |= t), Fa(e.return, t, i) } function ll(e, t, i, a, u) { var d = e.memoizedState; d === null ? e.memoizedState = { isBackwards: t, rendering: null, renderingStartTime: 0, last: a, tail: i, tailMode: u } : (d.isBackwards = t, d.rendering = null, d.renderingStartTime = 0, d.last = a, d.tail = i, d.tailMode = u) } function jd(e, t, i) { var a = t.pendingProps, u = a.revealOrder, d = a.tail; if (it(e, t, a.children, i), a = Re.current, (a & 2) !== 0) a = a & 1 | 2, t.flags |= 128; else { if (e !== null && (e.flags & 128) !== 0) e: for (e = t.child; e !== null;) { if (e.tag === 13) e.memoizedState !== null && Dd(e, i, t); else if (e.tag === 19) Dd(e, i, t); else if (e.child !== null) { e.child.return = e, e = e.child; continue } if (e === t) break e; for (; e.sibling === null;) { if (e.return === null || e.return === t) break e; e = e.return } e.sibling.return = e.return, e = e.sibling } a &= 1 } if (Se(Re, a), (t.mode & 1) === 0) t.memoizedState = null; else switch (u) { case "forwards": for (i = t.child, u = null; i !== null;)e = i.alternate, e !== null && Vo(e) === null && (u = i), i = i.sibling; i = u, i === null ? (u = t.child, t.child = null) : (u = i.sibling, i.sibling = null), ll(t, !1, u, i, d); break; case "backwards": for (i = null, u = t.child, t.child = null; u !== null;) { if (e = u.alternate, e !== null && Vo(e) === null) { t.child = u; break } e = u.sibling, u.sibling = i, i = u, u = e } ll(t, !0, i, null, d); break; case "together": ll(t, !1, null, null, void 0); break; default: t.memoizedState = null }return t.child } function Uo(e, t) { (t.mode & 1) === 0 && e !== null && (e.alternate = null, t.alternate = null, t.flags |= 2) } function Jt(e, t, i) { if (e !== null && (t.dependencies = e.dependencies), Wn |= t.lanes, (i & t.childLanes) === 0) return null; if (e !== null && t.child !== e.child) throw Error(o(153)); if (t.child !== null) { for (e = t.child, i = Tn(e, e.pendingProps), t.child = i, i.return = t; e.sibling !== null;)e = e.sibling, i = i.sibling = Tn(e, e.pendingProps), i.return = t; i.sibling = null } return t.child } function Dv(e, t, i) { switch (t.tag) { case 3: Ad(t), yr(); break; case 5: Gf(t); break; case 1: ut(t.type) && Eo(t); break; case 4: Ba(t, t.stateNode.containerInfo); break; case 10: var a = t.type._context, u = t.memoizedProps.value; Se(Lo, a._currentValue), a._currentValue = u; break; case 13: if (a = t.memoizedState, a !== null) return a.dehydrated !== null ? (Se(Re, Re.current & 1), t.flags |= 128, null) : (i & t.child.childLanes) !== 0 ? Nd(e, t, i) : (Se(Re, Re.current & 1), e = Jt(e, t, i), e !== null ? e.sibling : null); Se(Re, Re.current & 1); break; case 19: if (a = (i & t.childLanes) !== 0, (e.flags & 128) !== 0) { if (a) return jd(e, t, i); t.flags |= 128 } if (u = t.memoizedState, u !== null && (u.rendering = null, u.tail = null, u.lastEffect = null), Se(Re, Re.current), a) break; return null; case 22: case 23: return t.lanes = 0, Pd(e, t, i) }return Jt(e, t, i) } var Vd, ul, _d, bd; Vd = function (e, t) { for (var i = t.child; i !== null;) { if (i.tag === 5 || i.tag === 6) e.appendChild(i.stateNode); else if (i.tag !== 4 && i.child !== null) { i.child.return = i, i = i.child; continue } if (i === t) break; for (; i.sibling === null;) { if (i.return === null || i.return === t) return; i = i.return } i.sibling.return = i.return, i = i.sibling } }, ul = function () { }, _d = function (e, t, i, a) { var u = e.memoizedProps; if (u !== a) { e = t.stateNode, Un(Ot.current); var d = null; switch (i) { case "input": u = Fs(e, u), a = Fs(e, a), d = []; break; case "select": u = H({}, u, { value: void 0 }), a = H({}, a, { value: void 0 }), d = []; break; case "textarea": u = Bs(e, u), a = Bs(e, a), d = []; break; default: typeof u.onClick != "function" && typeof a.onClick == "function" && (e.onclick = So) }$s(i, a); var m; i = null; for (D in u) if (!a.hasOwnProperty(D) && u.hasOwnProperty(D) && u[D] != null) if (D === "style") { var w = u[D]; for (m in w) w.hasOwnProperty(m) && (i || (i = {}), i[m] = "") } else D !== "dangerouslySetInnerHTML" && D !== "children" && D !== "suppressContentEditableWarning" && D !== "suppressHydrationWarning" && D !== "autoFocus" && (l.hasOwnProperty(D) ? d || (d = []) : (d = d || []).push(D, null)); for (D in a) { var S = a[D]; if (w = u != null ? u[D] : void 0, a.hasOwnProperty(D) && S !== w && (S != null || w != null)) if (D === "style") if (w) { for (m in w) !w.hasOwnProperty(m) || S && S.hasOwnProperty(m) || (i || (i = {}), i[m] = ""); for (m in S) S.hasOwnProperty(m) && w[m] !== S[m] && (i || (i = {}), i[m] = S[m]) } else i || (d || (d = []), d.push(D, i)), i = S; else D === "dangerouslySetInnerHTML" ? (S = S ? S.__html : void 0, w = w ? w.__html : void 0, S != null && w !== S && (d = d || []).push(D, S)) : D === "children" ? typeof S != "string" && typeof S != "number" || (d = d || []).push(D, "" + S) : D !== "suppressContentEditableWarning" && D !== "suppressHydrationWarning" && (l.hasOwnProperty(D) ? (S != null && D === "onScroll" && Ee("scroll", e), d || w === S || (d = [])) : (d = d || []).push(D, S)) } i && (d = d || []).push("style", i); var D = d; (t.updateQueue = D) && (t.flags |= 4) } }, bd = function (e, t, i, a) { i !== a && (t.flags |= 4) }; function ki(e, t) { if (!Pe) switch (e.tailMode) { case "hidden": t = e.tail; for (var i = null; t !== null;)t.alternate !== null && (i = t), t = t.sibling; i === null ? e.tail = null : i.sibling = null; break; case "collapsed": i = e.tail; for (var a = null; i !== null;)i.alternate !== null && (a = i), i = i.sibling; a === null ? t || e.tail === null ? e.tail = null : e.tail.sibling = null : a.sibling = null } } function tt(e) { var t = e.alternate !== null && e.alternate.child === e.child, i = 0, a = 0; if (t) for (var u = e.child; u !== null;)i |= u.lanes | u.childLanes, a |= u.subtreeFlags & 14680064, a |= u.flags & 14680064, u.return = e, u = u.sibling; else for (u = e.child; u !== null;)i |= u.lanes | u.childLanes, a |= u.subtreeFlags, a |= u.flags, u.return = e, u = u.sibling; return e.subtreeFlags |= a, e.childLanes = i, t } function jv(e, t, i) { var a = t.pendingProps; switch (Na(t), t.tag) { case 2: case 16: case 15: case 0: case 11: case 7: case 8: case 12: case 9: case 14: return tt(t), null; case 1: return ut(t.type) && Co(), tt(t), null; case 3: return a = t.stateNode, Sr(), Te(lt), Te(Je), Wa(), a.pendingContext && (a.context = a.pendingContext, a.pendingContext = null), (e === null || e.child === null) && (Mo(t) ? t.flags |= 4 : e === null || e.memoizedState.isDehydrated && (t.flags & 256) === 0 || (t.flags |= 1024, At !== null && (wl(At), At = null))), ul(e, t), tt(t), null; case 5: Ua(t); var u = Un(yi.current); if (i = t.type, e !== null && t.stateNode != null) _d(e, t, i, a, u), e.ref !== t.ref && (t.flags |= 512, t.flags |= 2097152); else { if (!a) { if (t.stateNode === null) throw Error(o(166)); return tt(t), null } if (e = Un(Ot.current), Mo(t)) { a = t.stateNode, i = t.type; var d = t.memoizedProps; switch (a[zt] = t, a[di] = d, e = (t.mode & 1) !== 0, i) { case "dialog": Ee("cancel", a), Ee("close", a); break; case "iframe": case "object": case "embed": Ee("load", a); break; case "video": case "audio": for (u = 0; u < ui.length; u++)Ee(ui[u], a); break; case "source": Ee("error", a); break; case "img": case "image": case "link": Ee("error", a), Ee("load", a); break; case "details": Ee("toggle", a); break; case "input": mc(a, d), Ee("invalid", a); break; case "select": a._wrapperState = { wasMultiple: !!d.multiple }, Ee("invalid", a); break; case "textarea": vc(a, d), Ee("invalid", a) }$s(i, d), u = null; for (var m in d) if (d.hasOwnProperty(m)) { var w = d[m]; m === "children" ? typeof w == "string" ? a.textContent !== w && (d.suppressHydrationWarning !== !0 && wo(a.textContent, w, e), u = ["children", w]) : typeof w == "number" && a.textContent !== "" + w && (d.suppressHydrationWarning !== !0 && wo(a.textContent, w, e), u = ["children", "" + w]) : l.hasOwnProperty(m) && w != null && m === "onScroll" && Ee("scroll", a) } switch (i) { case "input": an(a), yc(a, d, !0); break; case "textarea": an(a), wc(a); break; case "select": case "option": break; default: typeof d.onClick == "function" && (a.onclick = So) }a = u, t.updateQueue = a, a !== null && (t.flags |= 4) } else { m = u.nodeType === 9 ? u : u.ownerDocument, e === "http://www.w3.org/1999/xhtml" && (e = Sc(i)), e === "http://www.w3.org/1999/xhtml" ? i === "script" ? (e = m.createElement("div"), e.innerHTML = "<script><\/script>", e = e.removeChild(e.firstChild)) : typeof a.is == "string" ? e = m.createElement(i, { is: a.is }) : (e = m.createElement(i), i === "select" && (m = e, a.multiple ? m.multiple = !0 : a.size && (m.size = a.size))) : e = m.createElementNS(e, i), e[zt] = t, e[di] = a, Vd(e, t, !1, !1), t.stateNode = e; e: { switch (m = Ws(i, a), i) { case "dialog": Ee("cancel", e), Ee("close", e), u = a; break; case "iframe": case "object": case "embed": Ee("load", e), u = a; break; case "video": case "audio": for (u = 0; u < ui.length; u++)Ee(ui[u], e); u = a; break; case "source": Ee("error", e), u = a; break; case "img": case "image": case "link": Ee("error", e), Ee("load", e), u = a; break; case "details": Ee("toggle", e), u = a; break; case "input": mc(e, a), u = Fs(e, a), Ee("invalid", e); break; case "option": u = a; break; case "select": e._wrapperState = { wasMultiple: !!a.multiple }, u = H({}, a, { value: void 0 }), Ee("invalid", e); break; case "textarea": vc(e, a), u = Bs(e, a), Ee("invalid", e); break; default: u = a }$s(i, u), w = u; for (d in w) if (w.hasOwnProperty(d)) { var S = w[d]; d === "style" ? Ec(e, S) : d === "dangerouslySetInnerHTML" ? (S = S ? S.__html : void 0, S != null && kc(e, S)) : d === "children" ? typeof S == "string" ? (i !== "textarea" || S !== "") && Wr(e, S) : typeof S == "number" && Wr(e, "" + S) : d !== "suppressContentEditableWarning" && d !== "suppressHydrationWarning" && d !== "autoFocus" && (l.hasOwnProperty(d) ? S != null && d === "onScroll" && Ee("scroll", e) : S != null && j(e, d, S, m)) } switch (i) { case "input": an(e), yc(e, a, !1); break; case "textarea": an(e), wc(e); break; case "option": a.value != null && e.setAttribute("value", "" + ge(a.value)); break; case "select": e.multiple = !!a.multiple, d = a.value, d != null ? nr(e, !!a.multiple, d, !1) : a.defaultValue != null && nr(e, !!a.multiple, a.defaultValue, !0); break; default: typeof u.onClick == "function" && (e.onclick = So) }switch (i) { case "button": case "input": case "select": case "textarea": a = !!a.autoFocus; break e; case "img": a = !0; break e; default: a = !1 } } a && (t.flags |= 4) } t.ref !== null && (t.flags |= 512, t.flags |= 2097152) } return tt(t), null; case 6: if (e && t.stateNode != null) bd(e, t, e.memoizedProps, a); else { if (typeof a != "string" && t.stateNode === null) throw Error(o(166)); if (i = Un(yi.current), Un(Ot.current), Mo(t)) { if (a = t.stateNode, i = t.memoizedProps, a[zt] = t, (d = a.nodeValue !== i) && (e = mt, e !== null)) switch (e.tag) { case 3: wo(a.nodeValue, i, (e.mode & 1) !== 0); break; case 5: e.memoizedProps.suppressHydrationWarning !== !0 && wo(a.nodeValue, i, (e.mode & 1) !== 0) }d && (t.flags |= 4) } else a = (i.nodeType === 9 ? i : i.ownerDocument).createTextNode(a), a[zt] = t, t.stateNode = a } return tt(t), null; case 13: if (Te(Re), a = t.memoizedState, e === null || e.memoizedState !== null && e.memoizedState.dehydrated !== null) { if (Pe && gt !== null && (t.mode & 1) !== 0 && (t.flags & 128) === 0) zf(), yr(), t.flags |= 98560, d = !1; else if (d = Mo(t), a !== null && a.dehydrated !== null) { if (e === null) { if (!d) throw Error(o(318)); if (d = t.memoizedState, d = d !== null ? d.dehydrated : null, !d) throw Error(o(317)); d[zt] = t } else yr(), (t.flags & 128) === 0 && (t.memoizedState = null), t.flags |= 4; tt(t), d = !1 } else At !== null && (wl(At), At = null), d = !0; if (!d) return t.flags & 65536 ? t : null } return (t.flags & 128) !== 0 ? (t.lanes = i, t) : (a = a !== null, a !== (e !== null && e.memoizedState !== null) && a && (t.child.flags |= 8192, (t.mode & 1) !== 0 && (e === null || (Re.current & 1) !== 0 ? ze === 0 && (ze = 3) : Cl())), t.updateQueue !== null && (t.flags |= 4), tt(t), null); case 4: return Sr(), ul(e, t), e === null && ci(t.stateNode.containerInfo), tt(t), null; case 10: return Ia(t.type._context), tt(t), null; case 17: return ut(t.type) && Co(), tt(t), null; case 19: if (Te(Re), d = t.memoizedState, d === null) return tt(t), null; if (a = (t.flags & 128) !== 0, m = d.rendering, m === null) if (a) ki(d, !1); else { if (ze !== 0 || e !== null && (e.flags & 128) !== 0) for (e = t.child; e !== null;) { if (m = Vo(e), m !== null) { for (t.flags |= 128, ki(d, !1), a = m.updateQueue, a !== null && (t.updateQueue = a, t.flags |= 4), t.subtreeFlags = 0, a = i, i = t.child; i !== null;)d = i, e = a, d.flags &= 14680066, m = d.alternate, m === null ? (d.childLanes = 0, d.lanes = e, d.child = null, d.subtreeFlags = 0, d.memoizedProps = null, d.memoizedState = null, d.updateQueue = null, d.dependencies = null, d.stateNode = null) : (d.childLanes = m.childLanes, d.lanes = m.lanes, d.child = m.child, d.subtreeFlags = 0, d.deletions = null, d.memoizedProps = m.memoizedProps, d.memoizedState = m.memoizedState, d.updateQueue = m.updateQueue, d.type = m.type, e = m.dependencies, d.dependencies = e === null ? null : { lanes: e.lanes, firstContext: e.firstContext }), i = i.sibling; return Se(Re, Re.current & 1 | 2), t.child } e = e.sibling } d.tail !== null && je() > Tr && (t.flags |= 128, a = !0, ki(d, !1), t.lanes = 4194304) } else { if (!a) if (e = Vo(m), e !== null) { if (t.flags |= 128, a = !0, i = e.updateQueue, i !== null && (t.updateQueue = i, t.flags |= 4), ki(d, !0), d.tail === null && d.tailMode === "hidden" && !m.alternate && !Pe) return tt(t), null } else 2 * je() - d.renderingStartTime > Tr && i !== 1073741824 && (t.flags |= 128, a = !0, ki(d, !1), t.lanes = 4194304); d.isBackwards ? (m.sibling = t.child, t.child = m) : (i = d.last, i !== null ? i.sibling = m : t.child = m, d.last = m) } return d.tail !== null ? (t = d.tail, d.rendering = t, d.tail = t.sibling, d.renderingStartTime = je(), t.sibling = null, i = Re.current, Se(Re, a ? i & 1 | 2 : i & 1), t) : (tt(t), null); case 22: case 23: return kl(), a = t.memoizedState !== null, e !== null && e.memoizedState !== null !== a && (t.flags |= 8192), a && (t.mode & 1) !== 0 ? (yt & 1073741824) !== 0 && (tt(t), t.subtreeFlags & 6 && (t.flags |= 8192)) : tt(t), null; case 24: return null; case 25: return null }throw Error(o(156, t.tag)) } function Vv(e, t) { switch (Na(t), t.tag) { case 1: return ut(t.type) && Co(), e = t.flags, e & 65536 ? (t.flags = e & -65537 | 128, t) : null; case 3: return Sr(), Te(lt), Te(Je), Wa(), e = t.flags, (e & 65536) !== 0 && (e & 128) === 0 ? (t.flags = e & -65537 | 128, t) : null; case 5: return Ua(t), null; case 13: if (Te(Re), e = t.memoizedState, e !== null && e.dehydrated !== null) { if (t.alternate === null) throw Error(o(340)); yr() } return e = t.flags, e & 65536 ? (t.flags = e & -65537 | 128, t) : null; case 19: return Te(Re), null; case 4: return Sr(), null; case 10: return Ia(t.type._context), null; case 22: case 23: return kl(), null; case 24: return null; default: return null } } var $o = !1, nt = !1, _v = typeof WeakSet == "function" ? WeakSet : Set, G = null; function Cr(e, t) { var i = e.ref; if (i !== null) if (typeof i == "function") try { i(null) } catch (a) { Ne(e, t, a) } else i.current = null } function cl(e, t, i) { try { i() } catch (a) { Ne(e, t, a) } } var Id = !1; function bv(e, t) { if (ka = lo, e = mf(), pa(e)) { if ("selectionStart" in e) var i = { start: e.selectionStart, end: e.selectionEnd }; else e: { i = (i = e.ownerDocument) && i.defaultView || window; var a = i.getSelection && i.getSelection(); if (a && a.rangeCount !== 0) { i = a.anchorNode; var u = a.anchorOffset, d = a.focusNode; a = a.focusOffset; try { i.nodeType, d.nodeType } catch { i = null; break e } var m = 0, w = -1, S = -1, D = 0, z = 0, B = e, F = null; t: for (; ;) { for (var K; B !== i || u !== 0 && B.nodeType !== 3 || (w = m + u), B !== d || a !== 0 && B.nodeType !== 3 || (S = m + a), B.nodeType === 3 && (m += B.nodeValue.length), (K = B.firstChild) !== null;)F = B, B = K; for (; ;) { if (B === e) break t; if (F === i && ++D === u && (w = m), F === d && ++z === a && (S = m), (K = B.nextSibling) !== null) break; B = F, F = B.parentNode } B = K } i = w === -1 || S === -1 ? null : { start: w, end: S } } else i = null } i = i || { start: 0, end: 0 } } else i = null; for (Ca = { focusedElem: e, selectionRange: i }, lo = !1, G = t; G !== null;)if (t = G, e = t.child, (t.subtreeFlags & 1028) !== 0 && e !== null) e.return = t, G = e; else for (; G !== null;) { t = G; try { var Y = t.alternate; if ((t.flags & 1024) !== 0) switch (t.tag) { case 0: case 11: case 15: break; case 1: if (Y !== null) { var q = Y.memoizedProps, Ve = Y.memoizedState, R = t.stateNode, k = R.getSnapshotBeforeUpdate(t.elementType === t.type ? q : Lt(t.type, q), Ve); R.__reactInternalSnapshotBeforeUpdate = k } break; case 3: var L = t.stateNode.containerInfo; L.nodeType === 1 ? L.textContent = "" : L.nodeType === 9 && L.documentElement && L.removeChild(L.documentElement); break; case 5: case 6: case 4: case 17: break; default: throw Error(o(163)) } } catch ($) { Ne(t, t.return, $) } if (e = t.sibling, e !== null) { e.return = t.return, G = e; break } G = t.return } return Y = Id, Id = !1, Y } function Ci(e, t, i) { var a = t.updateQueue; if (a = a !== null ? a.lastEffect : null, a !== null) { var u = a = a.next; do { if ((u.tag & e) === e) { var d = u.destroy; u.destroy = void 0, d !== void 0 && cl(t, i, d) } u = u.next } while (u !== a) } } function Wo(e, t) { if (t = t.updateQueue, t = t !== null ? t.lastEffect : null, t !== null) { var i = t = t.next; do { if ((i.tag & e) === e) { var a = i.create; i.destroy = a() } i = i.next } while (i !== t) } } function fl(e) { var t = e.ref; if (t !== null) { var i = e.stateNode; switch (e.tag) { case 5: e = i; break; default: e = i }typeof t == "function" ? t(e) : t.current = e } } function Fd(e) { var t = e.alternate; t !== null && (e.alternate = null, Fd(t)), e.child = null, e.deletions = null, e.sibling = null, e.tag === 5 && (t = e.stateNode, t !== null && (delete t[zt], delete t[di], delete t[Ra], delete t[vv], delete t[xv])), e.stateNode = null, e.return = null, e.dependencies = null, e.memoizedProps = null, e.memoizedState = null, e.pendingProps = null, e.stateNode = null, e.updateQueue = null } function zd(e) { return e.tag === 5 || e.tag === 3 || e.tag === 4 } function Od(e) { e: for (; ;) { for (; e.sibling === null;) { if (e.return === null || zd(e.return)) return null; e = e.return } for (e.sibling.return = e.return, e = e.sibling; e.tag !== 5 && e.tag !== 6 && e.tag !== 18;) { if (e.flags & 2 || e.child === null || e.tag === 4) continue e; e.child.return = e, e = e.child } if (!(e.flags & 2)) return e.stateNode } } function dl(e, t, i) { var a = e.tag; if (a === 5 || a === 6) e = e.stateNode, t ? i.nodeType === 8 ? i.parentNode.insertBefore(e, t) : i.insertBefore(e, t) : (i.nodeType === 8 ? (t = i.parentNode, t.insertBefore(e, i)) : (t = i, t.appendChild(e)), i = i._reactRootContainer, i != null || t.onclick !== null || (t.onclick = So)); else if (a !== 4 && (e = e.child, e !== null)) for (dl(e, t, i), e = e.sibling; e !== null;)dl(e, t, i), e = e.sibling } function hl(e, t, i) { var a = e.tag; if (a === 5 || a === 6) e = e.stateNode, t ? i.insertBefore(e, t) : i.appendChild(e); else if (a !== 4 && (e = e.child, e !== null)) for (hl(e, t, i), e = e.sibling; e !== null;)hl(e, t, i), e = e.sibling } var Qe = null, Nt = !1; function wn(e, t, i) { for (i = i.child; i !== null;)Bd(e, t, i), i = i.sibling } function Bd(e, t, i) { if (Ft && typeof Ft.onCommitFiberUnmount == "function") try { Ft.onCommitFiberUnmount(no, i) } catch { } switch (i.tag) { case 5: nt || Cr(i, t); case 6: var a = Qe, u = Nt; Qe = null, wn(e, t, i), Qe = a, Nt = u, Qe !== null && (Nt ? (e = Qe, i = i.stateNode, e.nodeType === 8 ? e.parentNode.removeChild(i) : e.removeChild(i)) : Qe.removeChild(i.stateNode)); break; case 18: Qe !== null && (Nt ? (e = Qe, i = i.stateNode, e.nodeType === 8 ? Pa(e.parentNode, i) : e.nodeType === 1 && Pa(e, i), ti(e)) : Pa(Qe, i.stateNode)); break; case 4: a = Qe, u = Nt, Qe = i.stateNode.containerInfo, Nt = !0, wn(e, t, i), Qe = a, Nt = u; break; case 0: case 11: case 14: case 15: if (!nt && (a = i.updateQueue, a !== null && (a = a.lastEffect, a !== null))) { u = a = a.next; do { var d = u, m = d.destroy; d = d.tag, m !== void 0 && ((d & 2) !== 0 || (d & 4) !== 0) && cl(i, t, m), u = u.next } while (u !== a) } wn(e, t, i); break; case 1: if (!nt && (Cr(i, t), a = i.stateNode, typeof a.componentWillUnmount == "function")) try { a.props = i.memoizedProps, a.state = i.memoizedState, a.componentWillUnmount() } catch (w) { Ne(i, t, w) } wn(e, t, i); break; case 21: wn(e, t, i); break; case 22: i.mode & 1 ? (nt = (a = nt) || i.memoizedState !== null, wn(e, t, i), nt = a) : wn(e, t, i); break; default: wn(e, t, i) } } function Ud(e) { var t = e.updateQueue; if (t !== null) { e.updateQueue = null; var i = e.stateNode; i === null && (i = e.stateNode = new _v), t.forEach(function (a) { var u = Hv.bind(null, e, a); i.has(a) || (i.add(a), a.then(u, u)) }) } } function Dt(e, t) { var i = t.deletions; if (i !== null) for (var a = 0; a < i.length; a++) { var u = i[a]; try { var d = e, m = t, w = m; e: for (; w !== null;) { switch (w.tag) { case 5: Qe = w.stateNode, Nt = !1; break e; case 3: Qe = w.stateNode.containerInfo, Nt = !0; break e; case 4: Qe = w.stateNode.containerInfo, Nt = !0; break e }w = w.return } if (Qe === null) throw Error(o(160)); Bd(d, m, u), Qe = null, Nt = !1; var S = u.alternate; S !== null && (S.return = null), u.return = null } catch (D) { Ne(u, t, D) } } if (t.subtreeFlags & 12854) for (t = t.child; t !== null;)$d(t, e), t = t.sibling } function $d(e, t) { var i = e.alternate, a = e.flags; switch (e.tag) { case 0: case 11: case 14: case 15: if (Dt(t, e), Ut(e), a & 4) { try { Ci(3, e, e.return), Wo(3, e) } catch (q) { Ne(e, e.return, q) } try { Ci(5, e, e.return) } catch (q) { Ne(e, e.return, q) } } break; case 1: Dt(t, e), Ut(e), a & 512 && i !== null && Cr(i, i.return); break; case 5: if (Dt(t, e), Ut(e), a & 512 && i !== null && Cr(i, i.return), e.flags & 32) { var u = e.stateNode; try { Wr(u, "") } catch (q) { Ne(e, e.return, q) } } if (a & 4 && (u = e.stateNode, u != null)) { var d = e.memoizedProps, m = i !== null ? i.memoizedProps : d, w = e.type, S = e.updateQueue; if (e.updateQueue = null, S !== null) try { w === "input" && d.type === "radio" && d.name != null && gc(u, d), Ws(w, m); var D = Ws(w, d); for (m = 0; m < S.length; m += 2) { var z = S[m], B = S[m + 1]; z === "style" ? Ec(u, B) : z === "dangerouslySetInnerHTML" ? kc(u, B) : z === "children" ? Wr(u, B) : j(u, z, B, D) } switch (w) { case "input": zs(u, d); break; case "textarea": xc(u, d); break; case "select": var F = u._wrapperState.wasMultiple; u._wrapperState.wasMultiple = !!d.multiple; var K = d.value; K != null ? nr(u, !!d.multiple, K, !1) : F !== !!d.multiple && (d.defaultValue != null ? nr(u, !!d.multiple, d.defaultValue, !0) : nr(u, !!d.multiple, d.multiple ? [] : "", !1)) }u[di] = d } catch (q) { Ne(e, e.return, q) } } break; case 6: if (Dt(t, e), Ut(e), a & 4) { if (e.stateNode === null) throw Error(o(162)); u = e.stateNode, d = e.memoizedProps; try { u.nodeValue = d } catch (q) { Ne(e, e.return, q) } } break; case 3: if (Dt(t, e), Ut(e), a & 4 && i !== null && i.memoizedState.isDehydrated) try { ti(t.containerInfo) } catch (q) { Ne(e, e.return, q) } break; case 4: Dt(t, e), Ut(e); break; case 13: Dt(t, e), Ut(e), u = e.child, u.flags & 8192 && (d = u.memoizedState !== null, u.stateNode.isHidden = d, !d || u.alternate !== null && u.alternate.memoizedState !== null || (gl = je())), a & 4 && Ud(e); break; case 22: if (z = i !== null && i.memoizedState !== null, e.mode & 1 ? (nt = (D = nt) || z, Dt(t, e), nt = D) : Dt(t, e), Ut(e), a & 8192) { if (D = e.memoizedState !== null, (e.stateNode.isHidden = D) && !z && (e.mode & 1) !== 0) for (G = e, z = e.child; z !== null;) { for (B = G = z; G !== null;) { switch (F = G, K = F.child, F.tag) { case 0: case 11: case 14: case 15: Ci(4, F, F.return); break; case 1: Cr(F, F.return); var Y = F.stateNode; if (typeof Y.componentWillUnmount == "function") { a = F, i = F.return; try { t = a, Y.props = t.memoizedProps, Y.state = t.memoizedState, Y.componentWillUnmount() } catch (q) { Ne(a, i, q) } } break; case 5: Cr(F, F.return); break; case 22: if (F.memoizedState !== null) { Kd(B); continue } }K !== null ? (K.return = F, G = K) : Kd(B) } z = z.sibling } e: for (z = null, B = e; ;) { if (B.tag === 5) { if (z === null) { z = B; try { u = B.stateNode, D ? (d = u.style, typeof d.setProperty == "function" ? d.setProperty("display", "none", "important") : d.display = "none") : (w = B.stateNode, S = B.memoizedProps.style, m = S != null && S.hasOwnProperty("display") ? S.display : null, w.style.display = Cc("display", m)) } catch (q) { Ne(e, e.return, q) } } } else if (B.tag === 6) { if (z === null) try { B.stateNode.nodeValue = D ? "" : B.memoizedProps } catch (q) { Ne(e, e.return, q) } } else if ((B.tag !== 22 && B.tag !== 23 || B.memoizedState === null || B === e) && B.child !== null) { B.child.return = B, B = B.child; continue } if (B === e) break e; for (; B.sibling === null;) { if (B.return === null || B.return === e) break e; z === B && (z = null), B = B.return } z === B && (z = null), B.sibling.return = B.return, B = B.sibling } } break; case 19: Dt(t, e), Ut(e), a & 4 && Ud(e); break; case 21: break; default: Dt(t, e), Ut(e) } } function Ut(e) { var t = e.flags; if (t & 2) { try { e: { for (var i = e.return; i !== null;) { if (zd(i)) { var a = i; break e } i = i.return } throw Error(o(160)) } switch (a.tag) { case 5: var u = a.stateNode; a.flags & 32 && (Wr(u, ""), a.flags &= -33); var d = Od(e); hl(e, d, u); break; case 3: case 4: var m = a.stateNode.containerInfo, w = Od(e); dl(e, w, m); break; default: throw Error(o(161)) } } catch (S) { Ne(e, e.return, S) } e.flags &= -3 } t & 4096 && (e.flags &= -4097) } function Iv(e, t, i) { G = e, Wd(e) } function Wd(e, t, i) { for (var a = (e.mode & 1) !== 0; G !== null;) { var u = G, d = u.child; if (u.tag === 22 && a) { var m = u.memoizedState !== null || $o; if (!m) { var w = u.alternate, S = w !== null && w.memoizedState !== null || nt; w = $o; var D = nt; if ($o = m, (nt = S) && !D) for (G = u; G !== null;)m = G, S = m.child, m.tag === 22 && m.memoizedState !== null ? Gd(u) : S !== null ? (S.return = m, G = S) : Gd(u); for (; d !== null;)G = d, Wd(d), d = d.sibling; G = u, $o = w, nt = D } Hd(e) } else (u.subtreeFlags & 8772) !== 0 && d !== null ? (d.return = u, G = d) : Hd(e) } } function Hd(e) { for (; G !== null;) { var t = G; if ((t.flags & 8772) !== 0) { var i = t.alternate; try { if ((t.flags & 8772) !== 0) switch (t.tag) { case 0: case 11: case 15: nt || Wo(5, t); break; case 1: var a = t.stateNode; if (t.flags & 4 && !nt) if (i === null) a.componentDidMount(); else { var u = t.elementType === t.type ? i.memoizedProps : Lt(t.type, i.memoizedProps); a.componentDidUpdate(u, i.memoizedState, a.__reactInternalSnapshotBeforeUpdate) } var d = t.updateQueue; d !== null && Kf(t, d, a); break; case 3: var m = t.updateQueue; if (m !== null) { if (i = null, t.child !== null) switch (t.child.tag) { case 5: i = t.child.stateNode; break; case 1: i = t.child.stateNode }Kf(t, m, i) } break; case 5: var w = t.stateNode; if (i === null && t.flags & 4) { i = w; var S = t.memoizedProps; switch (t.type) { case "button": case "input": case "select": case "textarea": S.autoFocus && i.focus(); break; case "img": S.src && (i.src = S.src) } } break; case 6: break; case 4: break; case 12: break; case 13: if (t.memoizedState === null) { var D = t.alternate; if (D !== null) { var z = D.memoizedState; if (z !== null) { var B = z.dehydrated; B !== null && ti(B) } } } break; case 19: case 17: case 21: case 22: case 23: case 25: break; default: throw Error(o(163)) }nt || t.flags & 512 && fl(t) } catch (F) { Ne(t, t.return, F) } } if (t === e) { G = null; break } if (i = t.sibling, i !== null) { i.return = t.return, G = i; break } G = t.return } } function Kd(e) { for (; G !== null;) { var t = G; if (t === e) { G = null; break } var i = t.sibling; if (i !== null) { i.return = t.return, G = i; break } G = t.return } } function Gd(e) { for (; G !== null;) { var t = G; try { switch (t.tag) { case 0: case 11: case 15: var i = t.return; try { Wo(4, t) } catch (S) { Ne(t, i, S) } break; case 1: var a = t.stateNode; if (typeof a.componentDidMount == "function") { var u = t.return; try { a.componentDidMount() } catch (S) { Ne(t, u, S) } } var d = t.return; try { fl(t) } catch (S) { Ne(t, d, S) } break; case 5: var m = t.return; try { fl(t) } catch (S) { Ne(t, m, S) } } } catch (S) { Ne(t, t.return, S) } if (t === e) { G = null; break } var w = t.sibling; if (w !== null) { w.return = t.return, G = w; break } G = t.return } } var Fv = Math.ceil, Ho = W.ReactCurrentDispatcher, pl = W.ReactCurrentOwner, kt = W.ReactCurrentBatchConfig, me = 0, Ge = null, be = null, Ze = 0, yt = 0, Er = mn(0), ze = 0, Ei = null, Wn = 0, Ko = 0, ml = 0, Ti = null, ft = null, gl = 0, Tr = 1 / 0, en = null, Go = !1, yl = null, Sn = null, Yo = !1, kn = null, Xo = 0, Pi = 0, vl = null, Qo = -1, Zo = 0; function ot() { return (me & 6) !== 0 ? je() : Qo !== -1 ? Qo : Qo = je() } function Cn(e) { return (e.mode & 1) === 0 ? 1 : (me & 2) !== 0 && Ze !== 0 ? Ze & -Ze : Sv.transition !== null ? (Zo === 0 && (Zo = zc()), Zo) : (e = we, e !== 0 || (e = window.event, e = e === void 0 ? 16 : Yc(e.type)), e) } function jt(e, t, i, a) { if (50 < Pi) throw Pi = 0, vl = null, Error(o(185)); Qr(e, i, a), ((me & 2) === 0 || e !== Ge) && (e === Ge && ((me & 2) === 0 && (Ko |= i), ze === 4 && En(e, Ze)), dt(e, a), i === 1 && me === 0 && (t.mode & 1) === 0 && (Tr = je() + 500, To && yn())) } function dt(e, t) { var i = e.callbackNode; Sy(e, t); var a = oo(e, e === Ge ? Ze : 0); if (a === 0) i !== null && bc(i), e.callbackNode = null, e.callbackPriority = 0; else if (t = a & -a, e.callbackPriority !== t) { if (i != null && bc(i), t === 1) e.tag === 0 ? wv(Xd.bind(null, e)) : Vf(Xd.bind(null, e)), gv(function () { (me & 6) === 0 && yn() }), i = null; else { switch (Oc(a)) { case 1: i = Zs; break; case 4: i = Ic; break; case 16: i = to; break; case 536870912: i = Fc; break; default: i = to }i = rh(i, Yd.bind(null, e)) } e.callbackPriority = t, e.callbackNode = i } } function Yd(e, t) { if (Qo = -1, Zo = 0, (me & 6) !== 0) throw Error(o(327)); var i = e.callbackNode; if (Pr() && e.callbackNode !== i) return null; var a = oo(e, e === Ge ? Ze : 0); if (a === 0) return null; if ((a & 30) !== 0 || (a & e.expiredLanes) !== 0 || t) t = qo(e, a); else { t = a; var u = me; me |= 2; var d = Zd(); (Ge !== e || Ze !== t) && (en = null, Tr = je() + 500, Kn(e, t)); do try { Bv(); break } catch (w) { Qd(e, w) } while (!0); ba(), Ho.current = d, me = u, be !== null ? t = 0 : (Ge = null, Ze = 0, t = ze) } if (t !== 0) { if (t === 2 && (u = qs(e), u !== 0 && (a = u, t = xl(e, u))), t === 1) throw i = Ei, Kn(e, 0), En(e, a), dt(e, je()), i; if (t === 6) En(e, a); else { if (u = e.current.alternate, (a & 30) === 0 && !zv(u) && (t = qo(e, a), t === 2 && (d = qs(e), d !== 0 && (a = d, t = xl(e, d))), t === 1)) throw i = Ei, Kn(e, 0), En(e, a), dt(e, je()), i; switch (e.finishedWork = u, e.finishedLanes = a, t) { case 0: case 1: throw Error(o(345)); case 2: Gn(e, ft, en); break; case 3: if (En(e, a), (a & 130023424) === a && (t = gl + 500 - je(), 10 < t)) { if (oo(e, 0) !== 0) break; if (u = e.suspendedLanes, (u & a) !== a) { ot(), e.pingedLanes |= e.suspendedLanes & u; break } e.timeoutHandle = Ta(Gn.bind(null, e, ft, en), t); break } Gn(e, ft, en); break; case 4: if (En(e, a), (a & 4194240) === a) break; for (t = e.eventTimes, u = -1; 0 < a;) { var m = 31 - Rt(a); d = 1 << m, m = t[m], m > u && (u = m), a &= ~d } if (a = u, a = je() - a, a = (120 > a ? 120 : 480 > a ? 480 : 1080 > a ? 1080 : 1920 > a ? 1920 : 3e3 > a ? 3e3 : 4320 > a ? 4320 : 1960 * Fv(a / 1960)) - a, 10 < a) { e.timeoutHandle = Ta(Gn.bind(null, e, ft, en), a); break } Gn(e, ft, en); break; case 5: Gn(e, ft, en); break; default: throw Error(o(329)) } } } return dt(e, je()), e.callbackNode === i ? Yd.bind(null, e) : null } function xl(e, t) { var i = Ti; return e.current.memoizedState.isDehydrated && (Kn(e, t).flags |= 256), e = qo(e, t), e !== 2 && (t = ft, ft = i, t !== null && wl(t)), e } function wl(e) { ft === null ? ft = e : ft.push.apply(ft, e) } function zv(e) { for (var t = e; ;) { if (t.flags & 16384) { var i = t.updateQueue; if (i !== null && (i = i.stores, i !== null)) for (var a = 0; a < i.length; a++) { var u = i[a], d = u.getSnapshot; u = u.value; try { if (!Mt(d(), u)) return !1 } catch { return !1 } } } if (i = t.child, t.subtreeFlags & 16384 && i !== null) i.return = t, t = i; else { if (t === e) break; for (; t.sibling === null;) { if (t.return === null || t.return === e) return !0; t = t.return } t.sibling.return = t.return, t = t.sibling } } return !0 } function En(e, t) { for (t &= ~ml, t &= ~Ko, e.suspendedLanes |= t, e.pingedLanes &= ~t, e = e.expirationTimes; 0 < t;) { var i = 31 - Rt(t), a = 1 << i; e[i] = -1, t &= ~a } } function Xd(e) { if ((me & 6) !== 0) throw Error(o(327)); Pr(); var t = oo(e, 0); if ((t & 1) === 0) return dt(e, je()), null; var i = qo(e, t); if (e.tag !== 0 && i === 2) { var a = qs(e); a !== 0 && (t = a, i = xl(e, a)) } if (i === 1) throw i = Ei, Kn(e, 0), En(e, t), dt(e, je()), i; if (i === 6) throw Error(o(345)); return e.finishedWork = e.current.alternate, e.finishedLanes = t, Gn(e, ft, en), dt(e, je()), null } function Sl(e, t) { var i = me; me |= 1; try { return e(t) } finally { me = i, me === 0 && (Tr = je() + 500, To && yn()) } } function Hn(e) { kn !== null && kn.tag === 0 && (me & 6) === 0 && Pr(); var t = me; me |= 1; var i = kt.transition, a = we; try { if (kt.transition = null, we = 1, e) return e() } finally { we = a, kt.transition = i, me = t, (me & 6) === 0 && yn() } } function kl() { yt = Er.current, Te(Er) } function Kn(e, t) { e.finishedWork = null, e.finishedLanes = 0; var i = e.timeoutHandle; if (i !== -1 && (e.timeoutHandle = -1, mv(i)), be !== null) for (i = be.return; i !== null;) { var a = i; switch (Na(a), a.tag) { case 1: a = a.type.childContextTypes, a != null && Co(); break; case 3: Sr(), Te(lt), Te(Je), Wa(); break; case 5: Ua(a); break; case 4: Sr(); break; case 13: Te(Re); break; case 19: Te(Re); break; case 10: Ia(a.type._context); break; case 22: case 23: kl() }i = i.return } if (Ge = e, be = e = Tn(e.current, null), Ze = yt = t, ze = 0, Ei = null, ml = Ko = Wn = 0, ft = Ti = null, Bn !== null) { for (t = 0; t < Bn.length; t++)if (i = Bn[t], a = i.interleaved, a !== null) { i.interleaved = null; var u = a.next, d = i.pending; if (d !== null) { var m = d.next; d.next = u, a.next = m } i.pending = a } Bn = null } return e } function Qd(e, t) { do { var i = be; try { if (ba(), _o.current = zo, bo) { for (var a = Me.memoizedState; a !== null;) { var u = a.queue; u !== null && (u.pending = null), a = a.next } bo = !1 } if ($n = 0, Ke = Fe = Me = null, vi = !1, xi = 0, pl.current = null, i === null || i.return === null) { ze = 1, Ei = t, be = null; break } e: { var d = e, m = i.return, w = i, S = t; if (t = Ze, w.flags |= 32768, S !== null && typeof S == "object" && typeof S.then == "function") { var D = S, z = w, B = z.tag; if ((z.mode & 1) === 0 && (B === 0 || B === 11 || B === 15)) { var F = z.alternate; F ? (z.updateQueue = F.updateQueue, z.memoizedState = F.memoizedState, z.lanes = F.lanes) : (z.updateQueue = null, z.memoizedState = null) } var K = Sd(m); if (K !== null) { K.flags &= -257, kd(K, m, w, d, t), K.mode & 1 && wd(d, D, t), t = K, S = D; var Y = t.updateQueue; if (Y === null) { var q = new Set; q.add(S), t.updateQueue = q } else Y.add(S); break e } else { if ((t & 1) === 0) { wd(d, D, t), Cl(); break e } S = Error(o(426)) } } else if (Pe && w.mode & 1) { var Ve = Sd(m); if (Ve !== null) { (Ve.flags & 65536) === 0 && (Ve.flags |= 256), kd(Ve, m, w, d, t), Va(kr(S, w)); break e } } d = S = kr(S, w), ze !== 4 && (ze = 2), Ti === null ? Ti = [d] : Ti.push(d), d = m; do { switch (d.tag) { case 3: d.flags |= 65536, t &= -t, d.lanes |= t; var R = vd(d, S, t); Hf(d, R); break e; case 1: w = S; var k = d.type, L = d.stateNode; if ((d.flags & 128) === 0 && (typeof k.getDerivedStateFromError == "function" || L !== null && typeof L.componentDidCatch == "function" && (Sn === null || !Sn.has(L)))) { d.flags |= 65536, t &= -t, d.lanes |= t; var $ = xd(d, w, t); Hf(d, $); break e } }d = d.return } while (d !== null) } Jd(i) } catch (te) { t = te, be === i && i !== null && (be = i = i.return); continue } break } while (!0) } function Zd() { var e = Ho.current; return Ho.current = zo, e === null ? zo : e } function Cl() { (ze === 0 || ze === 3 || ze === 2) && (ze = 4), Ge === null || (Wn & 268435455) === 0 && (Ko & 268435455) === 0 || En(Ge, Ze) } function qo(e, t) { var i = me; me |= 2; var a = Zd(); (Ge !== e || Ze !== t) && (en = null, Kn(e, t)); do try { Ov(); break } catch (u) { Qd(e, u) } while (!0); if (ba(), me = i, Ho.current = a, be !== null) throw Error(o(261)); return Ge = null, Ze = 0, ze } function Ov() { for (; be !== null;)qd(be) } function Bv() { for (; be !== null && !dy();)qd(be) } function qd(e) { var t = nh(e.alternate, e, yt); e.memoizedProps = e.pendingProps, t === null ? Jd(e) : be = t, pl.current = null } function Jd(e) { var t = e; do { var i = t.alternate; if (e = t.return, (t.flags & 32768) === 0) { if (i = jv(i, t, yt), i !== null) { be = i; return } } else { if (i = Vv(i, t), i !== null) { i.flags &= 32767, be = i; return } if (e !== null) e.flags |= 32768, e.subtreeFlags = 0, e.deletions = null; else { ze = 6, be = null; return } } if (t = t.sibling, t !== null) { be = t; return } be = t = e } while (t !== null); ze === 0 && (ze = 5) } function Gn(e, t, i) { var a = we, u = kt.transition; try { kt.transition = null, we = 1, Uv(e, t, i, a) } finally { kt.transition = u, we = a } return null } function Uv(e, t, i, a) { do Pr(); while (kn !== null); if ((me & 6) !== 0) throw Error(o(327)); i = e.finishedWork; var u = e.finishedLanes; if (i === null) return null; if (e.finishedWork = null, e.finishedLanes = 0, i === e.current) throw Error(o(177)); e.callbackNode = null, e.callbackPriority = 0; var d = i.lanes | i.childLanes; if (ky(e, d), e === Ge && (be = Ge = null, Ze = 0), (i.subtreeFlags & 2064) === 0 && (i.flags & 2064) === 0 || Yo || (Yo = !0, rh(to, function () { return Pr(), null })), d = (i.flags & 15990) !== 0, (i.subtreeFlags & 15990) !== 0 || d) { d = kt.transition, kt.transition = null; var m = we; we = 1; var w = me; me |= 4, pl.current = null, bv(e, i), $d(i, e), lv(Ca), lo = !!ka, Ca = ka = null, e.current = i, Iv(i), hy(), me = w, we = m, kt.transition = d } else e.current = i; if (Yo && (Yo = !1, kn = e, Xo = u), d = e.pendingLanes, d === 0 && (Sn = null), gy(i.stateNode), dt(e, je()), t !== null) for (a = e.onRecoverableError, i = 0; i < t.length; i++)u = t[i], a(u.value, { componentStack: u.stack, digest: u.digest }); if (Go) throw Go = !1, e = yl, yl = null, e; return (Xo & 1) !== 0 && e.tag !== 0 && Pr(), d = e.pendingLanes, (d & 1) !== 0 ? e === vl ? Pi++ : (Pi = 0, vl = e) : Pi = 0, yn(), null } function Pr() { if (kn !== null) { var e = Oc(Xo), t = kt.transition, i = we; try { if (kt.transition = null, we = 16 > e ? 16 : e, kn === null) var a = !1; else { if (e = kn, kn = null, Xo = 0, (me & 6) !== 0) throw Error(o(331)); var u = me; for (me |= 4, G = e.current; G !== null;) { var d = G, m = d.child; if ((G.flags & 16) !== 0) { var w = d.deletions; if (w !== null) { for (var S = 0; S < w.length; S++) { var D = w[S]; for (G = D; G !== null;) { var z = G; switch (z.tag) { case 0: case 11: case 15: Ci(8, z, d) }var B = z.child; if (B !== null) B.return = z, G = B; else for (; G !== null;) { z = G; var F = z.sibling, K = z.return; if (Fd(z), z === D) { G = null; break } if (F !== null) { F.return = K, G = F; break } G = K } } } var Y = d.alternate; if (Y !== null) { var q = Y.child; if (q !== null) { Y.child = null; do { var Ve = q.sibling; q.sibling = null, q = Ve } while (q !== null) } } G = d } } if ((d.subtreeFlags & 2064) !== 0 && m !== null) m.return = d, G = m; else e: for (; G !== null;) { if (d = G, (d.flags & 2048) !== 0) switch (d.tag) { case 0: case 11: case 15: Ci(9, d, d.return) }var R = d.sibling; if (R !== null) { R.return = d.return, G = R; break e } G = d.return } } var k = e.current; for (G = k; G !== null;) { m = G; var L = m.child; if ((m.subtreeFlags & 2064) !== 0 && L !== null) L.return = m, G = L; else e: for (m = k; G !== null;) { if (w = G, (w.flags & 2048) !== 0) try { switch (w.tag) { case 0: case 11: case 15: Wo(9, w) } } catch (te) { Ne(w, w.return, te) } if (w === m) { G = null; break e } var $ = w.sibling; if ($ !== null) { $.return = w.return, G = $; break e } G = w.return } } if (me = u, yn(), Ft && typeof Ft.onPostCommitFiberRoot == "function") try { Ft.onPostCommitFiberRoot(no, e) } catch { } a = !0 } return a } finally { we = i, kt.transition = t } } return !1 } function eh(e, t, i) { t = kr(i, t), t = vd(e, t, 1), e = xn(e, t, 1), t = ot(), e !== null && (Qr(e, 1, t), dt(e, t)) } function Ne(e, t, i) { if (e.tag === 3) eh(e, e, i); else for (; t !== null;) { if (t.tag === 3) { eh(t, e, i); break } else if (t.tag === 1) { var a = t.stateNode; if (typeof t.type.getDerivedStateFromError == "function" || typeof a.componentDidCatch == "function" && (Sn === null || !Sn.has(a))) { e = kr(i, e), e = xd(t, e, 1), t = xn(t, e, 1), e = ot(), t !== null && (Qr(t, 1, e), dt(t, e)); break } } t = t.return } } function $v(e, t, i) { var a = e.pingCache; a !== null && a.delete(t), t = ot(), e.pingedLanes |= e.suspendedLanes & i, Ge === e && (Ze & i) === i && (ze === 4 || ze === 3 && (Ze & 130023424) === Ze && 500 > je() - gl ? Kn(e, 0) : ml |= i), dt(e, t) } function th(e, t) { t === 0 && ((e.mode & 1) === 0 ? t = 1 : (t = io, io <<= 1, (io & 130023424) === 0 && (io = 4194304))); var i = ot(); e = Zt(e, t), e !== null && (Qr(e, t, i), dt(e, i)) } function Wv(e) { var t = e.memoizedState, i = 0; t !== null && (i = t.retryLane), th(e, i) } function Hv(e, t) { var i = 0; switch (e.tag) { case 13: var a = e.stateNode, u = e.memoizedState; u !== null && (i = u.retryLane); break; case 19: a = e.stateNode; break; default: throw Error(o(314)) }a !== null && a.delete(t), th(e, i) } var nh; nh = function (e, t, i) { if (e !== null) if (e.memoizedProps !== t.pendingProps || lt.current) ct = !0; else { if ((e.lanes & i) === 0 && (t.flags & 128) === 0) return ct = !1, Dv(e, t, i); ct = (e.flags & 131072) !== 0 } else ct = !1, Pe && (t.flags & 1048576) !== 0 && _f(t, Ro, t.index); switch (t.lanes = 0, t.tag) { case 2: var a = t.type; Uo(e, t), e = t.pendingProps; var u = pr(t, Je.current); wr(t, i), u = Ga(null, t, a, e, u, i); var d = Ya(); return t.flags |= 1, typeof u == "object" && u !== null && typeof u.render == "function" && u.$$typeof === void 0 ? (t.tag = 1, t.memoizedState = null, t.updateQueue = null, ut(a) ? (d = !0, Eo(t)) : d = !1, t.memoizedState = u.state !== null && u.state !== void 0 ? u.state : null, Oa(t), u.updater = Oo, t.stateNode = u, u._reactInternals = t, el(t, a, e, i), t = il(null, t, a, !0, d, i)) : (t.tag = 0, Pe && d && La(t), it(null, t, u, i), t = t.child), t; case 16: a = t.elementType; e: { switch (Uo(e, t), e = t.pendingProps, u = a._init, a = u(a._payload), t.type = a, u = t.tag = Gv(a), e = Lt(a, e), u) { case 0: t = rl(null, t, a, e, i); break e; case 1: t = Md(null, t, a, e, i); break e; case 11: t = Cd(null, t, a, e, i); break e; case 14: t = Ed(null, t, a, Lt(a.type, e), i); break e }throw Error(o(306, a, "")) } return t; case 0: return a = t.type, u = t.pendingProps, u = t.elementType === a ? u : Lt(a, u), rl(e, t, a, u, i); case 1: return a = t.type, u = t.pendingProps, u = t.elementType === a ? u : Lt(a, u), Md(e, t, a, u, i); case 3: e: { if (Ad(t), e === null) throw Error(o(387)); a = t.pendingProps, d = t.memoizedState, u = d.element, Wf(e, t), jo(t, a, null, i); var m = t.memoizedState; if (a = m.element, d.isDehydrated) if (d = { element: a, isDehydrated: !1, cache: m.cache, pendingSuspenseBoundaries: m.pendingSuspenseBoundaries, transitions: m.transitions }, t.updateQueue.baseState = d, t.memoizedState = d, t.flags & 256) { u = kr(Error(o(423)), t), t = Ld(e, t, a, i, u); break e } else if (a !== u) { u = kr(Error(o(424)), t), t = Ld(e, t, a, i, u); break e } else for (gt = pn(t.stateNode.containerInfo.firstChild), mt = t, Pe = !0, At = null, i = Uf(t, null, a, i), t.child = i; i;)i.flags = i.flags & -3 | 4096, i = i.sibling; else { if (yr(), a === u) { t = Jt(e, t, i); break e } it(e, t, a, i) } t = t.child } return t; case 5: return Gf(t), e === null && ja(t), a = t.type, u = t.pendingProps, d = e !== null ? e.memoizedProps : null, m = u.children, Ea(a, u) ? m = null : d !== null && Ea(a, d) && (t.flags |= 32), Rd(e, t), it(e, t, m, i), t.child; case 6: return e === null && ja(t), null; case 13: return Nd(e, t, i); case 4: return Ba(t, t.stateNode.containerInfo), a = t.pendingProps, e === null ? t.child = vr(t, null, a, i) : it(e, t, a, i), t.child; case 11: return a = t.type, u = t.pendingProps, u = t.elementType === a ? u : Lt(a, u), Cd(e, t, a, u, i); case 7: return it(e, t, t.pendingProps, i), t.child; case 8: return it(e, t, t.pendingProps.children, i), t.child; case 12: return it(e, t, t.pendingProps.children, i), t.child; case 10: e: { if (a = t.type._context, u = t.pendingProps, d = t.memoizedProps, m = u.value, Se(Lo, a._currentValue), a._currentValue = m, d !== null) if (Mt(d.value, m)) { if (d.children === u.children && !lt.current) { t = Jt(e, t, i); break e } } else for (d = t.child, d !== null && (d.return = t); d !== null;) { var w = d.dependencies; if (w !== null) { m = d.child; for (var S = w.firstContext; S !== null;) { if (S.context === a) { if (d.tag === 1) { S = qt(-1, i & -i), S.tag = 2; var D = d.updateQueue; if (D !== null) { D = D.shared; var z = D.pending; z === null ? S.next = S : (S.next = z.next, z.next = S), D.pending = S } } d.lanes |= i, S = d.alternate, S !== null && (S.lanes |= i), Fa(d.return, i, t), w.lanes |= i; break } S = S.next } } else if (d.tag === 10) m = d.type === t.type ? null : d.child; else if (d.tag === 18) { if (m = d.return, m === null) throw Error(o(341)); m.lanes |= i, w = m.alternate, w !== null && (w.lanes |= i), Fa(m, i, t), m = d.sibling } else m = d.child; if (m !== null) m.return = d; else for (m = d; m !== null;) { if (m === t) { m = null; break } if (d = m.sibling, d !== null) { d.return = m.return, m = d; break } m = m.return } d = m } it(e, t, u.children, i), t = t.child } return t; case 9: return u = t.type, a = t.pendingProps.children, wr(t, i), u = wt(u), a = a(u), t.flags |= 1, it(e, t, a, i), t.child; case 14: return a = t.type, u = Lt(a, t.pendingProps), u = Lt(a.type, u), Ed(e, t, a, u, i); case 15: return Td(e, t, t.type, t.pendingProps, i); case 17: return a = t.type, u = t.pendingProps, u = t.elementType === a ? u : Lt(a, u), Uo(e, t), t.tag = 1, ut(a) ? (e = !0, Eo(t)) : e = !1, wr(t, i), gd(t, a, u), el(t, a, u, i), il(null, t, a, !0, e, i); case 19: return jd(e, t, i); case 22: return Pd(e, t, i) }throw Error(o(156, t.tag)) }; function rh(e, t) { return _c(e, t) } function Kv(e, t, i, a) { this.tag = e, this.key = i, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = t, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = a, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null } function Ct(e, t, i, a) { return new Kv(e, t, i, a) } function El(e) { return e = e.prototype, !(!e || !e.isReactComponent) } function Gv(e) { if (typeof e == "function") return El(e) ? 1 : 0; if (e != null) { if (e = e.$$typeof, e === Ue) return 11; if (e === _e) return 14 } return 2 } function Tn(e, t) { var i = e.alternate; return i === null ? (i = Ct(e.tag, t, e.key, e.mode), i.elementType = e.elementType, i.type = e.type, i.stateNode = e.stateNode, i.alternate = e, e.alternate = i) : (i.pendingProps = t, i.type = e.type, i.flags = 0, i.subtreeFlags = 0, i.deletions = null), i.flags = e.flags & 14680064, i.childLanes = e.childLanes, i.lanes = e.lanes, i.child = e.child, i.memoizedProps = e.memoizedProps, i.memoizedState = e.memoizedState, i.updateQueue = e.updateQueue, t = e.dependencies, i.dependencies = t === null ? null : { lanes: t.lanes, firstContext: t.firstContext }, i.sibling = e.sibling, i.index = e.index, i.ref = e.ref, i } function Jo(e, t, i, a, u, d) { var m = 2; if (a = e, typeof e == "function") El(e) && (m = 1); else if (typeof e == "string") m = 5; else e: switch (e) { case se: return Yn(i.children, u, d, t); case O: m = 8, u |= 8; break; case ce: return e = Ct(12, i, t, u | 2), e.elementType = ce, e.lanes = d, e; case $e: return e = Ct(13, i, t, u), e.elementType = $e, e.lanes = d, e; case We: return e = Ct(19, i, t, u), e.elementType = We, e.lanes = d, e; case ae: return es(i, u, d, t); default: if (typeof e == "object" && e !== null) switch (e.$$typeof) { case ve: m = 10; break e; case Xe: m = 9; break e; case Ue: m = 11; break e; case _e: m = 14; break e; case Ce: m = 16, a = null; break e }throw Error(o(130, e == null ? e : typeof e, "")) }return t = Ct(m, i, t, u), t.elementType = e, t.type = a, t.lanes = d, t } function Yn(e, t, i, a) { return e = Ct(7, e, a, t), e.lanes = i, e } function es(e, t, i, a) { return e = Ct(22, e, a, t), e.elementType = ae, e.lanes = i, e.stateNode = { isHidden: !1 }, e } function Tl(e, t, i) { return e = Ct(6, e, null, t), e.lanes = i, e } function Pl(e, t, i) { return t = Ct(4, e.children !== null ? e.children : [], e.key, t), t.lanes = i, t.stateNode = { containerInfo: e.containerInfo, pendingChildren: null, implementation: e.implementation }, t } function Yv(e, t, i, a, u) { this.tag = t, this.containerInfo = e, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = Js(0), this.expirationTimes = Js(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = Js(0), this.identifierPrefix = a, this.onRecoverableError = u, this.mutableSourceEagerHydrationData = null } function Rl(e, t, i, a, u, d, m, w, S) { return e = new Yv(e, t, i, w, S), t === 1 ? (t = 1, d === !0 && (t |= 8)) : t = 0, d = Ct(3, null, null, t), e.current = d, d.stateNode = e, d.memoizedState = { element: a, isDehydrated: i, cache: null, transitions: null, pendingSuspenseBoundaries: null }, Oa(d), e } function Xv(e, t, i) { var a = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null; return { $$typeof: J, key: a == null ? null : "" + a, children: e, containerInfo: t, implementation: i } } function ih(e) { if (!e) return gn; e = e._reactInternals; e: { if (bn(e) !== e || e.tag !== 1) throw Error(o(170)); var t = e; do { switch (t.tag) { case 3: t = t.stateNode.context; break e; case 1: if (ut(t.type)) { t = t.stateNode.__reactInternalMemoizedMergedChildContext; break e } }t = t.return } while (t !== null); throw Error(o(171)) } if (e.tag === 1) { var i = e.type; if (ut(i)) return Df(e, i, t) } return t } function oh(e, t, i, a, u, d, m, w, S) { return e = Rl(i, a, !0, e, u, d, m, w, S), e.context = ih(null), i = e.current, a = ot(), u = Cn(i), d = qt(a, u), d.callback = t ?? null, xn(i, d, u), e.current.lanes = u, Qr(e, u, a), dt(e, a), e } function ts(e, t, i, a) { var u = t.current, d = ot(), m = Cn(u); return i = ih(i), t.context === null ? t.context = i : t.pendingContext = i, t = qt(d, m), t.payload = { element: e }, a = a === void 0 ? null : a, a !== null && (t.callback = a), e = xn(u, t, m), e !== null && (jt(e, u, m, d), Do(e, u, m)), m } function ns(e) { if (e = e.current, !e.child) return null; switch (e.child.tag) { case 5: return e.child.stateNode; default: return e.child.stateNode } } function sh(e, t) { if (e = e.memoizedState, e !== null && e.dehydrated !== null) { var i = e.retryLane; e.retryLane = i !== 0 && i < t ? i : t } } function Ml(e, t) { sh(e, t), (e = e.alternate) && sh(e, t) } function Qv() { return null } var ah = typeof reportError == "function" ? reportError : function (e) { console.error(e) }; function Al(e) { this._internalRoot = e } rs.prototype.render = Al.prototype.render = function (e) { var t = this._internalRoot; if (t === null) throw Error(o(409)); ts(e, t, null, null) }, rs.prototype.unmount = Al.prototype.unmount = function () { var e = this._internalRoot; if (e !== null) { this._internalRoot = null; var t = e.containerInfo; Hn(function () { ts(null, e, null, null) }), t[Gt] = null } }; function rs(e) { this._internalRoot = e } rs.prototype.unstable_scheduleHydration = function (e) { if (e) { var t = $c(); e = { blockedOn: null, target: e, priority: t }; for (var i = 0; i < fn.length && t !== 0 && t < fn[i].priority; i++); fn.splice(i, 0, e), i === 0 && Kc(e) } }; function Ll(e) { return !(!e || e.nodeType !== 1 && e.nodeType !== 9 && e.nodeType !== 11) } function is(e) { return !(!e || e.nodeType !== 1 && e.nodeType !== 9 && e.nodeType !== 11 && (e.nodeType !== 8 || e.nodeValue !== " react-mount-point-unstable ")) } function lh() { } function Zv(e, t, i, a, u) { if (u) { if (typeof a == "function") { var d = a; a = function () { var D = ns(m); d.call(D) } } var m = oh(t, a, e, 0, null, !1, !1, "", lh); return e._reactRootContainer = m, e[Gt] = m.current, ci(e.nodeType === 8 ? e.parentNode : e), Hn(), m } for (; u = e.lastChild;)e.removeChild(u); if (typeof a == "function") { var w = a; a = function () { var D = ns(S); w.call(D) } } var S = Rl(e, 0, !1, null, null, !1, !1, "", lh); return e._reactRootContainer = S, e[Gt] = S.current, ci(e.nodeType === 8 ? e.parentNode : e), Hn(function () { ts(t, S, i, a) }), S } function os(e, t, i, a, u) { var d = i._reactRootContainer; if (d) { var m = d; if (typeof u == "function") { var w = u; u = function () { var S = ns(m); w.call(S) } } ts(t, m, e, u) } else m = Zv(i, t, e, u, a); return ns(m) } Bc = function (e) { switch (e.tag) { case 3: var t = e.stateNode; if (t.current.memoizedState.isDehydrated) { var i = Xr(t.pendingLanes); i !== 0 && (ea(t, i | 1), dt(t, je()), (me & 6) === 0 && (Tr = je() + 500, yn())) } break; case 13: Hn(function () { var a = Zt(e, 1); if (a !== null) { var u = ot(); jt(a, e, 1, u) } }), Ml(e, 1) } }, ta = function (e) { if (e.tag === 13) { var t = Zt(e, 134217728); if (t !== null) { var i = ot(); jt(t, e, 134217728, i) } Ml(e, 134217728) } }, Uc = function (e) { if (e.tag === 13) { var t = Cn(e), i = Zt(e, t); if (i !== null) { var a = ot(); jt(i, e, t, a) } Ml(e, t) } }, $c = function () { return we }, Wc = function (e, t) { var i = we; try { return we = e, t() } finally { we = i } }, Gs = function (e, t, i) { switch (t) { case "input": if (zs(e, i), t = i.name, i.type === "radio" && t != null) { for (i = e; i.parentNode;)i = i.parentNode; for (i = i.querySelectorAll("input[name=" + JSON.stringify("" + t) + '][type="radio"]'), t = 0; t < i.length; t++) { var a = i[t]; if (a !== e && a.form === e.form) { var u = ko(a); if (!u) throw Error(o(90)); _n(a), zs(a, u) } } } break; case "textarea": xc(e, i); break; case "select": t = i.value, t != null && nr(e, !!i.multiple, t, !1) } }, Mc = Sl, Ac = Hn; var qv = { usingClientEntryPoint: !1, Events: [hi, dr, ko, Pc, Rc, Sl] }, Ri = { findFiberByHostInstance: In, bundleType: 0, version: "18.3.1", rendererPackageName: "react-dom" }, Jv = { bundleType: Ri.bundleType, version: Ri.version, rendererPackageName: Ri.rendererPackageName, rendererConfig: Ri.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: W.ReactCurrentDispatcher, findHostInstanceByFiber: function (e) { return e = jc(e), e === null ? null : e.stateNode }, findFiberByHostInstance: Ri.findFiberByHostInstance || Qv, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.3.1-next-f1338f8080-20240426" }; if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") { var ss = __REACT_DEVTOOLS_GLOBAL_HOOK__; if (!ss.isDisabled && ss.supportsFiber) try { no = ss.inject(Jv), Ft = ss } catch { } } return ht.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = qv, ht.createPortal = function (e, t) { var i = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null; if (!Ll(t)) throw Error(o(200)); return Xv(e, t, null, i) }, ht.createRoot = function (e, t) { if (!Ll(e)) throw Error(o(299)); var i = !1, a = "", u = ah; return t != null && (t.unstable_strictMode === !0 && (i = !0), t.identifierPrefix !== void 0 && (a = t.identifierPrefix), t.onRecoverableError !== void 0 && (u = t.onRecoverableError)), t = Rl(e, 1, !1, null, null, i, !1, a, u), e[Gt] = t.current, ci(e.nodeType === 8 ? e.parentNode : e), new Al(t) }, ht.findDOMNode = function (e) { if (e == null) return null; if (e.nodeType === 1) return e; var t = e._reactInternals; if (t === void 0) throw typeof e.render == "function" ? Error(o(188)) : (e = Object.keys(e).join(","), Error(o(268, e))); return e = jc(t), e = e === null ? null : e.stateNode, e }, ht.flushSync = function (e) { return Hn(e) }, ht.hydrate = function (e, t, i) { if (!is(t)) throw Error(o(200)); return os(null, e, t, !0, i) }, ht.hydrateRoot = function (e, t, i) { if (!Ll(e)) throw Error(o(405)); var a = i != null && i.hydratedSources || null, u = !1, d = "", m = ah; if (i != null && (i.unstable_strictMode === !0 && (u = !0), i.identifierPrefix !== void 0 && (d = i.identifierPrefix), i.onRecoverableError !== void 0 && (m = i.onRecoverableError)), t = oh(t, null, e, 1, i ?? null, u, !1, d, m), e[Gt] = t.current, ci(e), a) for (e = 0; e < a.length; e++)i = a[e], u = i._getVersion, u = u(i._source), t.mutableSourceEagerHydrationData == null ? t.mutableSourceEagerHydrationData = [i, u] : t.mutableSourceEagerHydrationData.push(i, u); return new rs(t) }, ht.render = function (e, t, i) { if (!is(t)) throw Error(o(200)); return os(null, e, t, !1, i) }, ht.unmountComponentAtNode = function (e) { if (!is(e)) throw Error(o(40)); return e._reactRootContainer ? (Hn(function () { os(null, null, e, !1, function () { e._reactRootContainer = null, e[Gt] = null }) }), !0) : !1 }, ht.unstable_batchedUpdates = Sl, ht.unstable_renderSubtreeIntoContainer = function (e, t, i, a) { if (!is(i)) throw Error(o(200)); if (e == null || e._reactInternals === void 0) throw Error(o(38)); return os(e, t, i, !1, a) }, ht.version = "18.3.1-next-f1338f8080-20240426", ht
} var gh; function a0() { if (gh) return jl.exports; gh = 1; function n() { if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) try { __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(n) } catch (r) { console.error(r) } } return n(), jl.exports = s0(), jl.exports } var yh; function l0() { if (yh) return as; yh = 1; var n = a0(); return as.createRoot = n.createRoot, as.hydrateRoot = n.hydrateRoot, as } var u0 = l0(), P = Du();/**
 * react-router v7.13.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */var vh = "popstate"; function c0(n = {}) { function r(s, l) { let { pathname: f, search: c, hash: h } = s.location; return iu("", { pathname: f, search: c, hash: h }, l.state && l.state.usr || null, l.state && l.state.key || "default") } function o(s, l) { return typeof l == "string" ? l : Ii(l) } return d0(r, o, null, n) } function Le(n, r) { if (n === !1 || n === null || typeof n > "u") throw new Error(r) } function Ht(n, r) { if (!n) { typeof console < "u" && console.warn(r); try { throw new Error(r) } catch { } } } function f0() { return Math.random().toString(36).substring(2, 10) } function xh(n, r) { return { usr: n.state, key: n.key, idx: r } } function iu(n, r, o = null, s) { return { pathname: typeof n == "string" ? n : n.pathname, search: "", hash: "", ...typeof r == "string" ? br(r) : r, state: o, key: r && r.key || s || f0() } } function Ii({ pathname: n = "/", search: r = "", hash: o = "" }) { return r && r !== "?" && (n += r.charAt(0) === "?" ? r : "?" + r), o && o !== "#" && (n += o.charAt(0) === "#" ? o : "#" + o), n } function br(n) { let r = {}; if (n) { let o = n.indexOf("#"); o >= 0 && (r.hash = n.substring(o), n = n.substring(0, o)); let s = n.indexOf("?"); s >= 0 && (r.search = n.substring(s), n = n.substring(0, s)), n && (r.pathname = n) } return r } function d0(n, r, o, s = {}) { let { window: l = document.defaultView, v5Compat: f = !1 } = s, c = l.history, h = "POP", p = null, g = y(); g == null && (g = 0, c.replaceState({ ...c.state, idx: g }, "")); function y() { return (c.state || { idx: null }).idx } function v() { h = "POP"; let A = y(), V = A == null ? null : A - g; g = A, p && p({ action: h, location: N.location, delta: V }) } function x(A, V) { h = "PUSH"; let b = iu(N.location, A, V); g = y() + 1; let j = xh(b, g), W = N.createHref(b); try { c.pushState(j, "", W) } catch (U) { if (U instanceof DOMException && U.name === "DataCloneError") throw U; l.location.assign(W) } f && p && p({ action: h, location: N.location, delta: 1 }) } function C(A, V) { h = "REPLACE"; let b = iu(N.location, A, V); g = y(); let j = xh(b, g), W = N.createHref(b); c.replaceState(j, "", W), f && p && p({ action: h, location: N.location, delta: 0 }) } function M(A) { return h0(A) } let N = { get action() { return h }, get location() { return n(l, c) }, listen(A) { if (p) throw new Error("A history only accepts one active listener"); return l.addEventListener(vh, v), p = A, () => { l.removeEventListener(vh, v), p = null } }, createHref(A) { return r(l, A) }, createURL: M, encodeLocation(A) { let V = M(A); return { pathname: V.pathname, search: V.search, hash: V.hash } }, push: x, replace: C, go(A) { return c.go(A) } }; return N } function h0(n, r = !1) { let o = "http://localhost"; typeof window < "u" && (o = window.location.origin !== "null" ? window.location.origin : window.location.href), Le(o, "No window.location.(origin|href) available to create URL"); let s = typeof n == "string" ? n : Ii(n); return s = s.replace(/ $/, "%20"), !r && s.startsWith("//") && (s = o + s), new URL(s, o) } function $p(n, r, o = "/") { return p0(n, r, o, !1) } function p0(n, r, o, s) { let l = typeof r == "string" ? br(r) : r, f = rn(l.pathname || "/", o); if (f == null) return null; let c = Wp(n); m0(c); let h = null; for (let p = 0; h == null && p < c.length; ++p) { let g = P0(f); h = E0(c[p], g, s) } return h } function Wp(n, r = [], o = [], s = "", l = !1) { let f = (c, h, p = l, g) => { let y = { relativePath: g === void 0 ? c.path || "" : g, caseSensitive: c.caseSensitive === !0, childrenIndex: h, route: c }; if (y.relativePath.startsWith("/")) { if (!y.relativePath.startsWith(s) && p) return; Le(y.relativePath.startsWith(s), `Absolute route path "${y.relativePath}" nested under path "${s}" is not valid. An absolute child route path must start with the combined path of all its parent routes.`), y.relativePath = y.relativePath.slice(s.length) } let v = nn([s, y.relativePath]), x = o.concat(y); c.children && c.children.length > 0 && (Le(c.index !== !0, `Index routes must not have child routes. Please remove all child routes from route path "${v}".`), Wp(c.children, r, x, v, p)), !(c.path == null && !c.index) && r.push({ path: v, score: k0(v, c.index), routesMeta: x }) }; return n.forEach((c, h) => { var p; if (c.path === "" || !((p = c.path) != null && p.includes("?"))) f(c, h); else for (let g of Hp(c.path)) f(c, h, !0, g) }), r } function Hp(n) { let r = n.split("/"); if (r.length === 0) return []; let [o, ...s] = r, l = o.endsWith("?"), f = o.replace(/\?$/, ""); if (s.length === 0) return l ? [f, ""] : [f]; let c = Hp(s.join("/")), h = []; return h.push(...c.map(p => p === "" ? f : [f, p].join("/"))), l && h.push(...c), h.map(p => n.startsWith("/") && p === "" ? "/" : p) } function m0(n) { n.sort((r, o) => r.score !== o.score ? o.score - r.score : C0(r.routesMeta.map(s => s.childrenIndex), o.routesMeta.map(s => s.childrenIndex))) } var g0 = /^:[\w-]+$/, y0 = 3, v0 = 2, x0 = 1, w0 = 10, S0 = -2, wh = n => n === "*"; function k0(n, r) { let o = n.split("/"), s = o.length; return o.some(wh) && (s += S0), r && (s += v0), o.filter(l => !wh(l)).reduce((l, f) => l + (g0.test(f) ? y0 : f === "" ? x0 : w0), s) } function C0(n, r) { return n.length === r.length && n.slice(0, -1).every((s, l) => s === r[l]) ? n[n.length - 1] - r[r.length - 1] : 0 } function E0(n, r, o = !1) { let { routesMeta: s } = n, l = {}, f = "/", c = []; for (let h = 0; h < s.length; ++h) { let p = s[h], g = h === s.length - 1, y = f === "/" ? r : r.slice(f.length) || "/", v = ks({ path: p.relativePath, caseSensitive: p.caseSensitive, end: g }, y), x = p.route; if (!v && g && o && !s[s.length - 1].route.index && (v = ks({ path: p.relativePath, caseSensitive: p.caseSensitive, end: !1 }, y)), !v) return null; Object.assign(l, v.params), c.push({ params: l, pathname: nn([f, v.pathname]), pathnameBase: L0(nn([f, v.pathnameBase])), route: x }), v.pathnameBase !== "/" && (f = nn([f, v.pathnameBase])) } return c } function ks(n, r) { typeof n == "string" && (n = { path: n, caseSensitive: !1, end: !0 }); let [o, s] = T0(n.path, n.caseSensitive, n.end), l = r.match(o); if (!l) return null; let f = l[0], c = f.replace(/(.)\/+$/, "$1"), h = l.slice(1); return { params: s.reduce((g, { paramName: y, isOptional: v }, x) => { if (y === "*") { let M = h[x] || ""; c = f.slice(0, f.length - M.length).replace(/(.)\/+$/, "$1") } const C = h[x]; return v && !C ? g[y] = void 0 : g[y] = (C || "").replace(/%2F/g, "/"), g }, {}), pathname: f, pathnameBase: c, pattern: n } } function T0(n, r = !1, o = !0) { Ht(n === "*" || !n.endsWith("*") || n.endsWith("/*"), `Route path "${n}" will be treated as if it were "${n.replace(/\*$/, "/*")}" because the \`*\` character must always follow a \`/\` in the pattern. To get rid of this warning, please change the route path to "${n.replace(/\*$/, "/*")}".`); let s = [], l = "^" + n.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(/\/:([\w-]+)(\?)?/g, (c, h, p) => (s.push({ paramName: h, isOptional: p != null }), p ? "/?([^\\/]+)?" : "/([^\\/]+)")).replace(/\/([\w-]+)\?(\/|$)/g, "(/$1)?$2"); return n.endsWith("*") ? (s.push({ paramName: "*" }), l += n === "*" || n === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$") : o ? l += "\\/*$" : n !== "" && n !== "/" && (l += "(?:(?=\\/|$))"), [new RegExp(l, r ? void 0 : "i"), s] } function P0(n) { try { return n.split("/").map(r => decodeURIComponent(r).replace(/\//g, "%2F")).join("/") } catch (r) { return Ht(!1, `The URL path "${n}" could not be decoded because it is a malformed URL segment. This is probably due to a bad percent encoding (${r}).`), n } } function rn(n, r) { if (r === "/") return n; if (!n.toLowerCase().startsWith(r.toLowerCase())) return null; let o = r.endsWith("/") ? r.length - 1 : r.length, s = n.charAt(o); return s && s !== "/" ? null : n.slice(o) || "/" } var R0 = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i; function M0(n, r = "/") { let { pathname: o, search: s = "", hash: l = "" } = typeof n == "string" ? br(n) : n, f; return o ? (o = o.replace(/\/\/+/g, "/"), o.startsWith("/") ? f = Sh(o.substring(1), "/") : f = Sh(o, r)) : f = r, { pathname: f, search: N0(s), hash: D0(l) } } function Sh(n, r) { let o = r.replace(/\/+$/, "").split("/"); return n.split("/").forEach(l => { l === ".." ? o.length > 1 && o.pop() : l !== "." && o.push(l) }), o.length > 1 ? o.join("/") : "/" } function bl(n, r, o, s) { return `Cannot include a '${n}' character in a manually specified \`to.${r}\` field [${JSON.stringify(s)}].  Please separate it out to the \`to.${o}\` field. Alternatively you may provide the full path as a string in <Link to="..."> and the router will parse it for you.` } function A0(n) { return n.filter((r, o) => o === 0 || r.route.path && r.route.path.length > 0) } function Kp(n) { let r = A0(n); return r.map((o, s) => s === r.length - 1 ? o.pathname : o.pathnameBase) } function Gp(n, r, o, s = !1) { let l; typeof n == "string" ? l = br(n) : (l = { ...n }, Le(!l.pathname || !l.pathname.includes("?"), bl("?", "pathname", "search", l)), Le(!l.pathname || !l.pathname.includes("#"), bl("#", "pathname", "hash", l)), Le(!l.search || !l.search.includes("#"), bl("#", "search", "hash", l))); let f = n === "" || l.pathname === "", c = f ? "/" : l.pathname, h; if (c == null) h = o; else { let v = r.length - 1; if (!s && c.startsWith("..")) { let x = c.split("/"); for (; x[0] === "..";)x.shift(), v -= 1; l.pathname = x.join("/") } h = v >= 0 ? r[v] : "/" } let p = M0(l, h), g = c && c !== "/" && c.endsWith("/"), y = (f || c === ".") && o.endsWith("/"); return !p.pathname.endsWith("/") && (g || y) && (p.pathname += "/"), p } var nn = n => n.join("/").replace(/\/\/+/g, "/"), L0 = n => n.replace(/\/+$/, "").replace(/^\/*/, "/"), N0 = n => !n || n === "?" ? "" : n.startsWith("?") ? n : "?" + n, D0 = n => !n || n === "#" ? "" : n.startsWith("#") ? n : "#" + n, j0 = class { constructor(n, r, o, s = !1) { this.status = n, this.statusText = r || "", this.internal = s, o instanceof Error ? (this.data = o.toString(), this.error = o) : this.data = o } }; function V0(n) { return n != null && typeof n.status == "number" && typeof n.statusText == "string" && typeof n.internal == "boolean" && "data" in n } function _0(n) { return n.map(r => r.route.path).filter(Boolean).join("/").replace(/\/\/*/g, "/") || "/" } var Yp = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u"; function Xp(n, r) { let o = n; if (typeof o != "string" || !R0.test(o)) return { absoluteURL: void 0, isExternal: !1, to: o }; let s = o, l = !1; if (Yp) try { let f = new URL(window.location.href), c = o.startsWith("//") ? new URL(f.protocol + o) : new URL(o), h = rn(c.pathname, r); c.origin === f.origin && h != null ? o = h + c.search + c.hash : l = !0 } catch { Ht(!1, `<Link to="${o}"> contains an invalid URL which will probably break when clicked - please update to a valid URL path.`) } return { absoluteURL: s, isExternal: l, to: o } } Object.getOwnPropertyNames(Object.prototype).sort().join("\0"); var Qp = ["POST", "PUT", "PATCH", "DELETE"]; new Set(Qp); var b0 = ["GET", ...Qp]; new Set(b0); var Ir = P.createContext(null); Ir.displayName = "DataRouter"; var Ds = P.createContext(null); Ds.displayName = "DataRouterState"; var I0 = P.createContext(!1), Zp = P.createContext({ isTransitioning: !1 }); Zp.displayName = "ViewTransition"; var F0 = P.createContext(new Map); F0.displayName = "Fetchers"; var z0 = P.createContext(null); z0.displayName = "Await"; var Pt = P.createContext(null); Pt.displayName = "Navigation"; var Wi = P.createContext(null); Wi.displayName = "Location"; var sn = P.createContext({ outlet: null, matches: [], isDataRoute: !1 }); sn.displayName = "Route"; var ju = P.createContext(null); ju.displayName = "RouteError"; var qp = "REACT_ROUTER_ERROR", O0 = "REDIRECT", B0 = "ROUTE_ERROR_RESPONSE"; function U0(n) { if (n.startsWith(`${qp}:${O0}:{`)) try { let r = JSON.parse(n.slice(28)); if (typeof r == "object" && r && typeof r.status == "number" && typeof r.statusText == "string" && typeof r.location == "string" && typeof r.reloadDocument == "boolean" && typeof r.replace == "boolean") return r } catch { } } function $0(n) { if (n.startsWith(`${qp}:${B0}:{`)) try { let r = JSON.parse(n.slice(40)); if (typeof r == "object" && r && typeof r.status == "number" && typeof r.statusText == "string") return new j0(r.status, r.statusText, r.data) } catch { } } function W0(n, { relative: r } = {}) { Le(Hi(), "useHref() may be used only in the context of a <Router> component."); let { basename: o, navigator: s } = P.useContext(Pt), { hash: l, pathname: f, search: c } = Ki(n, { relative: r }), h = f; return o !== "/" && (h = f === "/" ? o : nn([o, f])), s.createHref({ pathname: h, search: c, hash: l }) } function Hi() { return P.useContext(Wi) != null } function tr() { return Le(Hi(), "useLocation() may be used only in the context of a <Router> component."), P.useContext(Wi).location } var Jp = "You should call navigate() in a React.useEffect(), not when your component is first rendered."; function em(n) { P.useContext(Pt).static || P.useLayoutEffect(n) } function H0() { let { isDataRoute: n } = P.useContext(sn); return n ? ix() : K0() } function K0() { Le(Hi(), "useNavigate() may be used only in the context of a <Router> component."); let n = P.useContext(Ir), { basename: r, navigator: o } = P.useContext(Pt), { matches: s } = P.useContext(sn), { pathname: l } = tr(), f = JSON.stringify(Kp(s)), c = P.useRef(!1); return em(() => { c.current = !0 }), P.useCallback((p, g = {}) => { if (Ht(c.current, Jp), !c.current) return; if (typeof p == "number") { o.go(p); return } let y = Gp(p, JSON.parse(f), l, g.relative === "path"); n == null && r !== "/" && (y.pathname = y.pathname === "/" ? r : nn([r, y.pathname])), (g.replace ? o.replace : o.push)(y, g.state, g) }, [r, o, f, l, n]) } P.createContext(null); function Ki(n, { relative: r } = {}) { let { matches: o } = P.useContext(sn), { pathname: s } = tr(), l = JSON.stringify(Kp(o)); return P.useMemo(() => Gp(n, JSON.parse(l), s, r === "path"), [n, l, s, r]) } function G0(n, r) { return tm(n, r) } function tm(n, r, o, s, l) {
    var b; Le(Hi(), "useRoutes() may be used only in the context of a <Router> component."); let { navigator: f } = P.useContext(Pt), { matches: c } = P.useContext(sn), h = c[c.length - 1], p = h ? h.params : {}, g = h ? h.pathname : "/", y = h ? h.pathnameBase : "/", v = h && h.route; {
        let j = v && v.path || ""; rm(g, !v || j.endsWith("*") || j.endsWith("*?"), `You rendered descendant <Routes> (or called \`useRoutes()\`) at "${g}" (under <Route path="${j}">) but the parent route path has no trailing "*". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.

Please change the parent <Route path="${j}"> to <Route path="${j === "/" ? "*" : `${j}/*`}">.`)
    } let x = tr(), C; if (r) { let j = typeof r == "string" ? br(r) : r; Le(y === "/" || ((b = j.pathname) == null ? void 0 : b.startsWith(y)), `When overriding the location using \`<Routes location>\` or \`useRoutes(routes, location)\`, the location pathname must begin with the portion of the URL pathname that was matched by all parent routes. The current pathname base is "${y}" but pathname "${j.pathname}" was given in the \`location\` prop.`), C = j } else C = x; let M = C.pathname || "/", N = M; if (y !== "/") { let j = y.replace(/^\//, "").split("/"); N = "/" + M.replace(/^\//, "").split("/").slice(j.length).join("/") } let A = $p(n, { pathname: N }); Ht(v || A != null, `No routes matched location "${C.pathname}${C.search}${C.hash}" `), Ht(A == null || A[A.length - 1].route.element !== void 0 || A[A.length - 1].route.Component !== void 0 || A[A.length - 1].route.lazy !== void 0, `Matched leaf route at location "${C.pathname}${C.search}${C.hash}" does not have an element or Component. This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.`); let V = q0(A && A.map(j => Object.assign({}, j, { params: Object.assign({}, p, j.params), pathname: nn([y, f.encodeLocation ? f.encodeLocation(j.pathname.replace(/\?/g, "%3F").replace(/#/g, "%23")).pathname : j.pathname]), pathnameBase: j.pathnameBase === "/" ? y : nn([y, f.encodeLocation ? f.encodeLocation(j.pathnameBase.replace(/\?/g, "%3F").replace(/#/g, "%23")).pathname : j.pathnameBase]) })), c, o, s, l); return r && V ? P.createElement(Wi.Provider, { value: { location: { pathname: "/", search: "", hash: "", state: null, key: "default", ...C }, navigationType: "POP" } }, V) : V
} function Y0() { let n = rx(), r = V0(n) ? `${n.status} ${n.statusText}` : n instanceof Error ? n.message : JSON.stringify(n), o = n instanceof Error ? n.stack : null, s = "rgba(200,200,200, 0.5)", l = { padding: "0.5rem", backgroundColor: s }, f = { padding: "2px 4px", backgroundColor: s }, c = null; return console.error("Error handled by React Router default ErrorBoundary:", n), c = P.createElement(P.Fragment, null, P.createElement("p", null, " Hey developer "), P.createElement("p", null, "You can provide a way better UX than this when your app throws errors by providing your own ", P.createElement("code", { style: f }, "ErrorBoundary"), " or", " ", P.createElement("code", { style: f }, "errorElement"), " prop on your route.")), P.createElement(P.Fragment, null, P.createElement("h2", null, "Unexpected Application Error!"), P.createElement("h3", { style: { fontStyle: "italic" } }, r), o ? P.createElement("pre", { style: l }, o) : null, c) } var X0 = P.createElement(Y0, null), nm = class extends P.Component { constructor(n) { super(n), this.state = { location: n.location, revalidation: n.revalidation, error: n.error } } static getDerivedStateFromError(n) { return { error: n } } static getDerivedStateFromProps(n, r) { return r.location !== n.location || r.revalidation !== "idle" && n.revalidation === "idle" ? { error: n.error, location: n.location, revalidation: n.revalidation } : { error: n.error !== void 0 ? n.error : r.error, location: r.location, revalidation: n.revalidation || r.revalidation } } componentDidCatch(n, r) { this.props.onError ? this.props.onError(n, r) : console.error("React Router caught the following error during render", n) } render() { let n = this.state.error; if (this.context && typeof n == "object" && n && "digest" in n && typeof n.digest == "string") { const o = $0(n.digest); o && (n = o) } let r = n !== void 0 ? P.createElement(sn.Provider, { value: this.props.routeContext }, P.createElement(ju.Provider, { value: n, children: this.props.component })) : this.props.children; return this.context ? P.createElement(Q0, { error: n }, r) : r } }; nm.contextType = I0; var Il = new WeakMap; function Q0({ children: n, error: r }) { let { basename: o } = P.useContext(Pt); if (typeof r == "object" && r && "digest" in r && typeof r.digest == "string") { let s = U0(r.digest); if (s) { let l = Il.get(r); if (l) throw l; let f = Xp(s.location, o); if (Yp && !Il.get(r)) if (f.isExternal || s.reloadDocument) window.location.href = f.absoluteURL || f.to; else { const c = Promise.resolve().then(() => window.__reactRouterDataRouter.navigate(f.to, { replace: s.replace })); throw Il.set(r, c), c } return P.createElement("meta", { httpEquiv: "refresh", content: `0;url=${f.absoluteURL || f.to}` }) } } return n } function Z0({ routeContext: n, match: r, children: o }) { let s = P.useContext(Ir); return s && s.static && s.staticContext && (r.route.errorElement || r.route.ErrorBoundary) && (s.staticContext._deepestRenderedBoundaryId = r.route.id), P.createElement(sn.Provider, { value: n }, o) } function q0(n, r = [], o = null, s = null, l = null) { if (n == null) { if (!o) return null; if (o.errors) n = o.matches; else if (r.length === 0 && !o.initialized && o.matches.length > 0) n = o.matches; else return null } let f = n, c = o == null ? void 0 : o.errors; if (c != null) { let y = f.findIndex(v => v.route.id && (c == null ? void 0 : c[v.route.id]) !== void 0); Le(y >= 0, `Could not find a matching route for errors on route IDs: ${Object.keys(c).join(",")}`), f = f.slice(0, Math.min(f.length, y + 1)) } let h = !1, p = -1; if (o) for (let y = 0; y < f.length; y++) { let v = f[y]; if ((v.route.HydrateFallback || v.route.hydrateFallbackElement) && (p = y), v.route.id) { let { loaderData: x, errors: C } = o, M = v.route.loader && !x.hasOwnProperty(v.route.id) && (!C || C[v.route.id] === void 0); if (v.route.lazy || M) { h = !0, p >= 0 ? f = f.slice(0, p + 1) : f = [f[0]]; break } } } let g = o && s ? (y, v) => { var x, C; s(y, { location: o.location, params: ((C = (x = o.matches) == null ? void 0 : x[0]) == null ? void 0 : C.params) ?? {}, unstable_pattern: _0(o.matches), errorInfo: v }) } : void 0; return f.reduceRight((y, v, x) => { let C, M = !1, N = null, A = null; o && (C = c && v.route.id ? c[v.route.id] : void 0, N = v.route.errorElement || X0, h && (p < 0 && x === 0 ? (rm("route-fallback", !1, "No `HydrateFallback` element provided to render during initial hydration"), M = !0, A = null) : p === x && (M = !0, A = v.route.hydrateFallbackElement || null))); let V = r.concat(f.slice(0, x + 1)), b = () => { let j; return C ? j = N : M ? j = A : v.route.Component ? j = P.createElement(v.route.Component, null) : v.route.element ? j = v.route.element : j = y, P.createElement(Z0, { match: v, routeContext: { outlet: y, matches: V, isDataRoute: o != null }, children: j }) }; return o && (v.route.ErrorBoundary || v.route.errorElement || x === 0) ? P.createElement(nm, { location: o.location, revalidation: o.revalidation, component: N, error: C, children: b(), routeContext: { outlet: null, matches: V, isDataRoute: !0 }, onError: g }) : b() }, null) } function Vu(n) { return `${n} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.` } function J0(n) { let r = P.useContext(Ir); return Le(r, Vu(n)), r } function ex(n) { let r = P.useContext(Ds); return Le(r, Vu(n)), r } function tx(n) { let r = P.useContext(sn); return Le(r, Vu(n)), r } function _u(n) { let r = tx(n), o = r.matches[r.matches.length - 1]; return Le(o.route.id, `${n} can only be used on routes that contain a unique "id"`), o.route.id } function nx() { return _u("useRouteId") } function rx() { var s; let n = P.useContext(ju), r = ex("useRouteError"), o = _u("useRouteError"); return n !== void 0 ? n : (s = r.errors) == null ? void 0 : s[o] } function ix() { let { router: n } = J0("useNavigate"), r = _u("useNavigate"), o = P.useRef(!1); return em(() => { o.current = !0 }), P.useCallback(async (l, f = {}) => { Ht(o.current, Jp), o.current && (typeof l == "number" ? await n.navigate(l) : await n.navigate(l, { fromRouteId: r, ...f })) }, [n, r]) } var kh = {}; function rm(n, r, o) { !r && !kh[n] && (kh[n] = !0, Ht(!1, o)) } P.memo(ox); function ox({ routes: n, future: r, state: o, onError: s }) { return tm(n, void 0, o, s, r) } function ou(n) { Le(!1, "A <Route> is only ever to be used as the child of <Routes> element, never rendered directly. Please wrap your <Route> in a <Routes>.") } function sx({ basename: n = "/", children: r = null, location: o, navigationType: s = "POP", navigator: l, static: f = !1, unstable_useTransitions: c }) { Le(!Hi(), "You cannot render a <Router> inside another <Router>. You should never have more than one in your app."); let h = n.replace(/^\/*/, "/"), p = P.useMemo(() => ({ basename: h, navigator: l, static: f, unstable_useTransitions: c, future: {} }), [h, l, f, c]); typeof o == "string" && (o = br(o)); let { pathname: g = "/", search: y = "", hash: v = "", state: x = null, key: C = "default" } = o, M = P.useMemo(() => { let N = rn(g, h); return N == null ? null : { location: { pathname: N, search: y, hash: v, state: x, key: C }, navigationType: s } }, [h, g, y, v, x, C, s]); return Ht(M != null, `<Router basename="${h}"> is not able to match the URL "${g}${y}${v}" because it does not start with the basename, so the <Router> won't render anything.`), M == null ? null : P.createElement(Pt.Provider, { value: p }, P.createElement(Wi.Provider, { children: r, value: M })) } function ax({ children: n, location: r }) { return G0(su(n), r) } function su(n, r = []) { let o = []; return P.Children.forEach(n, (s, l) => { if (!P.isValidElement(s)) return; let f = [...r, l]; if (s.type === P.Fragment) { o.push.apply(o, su(s.props.children, f)); return } Le(s.type === ou, `[${typeof s.type == "string" ? s.type : s.type.name}] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>`), Le(!s.props.index || !s.props.children, "An index route cannot have child routes."); let c = { id: s.props.id || f.join("-"), caseSensitive: s.props.caseSensitive, element: s.props.element, Component: s.props.Component, index: s.props.index, path: s.props.path, middleware: s.props.middleware, loader: s.props.loader, action: s.props.action, hydrateFallbackElement: s.props.hydrateFallbackElement, HydrateFallback: s.props.HydrateFallback, errorElement: s.props.errorElement, ErrorBoundary: s.props.ErrorBoundary, hasErrorBoundary: s.props.hasErrorBoundary === !0 || s.props.ErrorBoundary != null || s.props.errorElement != null, shouldRevalidate: s.props.shouldRevalidate, handle: s.props.handle, lazy: s.props.lazy }; s.props.children && (c.children = su(s.props.children, f)), o.push(c) }), o } var ps = "get", ms = "application/x-www-form-urlencoded"; function js(n) { return typeof HTMLElement < "u" && n instanceof HTMLElement } function lx(n) { return js(n) && n.tagName.toLowerCase() === "button" } function ux(n) { return js(n) && n.tagName.toLowerCase() === "form" } function cx(n) { return js(n) && n.tagName.toLowerCase() === "input" } function fx(n) { return !!(n.metaKey || n.altKey || n.ctrlKey || n.shiftKey) } function dx(n, r) { return n.button === 0 && (!r || r === "_self") && !fx(n) } var ls = null; function hx() { if (ls === null) try { new FormData(document.createElement("form"), 0), ls = !1 } catch { ls = !0 } return ls } var px = new Set(["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"]); function Fl(n) { return n != null && !px.has(n) ? (Ht(!1, `"${n}" is not a valid \`encType\` for \`<Form>\`/\`<fetcher.Form>\` and will default to "${ms}"`), null) : n } function mx(n, r) { let o, s, l, f, c; if (ux(n)) { let h = n.getAttribute("action"); s = h ? rn(h, r) : null, o = n.getAttribute("method") || ps, l = Fl(n.getAttribute("enctype")) || ms, f = new FormData(n) } else if (lx(n) || cx(n) && (n.type === "submit" || n.type === "image")) { let h = n.form; if (h == null) throw new Error('Cannot submit a <button> or <input type="submit"> without a <form>'); let p = n.getAttribute("formaction") || h.getAttribute("action"); if (s = p ? rn(p, r) : null, o = n.getAttribute("formmethod") || h.getAttribute("method") || ps, l = Fl(n.getAttribute("formenctype")) || Fl(h.getAttribute("enctype")) || ms, f = new FormData(h, n), !hx()) { let { name: g, type: y, value: v } = n; if (y === "image") { let x = g ? `${g}.` : ""; f.append(`${x}x`, "0"), f.append(`${x}y`, "0") } else g && f.append(g, v) } } else { if (js(n)) throw new Error('Cannot submit element that is not <form>, <button>, or <input type="submit|image">'); o = ps, s = null, l = ms, c = n } return f && l === "text/plain" && (c = f, f = void 0), { action: s, method: o.toLowerCase(), encType: l, formData: f, body: c } } Object.getOwnPropertyNames(Object.prototype).sort().join("\0"); function bu(n, r) { if (n === !1 || n === null || typeof n > "u") throw new Error(r) } function gx(n, r, o, s) { let l = typeof n == "string" ? new URL(n, typeof window > "u" ? "server://singlefetch/" : window.location.origin) : n; return o ? l.pathname.endsWith("/") ? l.pathname = `${l.pathname}_.${s}` : l.pathname = `${l.pathname}.${s}` : l.pathname === "/" ? l.pathname = `_root.${s}` : r && rn(l.pathname, r) === "/" ? l.pathname = `${r.replace(/\/$/, "")}/_root.${s}` : l.pathname = `${l.pathname.replace(/\/$/, "")}.${s}`, l } async function yx(n, r) { if (n.id in r) return r[n.id]; try { let o = await import(n.module); return r[n.id] = o, o } catch (o) { return console.error(`Error loading route module \`${n.module}\`, reloading page...`), console.error(o), window.__reactRouterContext && window.__reactRouterContext.isSpaMode, window.location.reload(), new Promise(() => { }) } } function vx(n) { return n == null ? !1 : n.href == null ? n.rel === "preload" && typeof n.imageSrcSet == "string" && typeof n.imageSizes == "string" : typeof n.rel == "string" && typeof n.href == "string" } async function xx(n, r, o) { let s = await Promise.all(n.map(async l => { let f = r.routes[l.route.id]; if (f) { let c = await yx(f, o); return c.links ? c.links() : [] } return [] })); return Cx(s.flat(1).filter(vx).filter(l => l.rel === "stylesheet" || l.rel === "preload").map(l => l.rel === "stylesheet" ? { ...l, rel: "prefetch", as: "style" } : { ...l, rel: "prefetch" })) } function Ch(n, r, o, s, l, f) { let c = (p, g) => o[g] ? p.route.id !== o[g].route.id : !0, h = (p, g) => { var y; return o[g].pathname !== p.pathname || ((y = o[g].route.path) == null ? void 0 : y.endsWith("*")) && o[g].params["*"] !== p.params["*"] }; return f === "assets" ? r.filter((p, g) => c(p, g) || h(p, g)) : f === "data" ? r.filter((p, g) => { var v; let y = s.routes[p.route.id]; if (!y || !y.hasLoader) return !1; if (c(p, g) || h(p, g)) return !0; if (p.route.shouldRevalidate) { let x = p.route.shouldRevalidate({ currentUrl: new URL(l.pathname + l.search + l.hash, window.origin), currentParams: ((v = o[0]) == null ? void 0 : v.params) || {}, nextUrl: new URL(n, window.origin), nextParams: p.params, defaultShouldRevalidate: !0 }); if (typeof x == "boolean") return x } return !0 }) : [] } function wx(n, r, { includeHydrateFallback: o } = {}) { return Sx(n.map(s => { let l = r.routes[s.route.id]; if (!l) return []; let f = [l.module]; return l.clientActionModule && (f = f.concat(l.clientActionModule)), l.clientLoaderModule && (f = f.concat(l.clientLoaderModule)), o && l.hydrateFallbackModule && (f = f.concat(l.hydrateFallbackModule)), l.imports && (f = f.concat(l.imports)), f }).flat(1)) } function Sx(n) { return [...new Set(n)] } function kx(n) { let r = {}, o = Object.keys(n).sort(); for (let s of o) r[s] = n[s]; return r } function Cx(n, r) { let o = new Set; return new Set(r), n.reduce((s, l) => { let f = JSON.stringify(kx(l)); return o.has(f) || (o.add(f), s.push({ key: f, link: l })), s }, []) } function im() { let n = P.useContext(Ir); return bu(n, "You must render this element inside a <DataRouterContext.Provider> element"), n } function Ex() { let n = P.useContext(Ds); return bu(n, "You must render this element inside a <DataRouterStateContext.Provider> element"), n } var Iu = P.createContext(void 0); Iu.displayName = "FrameworkContext"; function om() { let n = P.useContext(Iu); return bu(n, "You must render this element inside a <HydratedRouter> element"), n } function Tx(n, r) { let o = P.useContext(Iu), [s, l] = P.useState(!1), [f, c] = P.useState(!1), { onFocus: h, onBlur: p, onMouseEnter: g, onMouseLeave: y, onTouchStart: v } = r, x = P.useRef(null); P.useEffect(() => { if (n === "render" && c(!0), n === "viewport") { let N = V => { V.forEach(b => { c(b.isIntersecting) }) }, A = new IntersectionObserver(N, { threshold: .5 }); return x.current && A.observe(x.current), () => { A.disconnect() } } }, [n]), P.useEffect(() => { if (s) { let N = setTimeout(() => { c(!0) }, 100); return () => { clearTimeout(N) } } }, [s]); let C = () => { l(!0) }, M = () => { l(!1), c(!1) }; return o ? n !== "intent" ? [f, x, {}] : [f, x, { onFocus: Ai(h, C), onBlur: Ai(p, M), onMouseEnter: Ai(g, C), onMouseLeave: Ai(y, M), onTouchStart: Ai(v, C) }] : [!1, x, {}] } function Ai(n, r) { return o => { n && n(o), o.defaultPrevented || r(o) } } function Px({ page: n, ...r }) { let { router: o } = im(), s = P.useMemo(() => $p(o.routes, n, o.basename), [o.routes, n, o.basename]); return s ? P.createElement(Mx, { page: n, matches: s, ...r }) : null } function Rx(n) { let { manifest: r, routeModules: o } = om(), [s, l] = P.useState([]); return P.useEffect(() => { let f = !1; return xx(n, r, o).then(c => { f || l(c) }), () => { f = !0 } }, [n, r, o]), s } function Mx({ page: n, matches: r, ...o }) { let s = tr(), { future: l, manifest: f, routeModules: c } = om(), { basename: h } = im(), { loaderData: p, matches: g } = Ex(), y = P.useMemo(() => Ch(n, r, g, f, s, "data"), [n, r, g, f, s]), v = P.useMemo(() => Ch(n, r, g, f, s, "assets"), [n, r, g, f, s]), x = P.useMemo(() => { if (n === s.pathname + s.search + s.hash) return []; let N = new Set, A = !1; if (r.forEach(b => { var W; let j = f.routes[b.route.id]; !j || !j.hasLoader || (!y.some(U => U.route.id === b.route.id) && b.route.id in p && ((W = c[b.route.id]) != null && W.shouldRevalidate) || j.hasClientLoader ? A = !0 : N.add(b.route.id)) }), N.size === 0) return []; let V = gx(n, h, l.unstable_trailingSlashAwareDataRequests, "data"); return A && N.size > 0 && V.searchParams.set("_routes", r.filter(b => N.has(b.route.id)).map(b => b.route.id).join(",")), [V.pathname + V.search] }, [h, l.unstable_trailingSlashAwareDataRequests, p, s, f, y, r, n, c]), C = P.useMemo(() => wx(v, f), [v, f]), M = Rx(v); return P.createElement(P.Fragment, null, x.map(N => P.createElement("link", { key: N, rel: "prefetch", as: "fetch", href: N, ...o })), C.map(N => P.createElement("link", { key: N, rel: "modulepreload", href: N, ...o })), M.map(({ key: N, link: A }) => P.createElement("link", { key: N, nonce: o.nonce, ...A, crossOrigin: A.crossOrigin ?? o.crossOrigin }))) } function Ax(...n) { return r => { n.forEach(o => { typeof o == "function" ? o(r) : o != null && (o.current = r) }) } } var Lx = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u"; try { Lx && (window.__reactRouterVersion = "7.13.0") } catch { } function Nx({ basename: n, children: r, unstable_useTransitions: o, window: s }) { let l = P.useRef(); l.current == null && (l.current = c0({ window: s, v5Compat: !0 })); let f = l.current, [c, h] = P.useState({ action: f.action, location: f.location }), p = P.useCallback(g => { o === !1 ? h(g) : P.startTransition(() => h(g)) }, [o]); return P.useLayoutEffect(() => f.listen(p), [f, p]), P.createElement(sx, { basename: n, children: r, location: c.location, navigationType: c.action, navigator: f, unstable_useTransitions: o }) } var sm = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i, Fi = P.forwardRef(function ({ onClick: r, discover: o = "render", prefetch: s = "none", relative: l, reloadDocument: f, replace: c, state: h, target: p, to: g, preventScrollReset: y, viewTransition: v, unstable_defaultShouldRevalidate: x, ...C }, M) { let { basename: N, unstable_useTransitions: A } = P.useContext(Pt), V = typeof g == "string" && sm.test(g), b = Xp(g, N); g = b.to; let j = W0(g, { relative: l }), [W, U, J] = Tx(s, C), se = _x(g, { replace: c, state: h, target: p, preventScrollReset: y, relative: l, viewTransition: v, unstable_defaultShouldRevalidate: x, unstable_useTransitions: A }); function O(ve) { r && r(ve), ve.defaultPrevented || se(ve) } let ce = P.createElement("a", { ...C, ...J, href: b.absoluteURL || j, onClick: b.isExternal || f ? r : O, ref: Ax(M, U), target: p, "data-discover": !V && o === "render" ? "true" : void 0 }); return W && !V ? P.createElement(P.Fragment, null, ce, P.createElement(Px, { page: j })) : ce }); Fi.displayName = "Link"; var Dx = P.forwardRef(function ({ "aria-current": r = "page", caseSensitive: o = !1, className: s = "", end: l = !1, style: f, to: c, viewTransition: h, children: p, ...g }, y) { let v = Ki(c, { relative: g.relative }), x = tr(), C = P.useContext(Ds), { navigator: M, basename: N } = P.useContext(Pt), A = C != null && Ox(v) && h === !0, V = M.encodeLocation ? M.encodeLocation(v).pathname : v.pathname, b = x.pathname, j = C && C.navigation && C.navigation.location ? C.navigation.location.pathname : null; o || (b = b.toLowerCase(), j = j ? j.toLowerCase() : null, V = V.toLowerCase()), j && N && (j = rn(j, N) || j); const W = V !== "/" && V.endsWith("/") ? V.length - 1 : V.length; let U = b === V || !l && b.startsWith(V) && b.charAt(W) === "/", J = j != null && (j === V || !l && j.startsWith(V) && j.charAt(V.length) === "/"), se = { isActive: U, isPending: J, isTransitioning: A }, O = U ? r : void 0, ce; typeof s == "function" ? ce = s(se) : ce = [s, U ? "active" : null, J ? "pending" : null, A ? "transitioning" : null].filter(Boolean).join(" "); let ve = typeof f == "function" ? f(se) : f; return P.createElement(Fi, { ...g, "aria-current": O, className: ce, ref: y, style: ve, to: c, viewTransition: h }, typeof p == "function" ? p(se) : p) }); Dx.displayName = "NavLink"; var jx = P.forwardRef(({ discover: n = "render", fetcherKey: r, navigate: o, reloadDocument: s, replace: l, state: f, method: c = ps, action: h, onSubmit: p, relative: g, preventScrollReset: y, viewTransition: v, unstable_defaultShouldRevalidate: x, ...C }, M) => { let { unstable_useTransitions: N } = P.useContext(Pt), A = Fx(), V = zx(h, { relative: g }), b = c.toLowerCase() === "get" ? "get" : "post", j = typeof h == "string" && sm.test(h), W = U => { if (p && p(U), U.defaultPrevented) return; U.preventDefault(); let J = U.nativeEvent.submitter, se = (J == null ? void 0 : J.getAttribute("formmethod")) || c, O = () => A(J || U.currentTarget, { fetcherKey: r, method: se, navigate: o, replace: l, state: f, relative: g, preventScrollReset: y, viewTransition: v, unstable_defaultShouldRevalidate: x }); N && o !== !1 ? P.startTransition(() => O()) : O() }; return P.createElement("form", { ref: M, method: b, action: V, onSubmit: s ? p : W, ...C, "data-discover": !j && n === "render" ? "true" : void 0 }) }); jx.displayName = "Form"; function Vx(n) { return `${n} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.` } function am(n) { let r = P.useContext(Ir); return Le(r, Vx(n)), r } function _x(n, { target: r, replace: o, state: s, preventScrollReset: l, relative: f, viewTransition: c, unstable_defaultShouldRevalidate: h, unstable_useTransitions: p } = {}) { let g = H0(), y = tr(), v = Ki(n, { relative: f }); return P.useCallback(x => { if (dx(x, r)) { x.preventDefault(); let C = o !== void 0 ? o : Ii(y) === Ii(v), M = () => g(n, { replace: C, state: s, preventScrollReset: l, relative: f, viewTransition: c, unstable_defaultShouldRevalidate: h }); p ? P.startTransition(() => M()) : M() } }, [y, g, v, o, s, r, n, l, f, c, h, p]) } var bx = 0, Ix = () => `__${String(++bx)}__`; function Fx() { let { router: n } = am("useSubmit"), { basename: r } = P.useContext(Pt), o = nx(), s = n.fetch, l = n.navigate; return P.useCallback(async (f, c = {}) => { let { action: h, method: p, encType: g, formData: y, body: v } = mx(f, r); if (c.navigate === !1) { let x = c.fetcherKey || Ix(); await s(x, o, c.action || h, { unstable_defaultShouldRevalidate: c.unstable_defaultShouldRevalidate, preventScrollReset: c.preventScrollReset, formData: y, body: v, formMethod: c.method || p, formEncType: c.encType || g, flushSync: c.flushSync }) } else await l(c.action || h, { unstable_defaultShouldRevalidate: c.unstable_defaultShouldRevalidate, preventScrollReset: c.preventScrollReset, formData: y, body: v, formMethod: c.method || p, formEncType: c.encType || g, replace: c.replace, state: c.state, fromRouteId: o, flushSync: c.flushSync, viewTransition: c.viewTransition }) }, [s, l, r, o]) } function zx(n, { relative: r } = {}) { let { basename: o } = P.useContext(Pt), s = P.useContext(sn); Le(s, "useFormAction must be used inside a RouteContext"); let [l] = s.matches.slice(-1), f = { ...Ki(n || ".", { relative: r }) }, c = tr(); if (n == null) { f.search = c.search; let h = new URLSearchParams(f.search), p = h.getAll("index"); if (p.some(y => y === "")) { h.delete("index"), p.filter(v => v).forEach(v => h.append("index", v)); let y = h.toString(); f.search = y ? `?${y}` : "" } } return (!n || n === ".") && l.route.index && (f.search = f.search ? f.search.replace(/^\?/, "?index&") : "?index"), o !== "/" && (f.pathname = f.pathname === "/" ? o : nn([o, f.pathname])), Ii(f) } function Ox(n, { relative: r } = {}) { let o = P.useContext(Zp); Le(o != null, "`useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  Did you accidentally import `RouterProvider` from `react-router`?"); let { basename: s } = am("useViewTransitionState"), l = Ki(n, { relative: r }); if (!o.isTransitioning) return !1; let f = rn(o.currentLocation.pathname, s) || o.currentLocation.pathname, c = rn(o.nextLocation.pathname, s) || o.nextLocation.pathname; return ks(l.pathname, c) != null || ks(l.pathname, f) != null } const lm = P.createContext({}); function Bx(n) { const r = P.useRef(null); return r.current === null && (r.current = n()), r.current } const um = typeof window < "u", Ux = um ? P.useLayoutEffect : P.useEffect, Fu = P.createContext(null); function zu(n, r) { n.indexOf(r) === -1 && n.push(r) } function Cs(n, r) { const o = n.indexOf(r); o > -1 && n.splice(o, 1) } const Kt = (n, r, o) => o > r ? r : o < n ? n : o; let Ou = () => { }; const on = {}, cm = n => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(n); function fm(n) { return typeof n == "object" && n !== null } const dm = n => /^0[^.\s]+$/u.test(n); function Bu(n) { let r; return () => (r === void 0 && (r = n()), r) } const Tt = n => n, $x = (n, r) => o => r(n(o)), Gi = (...n) => n.reduce($x), zi = (n, r, o) => { const s = r - n; return s === 0 ? 1 : (o - n) / s }; class Uu { constructor() { this.subscriptions = [] } add(r) { return zu(this.subscriptions, r), () => Cs(this.subscriptions, r) } notify(r, o, s) { const l = this.subscriptions.length; if (l) if (l === 1) this.subscriptions[0](r, o, s); else for (let f = 0; f < l; f++) { const c = this.subscriptions[f]; c && c(r, o, s) } } getSize() { return this.subscriptions.length } clear() { this.subscriptions.length = 0 } } const bt = n => n * 1e3, Et = n => n / 1e3; function hm(n, r) { return r ? n * (1e3 / r) : 0 } const pm = (n, r, o) => (((1 - 3 * o + 3 * r) * n + (3 * o - 6 * r)) * n + 3 * r) * n, Wx = 1e-7, Hx = 12; function Kx(n, r, o, s, l) { let f, c, h = 0; do c = r + (o - r) / 2, f = pm(c, s, l) - n, f > 0 ? o = c : r = c; while (Math.abs(f) > Wx && ++h < Hx); return c } function Yi(n, r, o, s) { if (n === r && o === s) return Tt; const l = f => Kx(f, 0, 1, n, o); return f => f === 0 || f === 1 ? f : pm(l(f), r, s) } const mm = n => r => r <= .5 ? n(2 * r) / 2 : (2 - n(2 * (1 - r))) / 2, gm = n => r => 1 - n(1 - r), ym = Yi(.33, 1.53, .69, .99), $u = gm(ym), vm = mm($u), xm = n => (n *= 2) < 1 ? .5 * $u(n) : .5 * (2 - Math.pow(2, -10 * (n - 1))), Wu = n => 1 - Math.sin(Math.acos(n)), wm = gm(Wu), Sm = mm(Wu), Gx = Yi(.42, 0, 1, 1), Yx = Yi(0, 0, .58, 1), km = Yi(.42, 0, .58, 1), Xx = n => Array.isArray(n) && typeof n[0] != "number", Cm = n => Array.isArray(n) && typeof n[0] == "number", Qx = { linear: Tt, easeIn: Gx, easeInOut: km, easeOut: Yx, circIn: Wu, circInOut: Sm, circOut: wm, backIn: $u, backInOut: vm, backOut: ym, anticipate: xm }, Zx = n => typeof n == "string", Eh = n => { if (Cm(n)) { Ou(n.length === 4); const [r, o, s, l] = n; return Yi(r, o, s, l) } else if (Zx(n)) return Qx[n]; return n }, us = ["setup", "read", "resolveKeyframes", "preUpdate", "update", "preRender", "render", "postRender"]; function qx(n, r) { let o = new Set, s = new Set, l = !1, f = !1; const c = new WeakSet; let h = { delta: 0, timestamp: 0, isProcessing: !1 }; function p(y) { c.has(y) && (g.schedule(y), n()), y(h) } const g = { schedule: (y, v = !1, x = !1) => { const M = x && l ? o : s; return v && c.add(y), M.has(y) || M.add(y), y }, cancel: y => { s.delete(y), c.delete(y) }, process: y => { if (h = y, l) { f = !0; return } l = !0, [o, s] = [s, o], o.forEach(p), o.clear(), l = !1, f && (f = !1, g.process(y)) } }; return g } const Jx = 40; function Em(n, r) { let o = !1, s = !0; const l = { delta: 0, timestamp: 0, isProcessing: !1 }, f = () => o = !0, c = us.reduce((j, W) => (j[W] = qx(f), j), {}), { setup: h, read: p, resolveKeyframes: g, preUpdate: y, update: v, preRender: x, render: C, postRender: M } = c, N = () => { const j = on.useManualTiming ? l.timestamp : performance.now(); o = !1, on.useManualTiming || (l.delta = s ? 1e3 / 60 : Math.max(Math.min(j - l.timestamp, Jx), 1)), l.timestamp = j, l.isProcessing = !0, h.process(l), p.process(l), g.process(l), y.process(l), v.process(l), x.process(l), C.process(l), M.process(l), l.isProcessing = !1, o && r && (s = !1, n(N)) }, A = () => { o = !0, s = !0, l.isProcessing || n(N) }; return { schedule: us.reduce((j, W) => { const U = c[W]; return j[W] = (J, se = !1, O = !1) => (o || A(), U.schedule(J, se, O)), j }, {}), cancel: j => { for (let W = 0; W < us.length; W++)c[us[W]].cancel(j) }, state: l, steps: c } } const { schedule: ke, cancel: Nn, state: qe, steps: zl } = Em(typeof requestAnimationFrame < "u" ? requestAnimationFrame : Tt, !0); let gs; function ew() { gs = void 0 } const st = { now: () => (gs === void 0 && st.set(qe.isProcessing || on.useManualTiming ? qe.timestamp : performance.now()), gs), set: n => { gs = n, queueMicrotask(ew) } }, Tm = n => r => typeof r == "string" && r.startsWith(n), Pm = Tm("--"), tw = Tm("var(--"), Hu = n => tw(n) ? nw.test(n.split("/*")[0].trim()) : !1, nw = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu; function Th(n) { return typeof n != "string" ? !1 : n.split("/*")[0].includes("var(--") } const Fr = { test: n => typeof n == "number", parse: parseFloat, transform: n => n }, Oi = { ...Fr, transform: n => Kt(0, 1, n) }, cs = { ...Fr, default: 1 }, ji = n => Math.round(n * 1e5) / 1e5, Ku = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu; function rw(n) { return n == null } const iw = /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu, Gu = (n, r) => o => !!(typeof o == "string" && iw.test(o) && o.startsWith(n) || r && !rw(o) && Object.prototype.hasOwnProperty.call(o, r)), Rm = (n, r, o) => s => { if (typeof s != "string") return s; const [l, f, c, h] = s.match(Ku); return { [n]: parseFloat(l), [r]: parseFloat(f), [o]: parseFloat(c), alpha: h !== void 0 ? parseFloat(h) : 1 } }, ow = n => Kt(0, 255, n), Ol = { ...Fr, transform: n => Math.round(ow(n)) }, qn = { test: Gu("rgb", "red"), parse: Rm("red", "green", "blue"), transform: ({ red: n, green: r, blue: o, alpha: s = 1 }) => "rgba(" + Ol.transform(n) + ", " + Ol.transform(r) + ", " + Ol.transform(o) + ", " + ji(Oi.transform(s)) + ")" }; function sw(n) { let r = "", o = "", s = "", l = ""; return n.length > 5 ? (r = n.substring(1, 3), o = n.substring(3, 5), s = n.substring(5, 7), l = n.substring(7, 9)) : (r = n.substring(1, 2), o = n.substring(2, 3), s = n.substring(3, 4), l = n.substring(4, 5), r += r, o += o, s += s, l += l), { red: parseInt(r, 16), green: parseInt(o, 16), blue: parseInt(s, 16), alpha: l ? parseInt(l, 16) / 255 : 1 } } const au = { test: Gu("#"), parse: sw, transform: qn.transform }, Xi = n => ({ test: r => typeof r == "string" && r.endsWith(n) && r.split(" ").length === 1, parse: parseFloat, transform: r => `${r}${n}` }), Mn = Xi("deg"), Wt = Xi("%"), Z = Xi("px"), aw = Xi("vh"), lw = Xi("vw"), Ph = { ...Wt, parse: n => Wt.parse(n) / 100, transform: n => Wt.transform(n * 100) }, Ar = { test: Gu("hsl", "hue"), parse: Rm("hue", "saturation", "lightness"), transform: ({ hue: n, saturation: r, lightness: o, alpha: s = 1 }) => "hsla(" + Math.round(n) + ", " + Wt.transform(ji(r)) + ", " + Wt.transform(ji(o)) + ", " + ji(Oi.transform(s)) + ")" }, Ie = { test: n => qn.test(n) || au.test(n) || Ar.test(n), parse: n => qn.test(n) ? qn.parse(n) : Ar.test(n) ? Ar.parse(n) : au.parse(n), transform: n => typeof n == "string" ? n : n.hasOwnProperty("red") ? qn.transform(n) : Ar.transform(n), getAnimatableNone: n => { const r = Ie.parse(n); return r.alpha = 0, Ie.transform(r) } }, uw = /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu; function cw(n) { var r, o; return isNaN(n) && typeof n == "string" && (((r = n.match(Ku)) == null ? void 0 : r.length) || 0) + (((o = n.match(uw)) == null ? void 0 : o.length) || 0) > 0 } const Mm = "number", Am = "color", fw = "var", dw = "var(", Rh = "${}", hw = /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu; function Bi(n) { const r = n.toString(), o = [], s = { color: [], number: [], var: [] }, l = []; let f = 0; const h = r.replace(hw, p => (Ie.test(p) ? (s.color.push(f), l.push(Am), o.push(Ie.parse(p))) : p.startsWith(dw) ? (s.var.push(f), l.push(fw), o.push(p)) : (s.number.push(f), l.push(Mm), o.push(parseFloat(p))), ++f, Rh)).split(Rh); return { values: o, split: h, indexes: s, types: l } } function Lm(n) { return Bi(n).values } function Nm(n) { const { split: r, types: o } = Bi(n), s = r.length; return l => { let f = ""; for (let c = 0; c < s; c++)if (f += r[c], l[c] !== void 0) { const h = o[c]; h === Mm ? f += ji(l[c]) : h === Am ? f += Ie.transform(l[c]) : f += l[c] } return f } } const pw = n => typeof n == "number" ? 0 : Ie.test(n) ? Ie.getAnimatableNone(n) : n; function mw(n) { const r = Lm(n); return Nm(n)(r.map(pw)) } const Dn = { test: cw, parse: Lm, createTransformer: Nm, getAnimatableNone: mw }; function Bl(n, r, o) { return o < 0 && (o += 1), o > 1 && (o -= 1), o < 1 / 6 ? n + (r - n) * 6 * o : o < 1 / 2 ? r : o < 2 / 3 ? n + (r - n) * (2 / 3 - o) * 6 : n } function gw({ hue: n, saturation: r, lightness: o, alpha: s }) { n /= 360, r /= 100, o /= 100; let l = 0, f = 0, c = 0; if (!r) l = f = c = o; else { const h = o < .5 ? o * (1 + r) : o + r - o * r, p = 2 * o - h; l = Bl(p, h, n + 1 / 3), f = Bl(p, h, n), c = Bl(p, h, n - 1 / 3) } return { red: Math.round(l * 255), green: Math.round(f * 255), blue: Math.round(c * 255), alpha: s } } function Es(n, r) { return o => o > 0 ? r : n } const Ae = (n, r, o) => n + (r - n) * o, Ul = (n, r, o) => { const s = n * n, l = o * (r * r - s) + s; return l < 0 ? 0 : Math.sqrt(l) }, yw = [au, qn, Ar], vw = n => yw.find(r => r.test(n)); function Mh(n) { const r = vw(n); if (!r) return !1; let o = r.parse(n); return r === Ar && (o = gw(o)), o } const Ah = (n, r) => { const o = Mh(n), s = Mh(r); if (!o || !s) return Es(n, r); const l = { ...o }; return f => (l.red = Ul(o.red, s.red, f), l.green = Ul(o.green, s.green, f), l.blue = Ul(o.blue, s.blue, f), l.alpha = Ae(o.alpha, s.alpha, f), qn.transform(l)) }, lu = new Set(["none", "hidden"]); function xw(n, r) { return lu.has(n) ? o => o <= 0 ? n : r : o => o >= 1 ? r : n } function ww(n, r) { return o => Ae(n, r, o) } function Yu(n) { return typeof n == "number" ? ww : typeof n == "string" ? Hu(n) ? Es : Ie.test(n) ? Ah : Cw : Array.isArray(n) ? Dm : typeof n == "object" ? Ie.test(n) ? Ah : Sw : Es } function Dm(n, r) { const o = [...n], s = o.length, l = n.map((f, c) => Yu(f)(f, r[c])); return f => { for (let c = 0; c < s; c++)o[c] = l[c](f); return o } } function Sw(n, r) { const o = { ...n, ...r }, s = {}; for (const l in o) n[l] !== void 0 && r[l] !== void 0 && (s[l] = Yu(n[l])(n[l], r[l])); return l => { for (const f in s) o[f] = s[f](l); return o } } function kw(n, r) { const o = [], s = { color: 0, var: 0, number: 0 }; for (let l = 0; l < r.values.length; l++) { const f = r.types[l], c = n.indexes[f][s[f]], h = n.values[c] ?? 0; o[l] = h, s[f]++ } return o } const Cw = (n, r) => { const o = Dn.createTransformer(r), s = Bi(n), l = Bi(r); return s.indexes.var.length === l.indexes.var.length && s.indexes.color.length === l.indexes.color.length && s.indexes.number.length >= l.indexes.number.length ? lu.has(n) && !l.values.length || lu.has(r) && !s.values.length ? xw(n, r) : Gi(Dm(kw(s, l), l.values), o) : Es(n, r) }; function jm(n, r, o) { return typeof n == "number" && typeof r == "number" && typeof o == "number" ? Ae(n, r, o) : Yu(n)(n, r) } const Ew = n => { const r = ({ timestamp: o }) => n(o); return { start: (o = !0) => ke.update(r, o), stop: () => Nn(r), now: () => qe.isProcessing ? qe.timestamp : st.now() } }, Vm = (n, r, o = 10) => { let s = ""; const l = Math.max(Math.round(r / o), 2); for (let f = 0; f < l; f++)s += Math.round(n(f / (l - 1)) * 1e4) / 1e4 + ", "; return `linear(${s.substring(0, s.length - 2)})` }, Ts = 2e4; function Xu(n) { let r = 0; const o = 50; let s = n.next(r); for (; !s.done && r < Ts;)r += o, s = n.next(r); return r >= Ts ? 1 / 0 : r } function Tw(n, r = 100, o) { const s = o({ ...n, keyframes: [0, r] }), l = Math.min(Xu(s), Ts); return { type: "keyframes", ease: f => s.next(l * f).value / r, duration: Et(l) } } const Pw = 5; function _m(n, r, o) { const s = Math.max(r - Pw, 0); return hm(o - n(s), r - s) } const De = { stiffness: 100, damping: 10, mass: 1, velocity: 0, duration: 800, bounce: .3, visualDuration: .3, restSpeed: { granular: .01, default: 2 }, restDelta: { granular: .005, default: .5 }, minDuration: .01, maxDuration: 10, minDamping: .05, maxDamping: 1 }, $l = .001; function Rw({ duration: n = De.duration, bounce: r = De.bounce, velocity: o = De.velocity, mass: s = De.mass }) { let l, f, c = 1 - r; c = Kt(De.minDamping, De.maxDamping, c), n = Kt(De.minDuration, De.maxDuration, Et(n)), c < 1 ? (l = g => { const y = g * c, v = y * n, x = y - o, C = uu(g, c), M = Math.exp(-v); return $l - x / C * M }, f = g => { const v = g * c * n, x = v * o + o, C = Math.pow(c, 2) * Math.pow(g, 2) * n, M = Math.exp(-v), N = uu(Math.pow(g, 2), c); return (-l(g) + $l > 0 ? -1 : 1) * ((x - C) * M) / N }) : (l = g => { const y = Math.exp(-g * n), v = (g - o) * n + 1; return -$l + y * v }, f = g => { const y = Math.exp(-g * n), v = (o - g) * (n * n); return y * v }); const h = 5 / n, p = Aw(l, f, h); if (n = bt(n), isNaN(p)) return { stiffness: De.stiffness, damping: De.damping, duration: n }; { const g = Math.pow(p, 2) * s; return { stiffness: g, damping: c * 2 * Math.sqrt(s * g), duration: n } } } const Mw = 12; function Aw(n, r, o) { let s = o; for (let l = 1; l < Mw; l++)s = s - n(s) / r(s); return s } function uu(n, r) { return n * Math.sqrt(1 - r * r) } const Lw = ["duration", "bounce"], Nw = ["stiffness", "damping", "mass"]; function Lh(n, r) { return r.some(o => n[o] !== void 0) } function Dw(n) { let r = { velocity: De.velocity, stiffness: De.stiffness, damping: De.damping, mass: De.mass, isResolvedFromDuration: !1, ...n }; if (!Lh(n, Nw) && Lh(n, Lw)) if (n.visualDuration) { const o = n.visualDuration, s = 2 * Math.PI / (o * 1.2), l = s * s, f = 2 * Kt(.05, 1, 1 - (n.bounce || 0)) * Math.sqrt(l); r = { ...r, mass: De.mass, stiffness: l, damping: f } } else { const o = Rw(n); r = { ...r, ...o, mass: De.mass }, r.isResolvedFromDuration = !0 } return r } function Ps(n = De.visualDuration, r = De.bounce) { const o = typeof n != "object" ? { visualDuration: n, keyframes: [0, 1], bounce: r } : n; let { restSpeed: s, restDelta: l } = o; const f = o.keyframes[0], c = o.keyframes[o.keyframes.length - 1], h = { done: !1, value: f }, { stiffness: p, damping: g, mass: y, duration: v, velocity: x, isResolvedFromDuration: C } = Dw({ ...o, velocity: -Et(o.velocity || 0) }), M = x || 0, N = g / (2 * Math.sqrt(p * y)), A = c - f, V = Et(Math.sqrt(p / y)), b = Math.abs(A) < 5; s || (s = b ? De.restSpeed.granular : De.restSpeed.default), l || (l = b ? De.restDelta.granular : De.restDelta.default); let j; if (N < 1) { const U = uu(V, N); j = J => { const se = Math.exp(-N * V * J); return c - se * ((M + N * V * A) / U * Math.sin(U * J) + A * Math.cos(U * J)) } } else if (N === 1) j = U => c - Math.exp(-V * U) * (A + (M + V * A) * U); else { const U = V * Math.sqrt(N * N - 1); j = J => { const se = Math.exp(-N * V * J), O = Math.min(U * J, 300); return c - se * ((M + N * V * A) * Math.sinh(O) + U * A * Math.cosh(O)) / U } } const W = { calculatedDuration: C && v || null, next: U => { const J = j(U); if (C) h.done = U >= v; else { let se = U === 0 ? M : 0; N < 1 && (se = U === 0 ? bt(M) : _m(j, U, J)); const O = Math.abs(se) <= s, ce = Math.abs(c - J) <= l; h.done = O && ce } return h.value = h.done ? c : J, h }, toString: () => { const U = Math.min(Xu(W), Ts), J = Vm(se => W.next(U * se).value, U, 30); return U + "ms " + J }, toTransition: () => { } }; return W } Ps.applyToOptions = n => { const r = Tw(n, 100, Ps); return n.ease = r.ease, n.duration = bt(r.duration), n.type = "keyframes", n }; function cu({ keyframes: n, velocity: r = 0, power: o = .8, timeConstant: s = 325, bounceDamping: l = 10, bounceStiffness: f = 500, modifyTarget: c, min: h, max: p, restDelta: g = .5, restSpeed: y }) { const v = n[0], x = { done: !1, value: v }, C = O => h !== void 0 && O < h || p !== void 0 && O > p, M = O => h === void 0 ? p : p === void 0 || Math.abs(h - O) < Math.abs(p - O) ? h : p; let N = o * r; const A = v + N, V = c === void 0 ? A : c(A); V !== A && (N = V - v); const b = O => -N * Math.exp(-O / s), j = O => V + b(O), W = O => { const ce = b(O), ve = j(O); x.done = Math.abs(ce) <= g, x.value = x.done ? V : ve }; let U, J; const se = O => { C(x.value) && (U = O, J = Ps({ keyframes: [x.value, M(x.value)], velocity: _m(j, O, x.value), damping: l, stiffness: f, restDelta: g, restSpeed: y })) }; return se(0), { calculatedDuration: null, next: O => { let ce = !1; return !J && U === void 0 && (ce = !0, W(O), se(O)), U !== void 0 && O >= U ? J.next(O - U) : (!ce && W(O), x) } } } function jw(n, r, o) { const s = [], l = o || on.mix || jm, f = n.length - 1; for (let c = 0; c < f; c++) { let h = l(n[c], n[c + 1]); if (r) { const p = Array.isArray(r) ? r[c] || Tt : r; h = Gi(p, h) } s.push(h) } return s } function Vw(n, r, { clamp: o = !0, ease: s, mixer: l } = {}) { const f = n.length; if (Ou(f === r.length), f === 1) return () => r[0]; if (f === 2 && r[0] === r[1]) return () => r[1]; const c = n[0] === n[1]; n[0] > n[f - 1] && (n = [...n].reverse(), r = [...r].reverse()); const h = jw(r, s, l), p = h.length, g = y => { if (c && y < n[0]) return r[0]; let v = 0; if (p > 1) for (; v < n.length - 2 && !(y < n[v + 1]); v++); const x = zi(n[v], n[v + 1], y); return h[v](x) }; return o ? y => g(Kt(n[0], n[f - 1], y)) : g } function _w(n, r) { const o = n[n.length - 1]; for (let s = 1; s <= r; s++) { const l = zi(0, r, s); n.push(Ae(o, 1, l)) } } function bw(n) { const r = [0]; return _w(r, n.length - 1), r } function Iw(n, r) { return n.map(o => o * r) } function Fw(n, r) { return n.map(() => r || km).splice(0, n.length - 1) } function Vi({ duration: n = 300, keyframes: r, times: o, ease: s = "easeInOut" }) { const l = Xx(s) ? s.map(Eh) : Eh(s), f = { done: !1, value: r[0] }, c = Iw(o && o.length === r.length ? o : bw(r), n), h = Vw(c, r, { ease: Array.isArray(l) ? l : Fw(r, l) }); return { calculatedDuration: n, next: p => (f.value = h(p), f.done = p >= n, f) } } const zw = n => n !== null; function Qu(n, { repeat: r, repeatType: o = "loop" }, s, l = 1) { const f = n.filter(zw), h = l < 0 || r && o !== "loop" && r % 2 === 1 ? 0 : f.length - 1; return !h || s === void 0 ? f[h] : s } const Ow = { decay: cu, inertia: cu, tween: Vi, keyframes: Vi, spring: Ps }; function bm(n) { typeof n.type == "string" && (n.type = Ow[n.type]) } class Zu { constructor() { this.updateFinished() } get finished() { return this._finished } updateFinished() { this._finished = new Promise(r => { this.resolve = r }) } notifyFinished() { this.resolve() } then(r, o) { return this.finished.then(r, o) } } const Bw = n => n / 100; class qu extends Zu { constructor(r) { super(), this.state = "idle", this.startTime = null, this.isStopped = !1, this.currentTime = 0, this.holdTime = null, this.playbackSpeed = 1, this.stop = () => { var s, l; const { motionValue: o } = this.options; o && o.updatedAt !== st.now() && this.tick(st.now()), this.isStopped = !0, this.state !== "idle" && (this.teardown(), (l = (s = this.options).onStop) == null || l.call(s)) }, this.options = r, this.initAnimation(), this.play(), r.autoplay === !1 && this.pause() } initAnimation() { const { options: r } = this; bm(r); const { type: o = Vi, repeat: s = 0, repeatDelay: l = 0, repeatType: f, velocity: c = 0 } = r; let { keyframes: h } = r; const p = o || Vi; p !== Vi && typeof h[0] != "number" && (this.mixKeyframes = Gi(Bw, jm(h[0], h[1])), h = [0, 100]); const g = p({ ...r, keyframes: h }); f === "mirror" && (this.mirroredGenerator = p({ ...r, keyframes: [...h].reverse(), velocity: -c })), g.calculatedDuration === null && (g.calculatedDuration = Xu(g)); const { calculatedDuration: y } = g; this.calculatedDuration = y, this.resolvedDuration = y + l, this.totalDuration = this.resolvedDuration * (s + 1) - l, this.generator = g } updateTime(r) { const o = Math.round(r - this.startTime) * this.playbackSpeed; this.holdTime !== null ? this.currentTime = this.holdTime : this.currentTime = o } tick(r, o = !1) { const { generator: s, totalDuration: l, mixKeyframes: f, mirroredGenerator: c, resolvedDuration: h, calculatedDuration: p } = this; if (this.startTime === null) return s.next(0); const { delay: g = 0, keyframes: y, repeat: v, repeatType: x, repeatDelay: C, type: M, onUpdate: N, finalKeyframe: A } = this.options; this.speed > 0 ? this.startTime = Math.min(this.startTime, r) : this.speed < 0 && (this.startTime = Math.min(r - l / this.speed, this.startTime)), o ? this.currentTime = r : this.updateTime(r); const V = this.currentTime - g * (this.playbackSpeed >= 0 ? 1 : -1), b = this.playbackSpeed >= 0 ? V < 0 : V > l; this.currentTime = Math.max(V, 0), this.state === "finished" && this.holdTime === null && (this.currentTime = l); let j = this.currentTime, W = s; if (v) { const O = Math.min(this.currentTime, l) / h; let ce = Math.floor(O), ve = O % 1; !ve && O >= 1 && (ve = 1), ve === 1 && ce--, ce = Math.min(ce, v + 1), !!(ce % 2) && (x === "reverse" ? (ve = 1 - ve, C && (ve -= C / h)) : x === "mirror" && (W = c)), j = Kt(0, 1, ve) * h } const U = b ? { done: !1, value: y[0] } : W.next(j); f && (U.value = f(U.value)); let { done: J } = U; !b && p !== null && (J = this.playbackSpeed >= 0 ? this.currentTime >= l : this.currentTime <= 0); const se = this.holdTime === null && (this.state === "finished" || this.state === "running" && J); return se && M !== cu && (U.value = Qu(y, this.options, A, this.speed)), N && N(U.value), se && this.finish(), U } then(r, o) { return this.finished.then(r, o) } get duration() { return Et(this.calculatedDuration) } get iterationDuration() { const { delay: r = 0 } = this.options || {}; return this.duration + Et(r) } get time() { return Et(this.currentTime) } set time(r) { var o; r = bt(r), this.currentTime = r, this.startTime === null || this.holdTime !== null || this.playbackSpeed === 0 ? this.holdTime = r : this.driver && (this.startTime = this.driver.now() - r / this.playbackSpeed), (o = this.driver) == null || o.start(!1) } get speed() { return this.playbackSpeed } set speed(r) { this.updateTime(st.now()); const o = this.playbackSpeed !== r; this.playbackSpeed = r, o && (this.time = Et(this.currentTime)) } play() { var l, f; if (this.isStopped) return; const { driver: r = Ew, startTime: o } = this.options; this.driver || (this.driver = r(c => this.tick(c))), (f = (l = this.options).onPlay) == null || f.call(l); const s = this.driver.now(); this.state === "finished" ? (this.updateFinished(), this.startTime = s) : this.holdTime !== null ? this.startTime = s - this.holdTime : this.startTime || (this.startTime = o ?? s), this.state === "finished" && this.speed < 0 && (this.startTime += this.calculatedDuration), this.holdTime = null, this.state = "running", this.driver.start() } pause() { this.state = "paused", this.updateTime(st.now()), this.holdTime = this.currentTime } complete() { this.state !== "running" && this.play(), this.state = "finished", this.holdTime = null } finish() { var r, o; this.notifyFinished(), this.teardown(), this.state = "finished", (o = (r = this.options).onComplete) == null || o.call(r) } cancel() { var r, o; this.holdTime = null, this.startTime = 0, this.tick(0), this.teardown(), (o = (r = this.options).onCancel) == null || o.call(r) } teardown() { this.state = "idle", this.stopDriver(), this.startTime = this.holdTime = null } stopDriver() { this.driver && (this.driver.stop(), this.driver = void 0) } sample(r) { return this.startTime = 0, this.tick(r, !0) } attachTimeline(r) { var o; return this.options.allowFlatten && (this.options.type = "keyframes", this.options.ease = "linear", this.initAnimation()), (o = this.driver) == null || o.stop(), r.observe(this) } } function Uw(n) { for (let r = 1; r < n.length; r++)n[r] ?? (n[r] = n[r - 1]) } const Jn = n => n * 180 / Math.PI, fu = n => { const r = Jn(Math.atan2(n[1], n[0])); return du(r) }, $w = { x: 4, y: 5, translateX: 4, translateY: 5, scaleX: 0, scaleY: 3, scale: n => (Math.abs(n[0]) + Math.abs(n[3])) / 2, rotate: fu, rotateZ: fu, skewX: n => Jn(Math.atan(n[1])), skewY: n => Jn(Math.atan(n[2])), skew: n => (Math.abs(n[1]) + Math.abs(n[2])) / 2 }, du = n => (n = n % 360, n < 0 && (n += 360), n), Nh = fu, Dh = n => Math.sqrt(n[0] * n[0] + n[1] * n[1]), jh = n => Math.sqrt(n[4] * n[4] + n[5] * n[5]), Ww = { x: 12, y: 13, z: 14, translateX: 12, translateY: 13, translateZ: 14, scaleX: Dh, scaleY: jh, scale: n => (Dh(n) + jh(n)) / 2, rotateX: n => du(Jn(Math.atan2(n[6], n[5]))), rotateY: n => du(Jn(Math.atan2(-n[2], n[0]))), rotateZ: Nh, rotate: Nh, skewX: n => Jn(Math.atan(n[4])), skewY: n => Jn(Math.atan(n[1])), skew: n => (Math.abs(n[1]) + Math.abs(n[4])) / 2 }; function hu(n) { return n.includes("scale") ? 1 : 0 } function pu(n, r) { if (!n || n === "none") return hu(r); const o = n.match(/^matrix3d\(([-\d.e\s,]+)\)$/u); let s, l; if (o) s = Ww, l = o; else { const h = n.match(/^matrix\(([-\d.e\s,]+)\)$/u); s = $w, l = h } if (!l) return hu(r); const f = s[r], c = l[1].split(",").map(Kw); return typeof f == "function" ? f(c) : c[f] } const Hw = (n, r) => { const { transform: o = "none" } = getComputedStyle(n); return pu(o, r) }; function Kw(n) { return parseFloat(n.trim()) } const zr = ["transformPerspective", "x", "y", "z", "translateX", "translateY", "translateZ", "scale", "scaleX", "scaleY", "rotate", "rotateX", "rotateY", "rotateZ", "skew", "skewX", "skewY"], Or = new Set(zr), Vh = n => n === Fr || n === Z, Gw = new Set(["x", "y", "z"]), Yw = zr.filter(n => !Gw.has(n)); function Xw(n) { const r = []; return Yw.forEach(o => { const s = n.getValue(o); s !== void 0 && (r.push([o, s.get()]), s.set(o.startsWith("scale") ? 1 : 0)) }), r } const Ln = { width: ({ x: n }, { paddingLeft: r = "0", paddingRight: o = "0" }) => n.max - n.min - parseFloat(r) - parseFloat(o), height: ({ y: n }, { paddingTop: r = "0", paddingBottom: o = "0" }) => n.max - n.min - parseFloat(r) - parseFloat(o), top: (n, { top: r }) => parseFloat(r), left: (n, { left: r }) => parseFloat(r), bottom: ({ y: n }, { top: r }) => parseFloat(r) + (n.max - n.min), right: ({ x: n }, { left: r }) => parseFloat(r) + (n.max - n.min), x: (n, { transform: r }) => pu(r, "x"), y: (n, { transform: r }) => pu(r, "y") }; Ln.translateX = Ln.x; Ln.translateY = Ln.y; const er = new Set; let mu = !1, gu = !1, yu = !1; function Im() { if (gu) { const n = Array.from(er).filter(s => s.needsMeasurement), r = new Set(n.map(s => s.element)), o = new Map; r.forEach(s => { const l = Xw(s); l.length && (o.set(s, l), s.render()) }), n.forEach(s => s.measureInitialState()), r.forEach(s => { s.render(); const l = o.get(s); l && l.forEach(([f, c]) => { var h; (h = s.getValue(f)) == null || h.set(c) }) }), n.forEach(s => s.measureEndState()), n.forEach(s => { s.suspendedScrollY !== void 0 && window.scrollTo(0, s.suspendedScrollY) }) } gu = !1, mu = !1, er.forEach(n => n.complete(yu)), er.clear() } function Fm() { er.forEach(n => { n.readKeyframes(), n.needsMeasurement && (gu = !0) }) } function Qw() { yu = !0, Fm(), Im(), yu = !1 } class Ju { constructor(r, o, s, l, f, c = !1) { this.state = "pending", this.isAsync = !1, this.needsMeasurement = !1, this.unresolvedKeyframes = [...r], this.onComplete = o, this.name = s, this.motionValue = l, this.element = f, this.isAsync = c } scheduleResolve() { this.state = "scheduled", this.isAsync ? (er.add(this), mu || (mu = !0, ke.read(Fm), ke.resolveKeyframes(Im))) : (this.readKeyframes(), this.complete()) } readKeyframes() { const { unresolvedKeyframes: r, name: o, element: s, motionValue: l } = this; if (r[0] === null) { const f = l == null ? void 0 : l.get(), c = r[r.length - 1]; if (f !== void 0) r[0] = f; else if (s && o) { const h = s.readValue(o, c); h != null && (r[0] = h) } r[0] === void 0 && (r[0] = c), l && f === void 0 && l.set(r[0]) } Uw(r) } setFinalKeyframe() { } measureInitialState() { } renderEndStyles() { } measureEndState() { } complete(r = !1) { this.state = "complete", this.onComplete(this.unresolvedKeyframes, this.finalKeyframe, r), er.delete(this) } cancel() { this.state === "scheduled" && (er.delete(this), this.state = "pending") } resume() { this.state === "pending" && this.scheduleResolve() } } const Zw = n => n.startsWith("--"); function qw(n, r, o) { Zw(r) ? n.style.setProperty(r, o) : n.style[r] = o } const Jw = Bu(() => window.ScrollTimeline !== void 0), e1 = {}; function t1(n, r) { const o = Bu(n); return () => e1[r] ?? o() } const zm = t1(() => { try { document.createElement("div").animate({ opacity: 0 }, { easing: "linear(0, 1)" }) } catch { return !1 } return !0 }, "linearEasing"), Di = ([n, r, o, s]) => `cubic-bezier(${n}, ${r}, ${o}, ${s})`, _h = { linear: "linear", ease: "ease", easeIn: "ease-in", easeOut: "ease-out", easeInOut: "ease-in-out", circIn: Di([0, .65, .55, 1]), circOut: Di([.55, 0, 1, .45]), backIn: Di([.31, .01, .66, -.59]), backOut: Di([.33, 1.53, .69, .99]) }; function Om(n, r) { if (n) return typeof n == "function" ? zm() ? Vm(n, r) : "ease-out" : Cm(n) ? Di(n) : Array.isArray(n) ? n.map(o => Om(o, r) || _h.easeOut) : _h[n] } function n1(n, r, o, { delay: s = 0, duration: l = 300, repeat: f = 0, repeatType: c = "loop", ease: h = "easeOut", times: p } = {}, g = void 0) { const y = { [r]: o }; p && (y.offset = p); const v = Om(h, l); Array.isArray(v) && (y.easing = v); const x = { delay: s, duration: l, easing: Array.isArray(v) ? "linear" : v, fill: "both", iterations: f + 1, direction: c === "reverse" ? "alternate" : "normal" }; return g && (x.pseudoElement = g), n.animate(y, x) } function Bm(n) { return typeof n == "function" && "applyToOptions" in n } function r1({ type: n, ...r }) { return Bm(n) && zm() ? n.applyToOptions(r) : (r.duration ?? (r.duration = 300), r.ease ?? (r.ease = "easeOut"), r) } class Um extends Zu { constructor(r) { if (super(), this.finishedTime = null, this.isStopped = !1, this.manualStartTime = null, !r) return; const { element: o, name: s, keyframes: l, pseudoElement: f, allowFlatten: c = !1, finalKeyframe: h, onComplete: p } = r; this.isPseudoElement = !!f, this.allowFlatten = c, this.options = r, Ou(typeof r.type != "string"); const g = r1(r); this.animation = n1(o, s, l, g, f), g.autoplay === !1 && this.animation.pause(), this.animation.onfinish = () => { if (this.finishedTime = this.time, !f) { const y = Qu(l, this.options, h, this.speed); this.updateMotionValue ? this.updateMotionValue(y) : qw(o, s, y), this.animation.cancel() } p == null || p(), this.notifyFinished() } } play() { this.isStopped || (this.manualStartTime = null, this.animation.play(), this.state === "finished" && this.updateFinished()) } pause() { this.animation.pause() } complete() { var r, o; (o = (r = this.animation).finish) == null || o.call(r) } cancel() { try { this.animation.cancel() } catch { } } stop() { if (this.isStopped) return; this.isStopped = !0; const { state: r } = this; r === "idle" || r === "finished" || (this.updateMotionValue ? this.updateMotionValue() : this.commitStyles(), this.isPseudoElement || this.cancel()) } commitStyles() { var o, s, l; const r = (o = this.options) == null ? void 0 : o.element; !this.isPseudoElement && (r != null && r.isConnected) && ((l = (s = this.animation).commitStyles) == null || l.call(s)) } get duration() { var o, s; const r = ((s = (o = this.animation.effect) == null ? void 0 : o.getComputedTiming) == null ? void 0 : s.call(o).duration) || 0; return Et(Number(r)) } get iterationDuration() { const { delay: r = 0 } = this.options || {}; return this.duration + Et(r) } get time() { return Et(Number(this.animation.currentTime) || 0) } set time(r) { this.manualStartTime = null, this.finishedTime = null, this.animation.currentTime = bt(r) } get speed() { return this.animation.playbackRate } set speed(r) { r < 0 && (this.finishedTime = null), this.animation.playbackRate = r } get state() { return this.finishedTime !== null ? "finished" : this.animation.playState } get startTime() { return this.manualStartTime ?? Number(this.animation.startTime) } set startTime(r) { this.manualStartTime = this.animation.startTime = r } attachTimeline({ timeline: r, observe: o }) { var s; return this.allowFlatten && ((s = this.animation.effect) == null || s.updateTiming({ easing: "linear" })), this.animation.onfinish = null, r && Jw() ? (this.animation.timeline = r, Tt) : o(this) } } const $m = { anticipate: xm, backInOut: vm, circInOut: Sm }; function i1(n) { return n in $m } function o1(n) { typeof n.ease == "string" && i1(n.ease) && (n.ease = $m[n.ease]) } const Wl = 10; class s1 extends Um { constructor(r) { o1(r), bm(r), super(r), r.startTime !== void 0 && (this.startTime = r.startTime), this.options = r } updateMotionValue(r) { const { motionValue: o, onUpdate: s, onComplete: l, element: f, ...c } = this.options; if (!o) return; if (r !== void 0) { o.set(r); return } const h = new qu({ ...c, autoplay: !1 }), p = Math.max(Wl, st.now() - this.startTime), g = Kt(0, Wl, p - Wl); o.setWithVelocity(h.sample(Math.max(0, p - g)).value, h.sample(p).value, g), h.stop() } } const bh = (n, r) => r === "zIndex" ? !1 : !!(typeof n == "number" || Array.isArray(n) || typeof n == "string" && (Dn.test(n) || n === "0") && !n.startsWith("url(")); function a1(n) { const r = n[0]; if (n.length === 1) return !0; for (let o = 0; o < n.length; o++)if (n[o] !== r) return !0 } function l1(n, r, o, s) { const l = n[0]; if (l === null) return !1; if (r === "display" || r === "visibility") return !0; const f = n[n.length - 1], c = bh(l, r), h = bh(f, r); return !c || !h ? !1 : a1(n) || (o === "spring" || Bm(o)) && s } function vu(n) { n.duration = 0, n.type = "keyframes" } const u1 = new Set(["opacity", "clipPath", "filter", "transform"]), c1 = Bu(() => Object.hasOwnProperty.call(Element.prototype, "animate")); function f1(n) { var y; const { motionValue: r, name: o, repeatDelay: s, repeatType: l, damping: f, type: c } = n; if (!(((y = r == null ? void 0 : r.owner) == null ? void 0 : y.current) instanceof HTMLElement)) return !1; const { onUpdate: p, transformTemplate: g } = r.owner.getProps(); return c1() && o && u1.has(o) && (o !== "transform" || !g) && !p && !s && l !== "mirror" && f !== 0 && c !== "inertia" } const d1 = 40; class h1 extends Zu { constructor({ autoplay: r = !0, delay: o = 0, type: s = "keyframes", repeat: l = 0, repeatDelay: f = 0, repeatType: c = "loop", keyframes: h, name: p, motionValue: g, element: y, ...v }) { var M; super(), this.stop = () => { var N, A; this._animation && (this._animation.stop(), (N = this.stopTimeline) == null || N.call(this)), (A = this.keyframeResolver) == null || A.cancel() }, this.createdAt = st.now(); const x = { autoplay: r, delay: o, type: s, repeat: l, repeatDelay: f, repeatType: c, name: p, motionValue: g, element: y, ...v }, C = (y == null ? void 0 : y.KeyframeResolver) || Ju; this.keyframeResolver = new C(h, (N, A, V) => this.onKeyframesResolved(N, A, x, !V), p, g, y), (M = this.keyframeResolver) == null || M.scheduleResolve() } onKeyframesResolved(r, o, s, l) { var A, V; this.keyframeResolver = void 0; const { name: f, type: c, velocity: h, delay: p, isHandoff: g, onUpdate: y } = s; this.resolvedAt = st.now(), l1(r, f, c, h) || ((on.instantAnimations || !p) && (y == null || y(Qu(r, s, o))), r[0] = r[r.length - 1], vu(s), s.repeat = 0); const x = { startTime: l ? this.resolvedAt ? this.resolvedAt - this.createdAt > d1 ? this.resolvedAt : this.createdAt : this.createdAt : void 0, finalKeyframe: o, ...s, keyframes: r }, C = !g && f1(x), M = (V = (A = x.motionValue) == null ? void 0 : A.owner) == null ? void 0 : V.current, N = C ? new s1({ ...x, element: M }) : new qu(x); N.finished.then(() => { this.notifyFinished() }).catch(Tt), this.pendingTimeline && (this.stopTimeline = N.attachTimeline(this.pendingTimeline), this.pendingTimeline = void 0), this._animation = N } get finished() { return this._animation ? this.animation.finished : this._finished } then(r, o) { return this.finished.finally(r).then(() => { }) } get animation() { var r; return this._animation || ((r = this.keyframeResolver) == null || r.resume(), Qw()), this._animation } get duration() { return this.animation.duration } get iterationDuration() { return this.animation.iterationDuration } get time() { return this.animation.time } set time(r) { this.animation.time = r } get speed() { return this.animation.speed } get state() { return this.animation.state } set speed(r) { this.animation.speed = r } get startTime() { return this.animation.startTime } attachTimeline(r) { return this._animation ? this.stopTimeline = this.animation.attachTimeline(r) : this.pendingTimeline = r, () => this.stop() } play() { this.animation.play() } pause() { this.animation.pause() } complete() { this.animation.complete() } cancel() { var r; this._animation && this.animation.cancel(), (r = this.keyframeResolver) == null || r.cancel() } } function Wm(n, r, o, s = 0, l = 1) { const f = Array.from(n).sort((g, y) => g.sortNodePosition(y)).indexOf(r), c = n.size, h = (c - 1) * s; return typeof o == "function" ? o(f, c) : l === 1 ? f * s : h - f * s } const p1 = /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u; function m1(n) { const r = p1.exec(n); if (!r) return [,]; const [, o, s, l] = r; return [`--${o ?? s}`, l] } function Hm(n, r, o = 1) { const [s, l] = m1(n); if (!s) return; const f = window.getComputedStyle(r).getPropertyValue(s); if (f) { const c = f.trim(); return cm(c) ? parseFloat(c) : c } return Hu(l) ? Hm(l, r, o + 1) : l } const g1 = { type: "spring", stiffness: 500, damping: 25, restSpeed: 10 }, y1 = n => ({ type: "spring", stiffness: 550, damping: n === 0 ? 2 * Math.sqrt(550) : 30, restSpeed: 10 }), v1 = { type: "keyframes", duration: .8 }, x1 = { type: "keyframes", ease: [.25, .1, .35, 1], duration: .3 }, w1 = (n, { keyframes: r }) => r.length > 2 ? v1 : Or.has(n) ? n.startsWith("scale") ? y1(r[1]) : g1 : x1, S1 = n => n !== null; function k1(n, { repeat: r, repeatType: o = "loop" }, s) { const l = n.filter(S1), f = r && o !== "loop" && r % 2 === 1 ? 0 : l.length - 1; return l[f] } function Km(n, r) { if (n != null && n.inherit && r) { const { inherit: o, ...s } = n; return { ...r, ...s } } return n } function ec(n, r) { const o = (n == null ? void 0 : n[r]) ?? (n == null ? void 0 : n.default) ?? n; return o !== n ? Km(o, n) : o } function C1({ when: n, delay: r, delayChildren: o, staggerChildren: s, staggerDirection: l, repeat: f, repeatType: c, repeatDelay: h, from: p, elapsed: g, ...y }) { return !!Object.keys(y).length } const tc = (n, r, o, s = {}, l, f) => c => { const h = ec(s, n) || {}, p = h.delay || s.delay || 0; let { elapsed: g = 0 } = s; g = g - bt(p); const y = { keyframes: Array.isArray(o) ? o : [null, o], ease: "easeOut", velocity: r.getVelocity(), ...h, delay: -g, onUpdate: x => { r.set(x), h.onUpdate && h.onUpdate(x) }, onComplete: () => { c(), h.onComplete && h.onComplete() }, name: n, motionValue: r, element: f ? void 0 : l }; C1(h) || Object.assign(y, w1(n, y)), y.duration && (y.duration = bt(y.duration)), y.repeatDelay && (y.repeatDelay = bt(y.repeatDelay)), y.from !== void 0 && (y.keyframes[0] = y.from); let v = !1; if ((y.type === !1 || y.duration === 0 && !y.repeatDelay) && (vu(y), y.delay === 0 && (v = !0)), (on.instantAnimations || on.skipAnimations || l != null && l.shouldSkipAnimations) && (v = !0, vu(y), y.delay = 0), y.allowFlatten = !h.type && !h.ease, v && !f && r.get() !== void 0) { const x = k1(y.keyframes, h); if (x !== void 0) { ke.update(() => { y.onUpdate(x), y.onComplete() }); return } } return h.isSync ? new qu(y) : new h1(y) }; function Ih(n) { const r = [{}, {}]; return n == null || n.values.forEach((o, s) => { r[0][s] = o.get(), r[1][s] = o.getVelocity() }), r } function nc(n, r, o, s) { if (typeof r == "function") { const [l, f] = Ih(s); r = r(o !== void 0 ? o : n.custom, l, f) } if (typeof r == "string" && (r = n.variants && n.variants[r]), typeof r == "function") { const [l, f] = Ih(s); r = r(o !== void 0 ? o : n.custom, l, f) } return r } function Vr(n, r, o) { const s = n.getProps(); return nc(s, r, o !== void 0 ? o : s.custom, n) } const Gm = new Set(["width", "height", "top", "left", "right", "bottom", ...zr]), Fh = 30, E1 = n => !isNaN(parseFloat(n)); class T1 { constructor(r, o = {}) { this.canTrackVelocity = null, this.events = {}, this.updateAndNotify = s => { var f; const l = st.now(); if (this.updatedAt !== l && this.setPrevFrameValue(), this.prev = this.current, this.setCurrent(s), this.current !== this.prev && ((f = this.events.change) == null || f.notify(this.current), this.dependents)) for (const c of this.dependents) c.dirty() }, this.hasAnimated = !1, this.setCurrent(r), this.owner = o.owner } setCurrent(r) { this.current = r, this.updatedAt = st.now(), this.canTrackVelocity === null && r !== void 0 && (this.canTrackVelocity = E1(this.current)) } setPrevFrameValue(r = this.current) { this.prevFrameValue = r, this.prevUpdatedAt = this.updatedAt } onChange(r) { return this.on("change", r) } on(r, o) { this.events[r] || (this.events[r] = new Uu); const s = this.events[r].add(o); return r === "change" ? () => { s(), ke.read(() => { this.events.change.getSize() || this.stop() }) } : s } clearListeners() { for (const r in this.events) this.events[r].clear() } attach(r, o) { this.passiveEffect = r, this.stopPassiveEffect = o } set(r) { this.passiveEffect ? this.passiveEffect(r, this.updateAndNotify) : this.updateAndNotify(r) } setWithVelocity(r, o, s) { this.set(o), this.prev = void 0, this.prevFrameValue = r, this.prevUpdatedAt = this.updatedAt - s } jump(r, o = !0) { this.updateAndNotify(r), this.prev = r, this.prevUpdatedAt = this.prevFrameValue = void 0, o && this.stop(), this.stopPassiveEffect && this.stopPassiveEffect() } dirty() { var r; (r = this.events.change) == null || r.notify(this.current) } addDependent(r) { this.dependents || (this.dependents = new Set), this.dependents.add(r) } removeDependent(r) { this.dependents && this.dependents.delete(r) } get() { return this.current } getPrevious() { return this.prev } getVelocity() { const r = st.now(); if (!this.canTrackVelocity || this.prevFrameValue === void 0 || r - this.updatedAt > Fh) return 0; const o = Math.min(this.updatedAt - this.prevUpdatedAt, Fh); return hm(parseFloat(this.current) - parseFloat(this.prevFrameValue), o) } start(r) { return this.stop(), new Promise(o => { this.hasAnimated = !0, this.animation = r(o), this.events.animationStart && this.events.animationStart.notify() }).then(() => { this.events.animationComplete && this.events.animationComplete.notify(), this.clearAnimation() }) } stop() { this.animation && (this.animation.stop(), this.events.animationCancel && this.events.animationCancel.notify()), this.clearAnimation() } isAnimating() { return !!this.animation } clearAnimation() { delete this.animation } destroy() { var r, o; (r = this.dependents) == null || r.clear(), (o = this.events.destroy) == null || o.notify(), this.clearListeners(), this.stop(), this.stopPassiveEffect && this.stopPassiveEffect() } } function _r(n, r) { return new T1(n, r) } const xu = n => Array.isArray(n); function P1(n, r, o) { n.hasValue(r) ? n.getValue(r).set(o) : n.addValue(r, _r(o)) } function R1(n) { return xu(n) ? n[n.length - 1] || 0 : n } function M1(n, r) { const o = Vr(n, r); let { transitionEnd: s = {}, transition: l = {}, ...f } = o || {}; f = { ...f, ...s }; for (const c in f) { const h = R1(f[c]); P1(n, c, h) } } const rt = n => !!(n && n.getVelocity); function A1(n) { return !!(rt(n) && n.add) } function wu(n, r) { const o = n.getValue("willChange"); if (A1(o)) return o.add(r); if (!o && on.WillChange) { const s = new on.WillChange("auto"); n.addValue("willChange", s), s.add(r) } } function rc(n) { return n.replace(/([A-Z])/g, r => `-${r.toLowerCase()}`) } const L1 = "framerAppearId", Ym = "data-" + rc(L1); function Xm(n) { return n.props[Ym] } function N1({ protectedKeys: n, needsAnimating: r }, o) { const s = n.hasOwnProperty(o) && r[o] !== !0; return r[o] = !1, s } function Qm(n, r, { delay: o = 0, transitionOverride: s, type: l } = {}) { let { transition: f, transitionEnd: c, ...h } = r; const p = n.getDefaultTransition(); f = f ? Km(f, p) : p; const g = f == null ? void 0 : f.reduceMotion; s && (f = s); const y = [], v = l && n.animationState && n.animationState.getState()[l]; for (const x in h) { const C = n.getValue(x, n.latestValues[x] ?? null), M = h[x]; if (M === void 0 || v && N1(v, x)) continue; const N = { delay: o, ...ec(f || {}, x) }, A = C.get(); if (A !== void 0 && !C.isAnimating && !Array.isArray(M) && M === A && !N.velocity) continue; let V = !1; if (window.MotionHandoffAnimation) { const W = Xm(n); if (W) { const U = window.MotionHandoffAnimation(W, x, ke); U !== null && (N.startTime = U, V = !0) } } wu(n, x); const b = g ?? n.shouldReduceMotion; C.start(tc(x, C, M, b && Gm.has(x) ? { type: !1 } : N, n, V)); const j = C.animation; j && y.push(j) } if (c) { const x = () => ke.update(() => { c && M1(n, c) }); y.length ? Promise.all(y).then(x) : x() } return y } function Su(n, r, o = {}) { var p; const s = Vr(n, r, o.type === "exit" ? (p = n.presenceContext) == null ? void 0 : p.custom : void 0); let { transition: l = n.getDefaultTransition() || {} } = s || {}; o.transitionOverride && (l = o.transitionOverride); const f = s ? () => Promise.all(Qm(n, s, o)) : () => Promise.resolve(), c = n.variantChildren && n.variantChildren.size ? (g = 0) => { const { delayChildren: y = 0, staggerChildren: v, staggerDirection: x } = l; return D1(n, r, g, y, v, x, o) } : () => Promise.resolve(), { when: h } = l; if (h) { const [g, y] = h === "beforeChildren" ? [f, c] : [c, f]; return g().then(() => y()) } else return Promise.all([f(), c(o.delay)]) } function D1(n, r, o = 0, s = 0, l = 0, f = 1, c) { const h = []; for (const p of n.variantChildren) p.notify("AnimationStart", r), h.push(Su(p, r, { ...c, delay: o + (typeof s == "function" ? 0 : s) + Wm(n.variantChildren, p, s, l, f) }).then(() => p.notify("AnimationComplete", r))); return Promise.all(h) } function j1(n, r, o = {}) { n.notify("AnimationStart", r); let s; if (Array.isArray(r)) { const l = r.map(f => Su(n, f, o)); s = Promise.all(l) } else if (typeof r == "string") s = Su(n, r, o); else { const l = typeof r == "function" ? Vr(n, r, o.custom) : r; s = Promise.all(Qm(n, l, o)) } return s.then(() => { n.notify("AnimationComplete", r) }) } const V1 = { test: n => n === "auto", parse: n => n }, Zm = n => r => r.test(n), qm = [Fr, Z, Wt, Mn, lw, aw, V1], zh = n => qm.find(Zm(n)); function _1(n) { return typeof n == "number" ? n === 0 : n !== null ? n === "none" || n === "0" || dm(n) : !0 } const b1 = new Set(["brightness", "contrast", "saturate", "opacity"]); function I1(n) { const [r, o] = n.slice(0, -1).split("("); if (r === "drop-shadow") return n; const [s] = o.match(Ku) || []; if (!s) return n; const l = o.replace(s, ""); let f = b1.has(r) ? 1 : 0; return s !== o && (f *= 100), r + "(" + f + l + ")" } const F1 = /\b([a-z-]*)\(.*?\)/gu, ku = { ...Dn, getAnimatableNone: n => { const r = n.match(F1); return r ? r.map(I1).join(" ") : n } }, Oh = { ...Fr, transform: Math.round }, z1 = { rotate: Mn, rotateX: Mn, rotateY: Mn, rotateZ: Mn, scale: cs, scaleX: cs, scaleY: cs, scaleZ: cs, skew: Mn, skewX: Mn, skewY: Mn, distance: Z, translateX: Z, translateY: Z, translateZ: Z, x: Z, y: Z, z: Z, perspective: Z, transformPerspective: Z, opacity: Oi, originX: Ph, originY: Ph, originZ: Z }, ic = { borderWidth: Z, borderTopWidth: Z, borderRightWidth: Z, borderBottomWidth: Z, borderLeftWidth: Z, borderRadius: Z, borderTopLeftRadius: Z, borderTopRightRadius: Z, borderBottomRightRadius: Z, borderBottomLeftRadius: Z, width: Z, maxWidth: Z, height: Z, maxHeight: Z, top: Z, right: Z, bottom: Z, left: Z, inset: Z, insetBlock: Z, insetBlockStart: Z, insetBlockEnd: Z, insetInline: Z, insetInlineStart: Z, insetInlineEnd: Z, padding: Z, paddingTop: Z, paddingRight: Z, paddingBottom: Z, paddingLeft: Z, paddingBlock: Z, paddingBlockStart: Z, paddingBlockEnd: Z, paddingInline: Z, paddingInlineStart: Z, paddingInlineEnd: Z, margin: Z, marginTop: Z, marginRight: Z, marginBottom: Z, marginLeft: Z, marginBlock: Z, marginBlockStart: Z, marginBlockEnd: Z, marginInline: Z, marginInlineStart: Z, marginInlineEnd: Z, fontSize: Z, backgroundPositionX: Z, backgroundPositionY: Z, ...z1, zIndex: Oh, fillOpacity: Oi, strokeOpacity: Oi, numOctaves: Oh }, O1 = { ...ic, color: Ie, backgroundColor: Ie, outlineColor: Ie, fill: Ie, stroke: Ie, borderColor: Ie, borderTopColor: Ie, borderRightColor: Ie, borderBottomColor: Ie, borderLeftColor: Ie, filter: ku, WebkitFilter: ku }, Jm = n => O1[n]; function eg(n, r) { let o = Jm(n); return o !== ku && (o = Dn), o.getAnimatableNone ? o.getAnimatableNone(r) : void 0 } const B1 = new Set(["auto", "none", "0"]); function U1(n, r, o) { let s = 0, l; for (; s < n.length && !l;) { const f = n[s]; typeof f == "string" && !B1.has(f) && Bi(f).values.length && (l = n[s]), s++ } if (l && o) for (const f of r) n[f] = eg(o, l) } class $1 extends Ju { constructor(r, o, s, l, f) { super(r, o, s, l, f, !0) } readKeyframes() { const { unresolvedKeyframes: r, element: o, name: s } = this; if (!o || !o.current) return; super.readKeyframes(); for (let y = 0; y < r.length; y++) { let v = r[y]; if (typeof v == "string" && (v = v.trim(), Hu(v))) { const x = Hm(v, o.current); x !== void 0 && (r[y] = x), y === r.length - 1 && (this.finalKeyframe = v) } } if (this.resolveNoneKeyframes(), !Gm.has(s) || r.length !== 2) return; const [l, f] = r, c = zh(l), h = zh(f), p = Th(l), g = Th(f); if (p !== g && Ln[s]) { this.needsMeasurement = !0; return } if (c !== h) if (Vh(c) && Vh(h)) for (let y = 0; y < r.length; y++) { const v = r[y]; typeof v == "string" && (r[y] = parseFloat(v)) } else Ln[s] && (this.needsMeasurement = !0) } resolveNoneKeyframes() { const { unresolvedKeyframes: r, name: o } = this, s = []; for (let l = 0; l < r.length; l++)(r[l] === null || _1(r[l])) && s.push(l); s.length && U1(r, s, o) } measureInitialState() { const { element: r, unresolvedKeyframes: o, name: s } = this; if (!r || !r.current) return; s === "height" && (this.suspendedScrollY = window.pageYOffset), this.measuredOrigin = Ln[s](r.measureViewportBox(), window.getComputedStyle(r.current)), o[0] = this.measuredOrigin; const l = o[o.length - 1]; l !== void 0 && r.getValue(s, l).jump(l, !1) } measureEndState() { var h; const { element: r, name: o, unresolvedKeyframes: s } = this; if (!r || !r.current) return; const l = r.getValue(o); l && l.jump(this.measuredOrigin, !1); const f = s.length - 1, c = s[f]; s[f] = Ln[o](r.measureViewportBox(), window.getComputedStyle(r.current)), c !== null && this.finalKeyframe === void 0 && (this.finalKeyframe = c), (h = this.removedTransforms) != null && h.length && this.removedTransforms.forEach(([p, g]) => { r.getValue(p).set(g) }), this.resolveNoneKeyframes() } } const W1 = new Set(["opacity", "clipPath", "filter", "transform"]); function tg(n, r, o) { if (n == null) return []; if (n instanceof EventTarget) return [n]; if (typeof n == "string") { let s = document; const l = (o == null ? void 0 : o[n]) ?? s.querySelectorAll(n); return l ? Array.from(l) : [] } return Array.from(n).filter(s => s != null) } const ng = (n, r) => r && typeof n == "number" ? r.transform(n) : n; function H1(n) { return fm(n) && "offsetHeight" in n } const { schedule: oc } = Em(queueMicrotask, !1), _t = { x: !1, y: !1 }; function rg() { return _t.x || _t.y } function K1(n) { return n === "x" || n === "y" ? _t[n] ? null : (_t[n] = !0, () => { _t[n] = !1 }) : _t.x || _t.y ? null : (_t.x = _t.y = !0, () => { _t.x = _t.y = !1 }) } function ig(n, r) { const o = tg(n), s = new AbortController, l = { passive: !0, ...r, signal: s.signal }; return [o, l, () => s.abort()] } function G1(n) { return !(n.pointerType === "touch" || rg()) } function Y1(n, r, o = {}) { const [s, l, f] = ig(n, o); return s.forEach(c => { let h = !1, p = !1, g; const y = () => { c.removeEventListener("pointerleave", M) }, v = A => { g && (g(A), g = void 0), y() }, x = A => { h = !1, window.removeEventListener("pointerup", x), window.removeEventListener("pointercancel", x), p && (p = !1, v(A)) }, C = () => { h = !0, window.addEventListener("pointerup", x, l), window.addEventListener("pointercancel", x, l) }, M = A => { if (A.pointerType !== "touch") { if (h) { p = !0; return } v(A) } }, N = A => { if (!G1(A)) return; p = !1; const V = r(c, A); typeof V == "function" && (g = V, c.addEventListener("pointerleave", M, l)) }; c.addEventListener("pointerenter", N, l), c.addEventListener("pointerdown", C, l) }), f } const og = (n, r) => r ? n === r ? !0 : og(n, r.parentElement) : !1, sc = n => n.pointerType === "mouse" ? typeof n.button != "number" || n.button <= 0 : n.isPrimary !== !1, X1 = new Set(["BUTTON", "INPUT", "SELECT", "TEXTAREA", "A"]); function Q1(n) { return X1.has(n.tagName) || n.isContentEditable === !0 } const Z1 = new Set(["INPUT", "SELECT", "TEXTAREA"]); function q1(n) { return Z1.has(n.tagName) || n.isContentEditable === !0 } const ys = new WeakSet; function Bh(n) { return r => { r.key === "Enter" && n(r) } } function Hl(n, r) { n.dispatchEvent(new PointerEvent("pointer" + r, { isPrimary: !0, bubbles: !0 })) } const J1 = (n, r) => { const o = n.currentTarget; if (!o) return; const s = Bh(() => { if (ys.has(o)) return; Hl(o, "down"); const l = Bh(() => { Hl(o, "up") }), f = () => Hl(o, "cancel"); o.addEventListener("keyup", l, r), o.addEventListener("blur", f, r) }); o.addEventListener("keydown", s, r), o.addEventListener("blur", () => o.removeEventListener("keydown", s), r) }; function Uh(n) { return sc(n) && !rg() } const $h = new WeakSet; function eS(n, r, o = {}) { const [s, l, f] = ig(n, o), c = h => { const p = h.currentTarget; if (!Uh(h) || $h.has(h)) return; ys.add(p), o.stopPropagation && $h.add(h); const g = r(p, h), y = (C, M) => { window.removeEventListener("pointerup", v), window.removeEventListener("pointercancel", x), ys.has(p) && ys.delete(p), Uh(C) && typeof g == "function" && g(C, { success: M }) }, v = C => { y(C, p === window || p === document || o.useGlobalTarget || og(p, C.target)) }, x = C => { y(C, !1) }; window.addEventListener("pointerup", v, l), window.addEventListener("pointercancel", x, l) }; return s.forEach(h => { (o.useGlobalTarget ? window : h).addEventListener("pointerdown", c, l), H1(h) && (h.addEventListener("focus", g => J1(g, l)), !Q1(h) && !h.hasAttribute("tabindex") && (h.tabIndex = 0)) }), f } function ac(n) { return fm(n) && "ownerSVGElement" in n } const vs = new WeakMap; let An; const sg = (n, r, o) => (s, l) => l && l[0] ? l[0][n + "Size"] : ac(s) && "getBBox" in s ? s.getBBox()[r] : s[o], tS = sg("inline", "width", "offsetWidth"), nS = sg("block", "height", "offsetHeight"); function rS({ target: n, borderBoxSize: r }) { var o; (o = vs.get(n)) == null || o.forEach(s => { s(n, { get width() { return tS(n, r) }, get height() { return nS(n, r) } }) }) } function iS(n) { n.forEach(rS) } function oS() { typeof ResizeObserver > "u" || (An = new ResizeObserver(iS)) } function sS(n, r) { An || oS(); const o = tg(n); return o.forEach(s => { let l = vs.get(s); l || (l = new Set, vs.set(s, l)), l.add(r), An == null || An.observe(s) }), () => { o.forEach(s => { const l = vs.get(s); l == null || l.delete(r), l != null && l.size || An == null || An.unobserve(s) }) } } const xs = new Set; let Lr; function aS() { Lr = () => { const n = { get width() { return window.innerWidth }, get height() { return window.innerHeight } }; xs.forEach(r => r(n)) }, window.addEventListener("resize", Lr) } function lS(n) { return xs.add(n), Lr || aS(), () => { xs.delete(n), !xs.size && typeof Lr == "function" && (window.removeEventListener("resize", Lr), Lr = void 0) } } function Wh(n, r) { return typeof n == "function" ? lS(n) : sS(n, r) } function uS(n) { return ac(n) && n.tagName === "svg" } const cS = [...qm, Ie, Dn], fS = n => cS.find(Zm(n)), Hh = () => ({ translate: 0, scale: 1, origin: 0, originPoint: 0 }), Nr = () => ({ x: Hh(), y: Hh() }), Kh = () => ({ min: 0, max: 0 }), Be = () => ({ x: Kh(), y: Kh() }), dS = new WeakMap; function Vs(n) { return n !== null && typeof n == "object" && typeof n.start == "function" } function Ui(n) { return typeof n == "string" || Array.isArray(n) } const lc = ["animate", "whileInView", "whileFocus", "whileHover", "whileTap", "whileDrag", "exit"], uc = ["initial", ...lc]; function _s(n) { return Vs(n.animate) || uc.some(r => Ui(n[r])) } function ag(n) { return !!(_s(n) || n.variants) } function hS(n, r, o) { for (const s in r) { const l = r[s], f = o[s]; if (rt(l)) n.addValue(s, l); else if (rt(f)) n.addValue(s, _r(l, { owner: n })); else if (f !== l) if (n.hasValue(s)) { const c = n.getValue(s); c.liveStyle === !0 ? c.jump(l) : c.hasAnimated || c.set(l) } else { const c = n.getStaticValue(s); n.addValue(s, _r(c !== void 0 ? c : l, { owner: n })) } } for (const s in o) r[s] === void 0 && n.removeValue(s); return r } const Cu = { current: null }, lg = { current: !1 }, pS = typeof window < "u"; function mS() { if (lg.current = !0, !!pS) if (window.matchMedia) { const n = window.matchMedia("(prefers-reduced-motion)"), r = () => Cu.current = n.matches; n.addEventListener("change", r), r() } else Cu.current = !1 } const Gh = ["AnimationStart", "AnimationComplete", "Update", "BeforeLayoutMeasure", "LayoutMeasure", "LayoutAnimationStart", "LayoutAnimationComplete"]; let Rs = {}; function ug(n) { Rs = n } function gS() { return Rs } class yS { scrapeMotionValuesFromProps(r, o, s) { return {} } constructor({ parent: r, props: o, presenceContext: s, reducedMotionConfig: l, skipAnimations: f, blockInitialAnimation: c, visualState: h }, p = {}) { this.current = null, this.children = new Set, this.isVariantNode = !1, this.isControllingVariants = !1, this.shouldReduceMotion = null, this.shouldSkipAnimations = !1, this.values = new Map, this.KeyframeResolver = Ju, this.features = {}, this.valueSubscriptions = new Map, this.prevMotionValues = {}, this.hasBeenMounted = !1, this.events = {}, this.propEventSubscriptions = {}, this.notifyUpdate = () => this.notify("Update", this.latestValues), this.render = () => { this.current && (this.triggerBuild(), this.renderInstance(this.current, this.renderState, this.props.style, this.projection)) }, this.renderScheduledAt = 0, this.scheduleRender = () => { const C = st.now(); this.renderScheduledAt < C && (this.renderScheduledAt = C, ke.render(this.render, !1, !0)) }; const { latestValues: g, renderState: y } = h; this.latestValues = g, this.baseTarget = { ...g }, this.initialValues = o.initial ? { ...g } : {}, this.renderState = y, this.parent = r, this.props = o, this.presenceContext = s, this.depth = r ? r.depth + 1 : 0, this.reducedMotionConfig = l, this.skipAnimationsConfig = f, this.options = p, this.blockInitialAnimation = !!c, this.isControllingVariants = _s(o), this.isVariantNode = ag(o), this.isVariantNode && (this.variantChildren = new Set), this.manuallyAnimateOnMount = !!(r && r.current); const { willChange: v, ...x } = this.scrapeMotionValuesFromProps(o, {}, this); for (const C in x) { const M = x[C]; g[C] !== void 0 && rt(M) && M.set(g[C]) } } mount(r) { var o, s; if (this.hasBeenMounted) for (const l in this.initialValues) (o = this.values.get(l)) == null || o.jump(this.initialValues[l]), this.latestValues[l] = this.initialValues[l]; this.current = r, dS.set(r, this), this.projection && !this.projection.instance && this.projection.mount(r), this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)), this.values.forEach((l, f) => this.bindToMotionValue(f, l)), this.reducedMotionConfig === "never" ? this.shouldReduceMotion = !1 : this.reducedMotionConfig === "always" ? this.shouldReduceMotion = !0 : (lg.current || mS(), this.shouldReduceMotion = Cu.current), this.shouldSkipAnimations = this.skipAnimationsConfig ?? !1, (s = this.parent) == null || s.addChild(this), this.update(this.props, this.presenceContext), this.hasBeenMounted = !0 } unmount() { var r; this.projection && this.projection.unmount(), Nn(this.notifyUpdate), Nn(this.render), this.valueSubscriptions.forEach(o => o()), this.valueSubscriptions.clear(), this.removeFromVariantTree && this.removeFromVariantTree(), (r = this.parent) == null || r.removeChild(this); for (const o in this.events) this.events[o].clear(); for (const o in this.features) { const s = this.features[o]; s && (s.unmount(), s.isMounted = !1) } this.current = null } addChild(r) { this.children.add(r), this.enteringChildren ?? (this.enteringChildren = new Set), this.enteringChildren.add(r) } removeChild(r) { this.children.delete(r), this.enteringChildren && this.enteringChildren.delete(r) } bindToMotionValue(r, o) { if (this.valueSubscriptions.has(r) && this.valueSubscriptions.get(r)(), o.accelerate && W1.has(r) && this.current instanceof HTMLElement) { const { factory: c, keyframes: h, times: p, ease: g, duration: y } = o.accelerate, v = new Um({ element: this.current, name: r, keyframes: h, times: p, ease: g, duration: bt(y) }), x = c(v); this.valueSubscriptions.set(r, () => { x(), v.cancel() }); return } const s = Or.has(r); s && this.onBindTransform && this.onBindTransform(); const l = o.on("change", c => { this.latestValues[r] = c, this.props.onUpdate && ke.preRender(this.notifyUpdate), s && this.projection && (this.projection.isTransformDirty = !0), this.scheduleRender() }); let f; typeof window < "u" && window.MotionCheckAppearSync && (f = window.MotionCheckAppearSync(this, r, o)), this.valueSubscriptions.set(r, () => { l(), f && f(), o.owner && o.stop() }) } sortNodePosition(r) { return !this.current || !this.sortInstanceNodePosition || this.type !== r.type ? 0 : this.sortInstanceNodePosition(this.current, r.current) } updateFeatures() { let r = "animation"; for (r in Rs) { const o = Rs[r]; if (!o) continue; const { isEnabled: s, Feature: l } = o; if (!this.features[r] && l && s(this.props) && (this.features[r] = new l(this)), this.features[r]) { const f = this.features[r]; f.isMounted ? f.update() : (f.mount(), f.isMounted = !0) } } } triggerBuild() { this.build(this.renderState, this.latestValues, this.props) } measureViewportBox() { return this.current ? this.measureInstanceViewportBox(this.current, this.props) : Be() } getStaticValue(r) { return this.latestValues[r] } setStaticValue(r, o) { this.latestValues[r] = o } update(r, o) { (r.transformTemplate || this.props.transformTemplate) && this.scheduleRender(), this.prevProps = this.props, this.props = r, this.prevPresenceContext = this.presenceContext, this.presenceContext = o; for (let s = 0; s < Gh.length; s++) { const l = Gh[s]; this.propEventSubscriptions[l] && (this.propEventSubscriptions[l](), delete this.propEventSubscriptions[l]); const f = "on" + l, c = r[f]; c && (this.propEventSubscriptions[l] = this.on(l, c)) } this.prevMotionValues = hS(this, this.scrapeMotionValuesFromProps(r, this.prevProps || {}, this), this.prevMotionValues), this.handleChildMotionValue && this.handleChildMotionValue() } getProps() { return this.props } getVariant(r) { return this.props.variants ? this.props.variants[r] : void 0 } getDefaultTransition() { return this.props.transition } getTransformPagePoint() { return this.props.transformPagePoint } getClosestVariantNode() { return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0 } addVariantChild(r) { const o = this.getClosestVariantNode(); if (o) return o.variantChildren && o.variantChildren.add(r), () => o.variantChildren.delete(r) } addValue(r, o) { const s = this.values.get(r); o !== s && (s && this.removeValue(r), this.bindToMotionValue(r, o), this.values.set(r, o), this.latestValues[r] = o.get()) } removeValue(r) { this.values.delete(r); const o = this.valueSubscriptions.get(r); o && (o(), this.valueSubscriptions.delete(r)), delete this.latestValues[r], this.removeValueFromRenderState(r, this.renderState) } hasValue(r) { return this.values.has(r) } getValue(r, o) { if (this.props.values && this.props.values[r]) return this.props.values[r]; let s = this.values.get(r); return s === void 0 && o !== void 0 && (s = _r(o === null ? void 0 : o, { owner: this }), this.addValue(r, s)), s } readValue(r, o) { let s = this.latestValues[r] !== void 0 || !this.current ? this.latestValues[r] : this.getBaseTargetFromProps(this.props, r) ?? this.readValueFromInstance(this.current, r, this.options); return s != null && (typeof s == "string" && (cm(s) || dm(s)) ? s = parseFloat(s) : !fS(s) && Dn.test(o) && (s = eg(r, o)), this.setBaseTarget(r, rt(s) ? s.get() : s)), rt(s) ? s.get() : s } setBaseTarget(r, o) { this.baseTarget[r] = o } getBaseTarget(r) { var f; const { initial: o } = this.props; let s; if (typeof o == "string" || typeof o == "object") { const c = nc(this.props, o, (f = this.presenceContext) == null ? void 0 : f.custom); c && (s = c[r]) } if (o && s !== void 0) return s; const l = this.getBaseTargetFromProps(this.props, r); return l !== void 0 && !rt(l) ? l : this.initialValues[r] !== void 0 && s === void 0 ? void 0 : this.baseTarget[r] } on(r, o) { return this.events[r] || (this.events[r] = new Uu), this.events[r].add(o) } notify(r, ...o) { this.events[r] && this.events[r].notify(...o) } scheduleRenderMicrotask() { oc.render(this.render) } } class cg extends yS { constructor() { super(...arguments), this.KeyframeResolver = $1 } sortInstanceNodePosition(r, o) { return r.compareDocumentPosition(o) & 2 ? 1 : -1 } getBaseTargetFromProps(r, o) { const s = r.style; return s ? s[o] : void 0 } removeValueFromRenderState(r, { vars: o, style: s }) { delete o[r], delete s[r] } handleChildMotionValue() { this.childSubscription && (this.childSubscription(), delete this.childSubscription); const { children: r } = this.props; rt(r) && (this.childSubscription = r.on("change", o => { this.current && (this.current.textContent = `${o}`) })) } } class jn { constructor(r) { this.isMounted = !1, this.node = r } update() { } } function fg({ top: n, left: r, right: o, bottom: s }) { return { x: { min: r, max: o }, y: { min: n, max: s } } } function vS({ x: n, y: r }) { return { top: r.min, right: n.max, bottom: r.max, left: n.min } } function xS(n, r) { if (!r) return n; const o = r({ x: n.left, y: n.top }), s = r({ x: n.right, y: n.bottom }); return { top: o.y, left: o.x, bottom: s.y, right: s.x } } function Kl(n) { return n === void 0 || n === 1 } function Eu({ scale: n, scaleX: r, scaleY: o }) { return !Kl(n) || !Kl(r) || !Kl(o) } function Zn(n) { return Eu(n) || dg(n) || n.z || n.rotate || n.rotateX || n.rotateY || n.skewX || n.skewY } function dg(n) { return Yh(n.x) || Yh(n.y) } function Yh(n) { return n && n !== "0%" } function Ms(n, r, o) { const s = n - o, l = r * s; return o + l } function Xh(n, r, o, s, l) { return l !== void 0 && (n = Ms(n, l, s)), Ms(n, o, s) + r } function Tu(n, r = 0, o = 1, s, l) { n.min = Xh(n.min, r, o, s, l), n.max = Xh(n.max, r, o, s, l) } function hg(n, { x: r, y: o }) { Tu(n.x, r.translate, r.scale, r.originPoint), Tu(n.y, o.translate, o.scale, o.originPoint) } const Qh = .999999999999, Zh = 1.0000000000001; function wS(n, r, o, s = !1) { const l = o.length; if (!l) return; r.x = r.y = 1; let f, c; for (let h = 0; h < l; h++) { f = o[h], c = f.projectionDelta; const { visualElement: p } = f.options; p && p.props.style && p.props.style.display === "contents" || (s && f.options.layoutScroll && f.scroll && f !== f.root && jr(n, { x: -f.scroll.offset.x, y: -f.scroll.offset.y }), c && (r.x *= c.x.scale, r.y *= c.y.scale, hg(n, c)), s && Zn(f.latestValues) && jr(n, f.latestValues)) } r.x < Zh && r.x > Qh && (r.x = 1), r.y < Zh && r.y > Qh && (r.y = 1) } function Dr(n, r) { n.min = n.min + r, n.max = n.max + r } function qh(n, r, o, s, l = .5) { const f = Ae(n.min, n.max, l); Tu(n, r, o, f, s) } function jr(n, r) { qh(n.x, r.x, r.scaleX, r.scale, r.originX), qh(n.y, r.y, r.scaleY, r.scale, r.originY) } function pg(n, r) { return fg(xS(n.getBoundingClientRect(), r)) } function SS(n, r, o) { const s = pg(n, o), { scroll: l } = r; return l && (Dr(s.x, l.offset.x), Dr(s.y, l.offset.y)), s } const kS = { x: "translateX", y: "translateY", z: "translateZ", transformPerspective: "perspective" }, CS = zr.length; function ES(n, r, o) { let s = "", l = !0; for (let f = 0; f < CS; f++) { const c = zr[f], h = n[c]; if (h === void 0) continue; let p = !0; if (typeof h == "number") p = h === (c.startsWith("scale") ? 1 : 0); else { const g = parseFloat(h); p = c.startsWith("scale") ? g === 1 : g === 0 } if (!p || o) { const g = ng(h, ic[c]); if (!p) { l = !1; const y = kS[c] || c; s += `${y}(${g}) ` } o && (r[c] = g) } } return s = s.trim(), o ? s = o(r, l ? "" : s) : l && (s = "none"), s } function cc(n, r, o) { const { style: s, vars: l, transformOrigin: f } = n; let c = !1, h = !1; for (const p in r) { const g = r[p]; if (Or.has(p)) { c = !0; continue } else if (Pm(p)) { l[p] = g; continue } else { const y = ng(g, ic[p]); p.startsWith("origin") ? (h = !0, f[p] = y) : s[p] = y } } if (r.transform || (c || o ? s.transform = ES(r, n.transform, o) : s.transform && (s.transform = "none")), h) { const { originX: p = "50%", originY: g = "50%", originZ: y = 0 } = f; s.transformOrigin = `${p} ${g} ${y}` } } function mg(n, { style: r, vars: o }, s, l) { const f = n.style; let c; for (c in r) f[c] = r[c]; l == null || l.applyProjectionStyles(f, s); for (c in o) f.setProperty(c, o[c]) } function Jh(n, r) { return r.max === r.min ? 0 : n / (r.max - r.min) * 100 } const Li = { correct: (n, r) => { if (!r.target) return n; if (typeof n == "string") if (Z.test(n)) n = parseFloat(n); else return n; const o = Jh(n, r.target.x), s = Jh(n, r.target.y); return `${o}% ${s}%` } }, TS = { correct: (n, { treeScale: r, projectionDelta: o }) => { const s = n, l = Dn.parse(n); if (l.length > 5) return s; const f = Dn.createTransformer(n), c = typeof l[0] != "number" ? 1 : 0, h = o.x.scale * r.x, p = o.y.scale * r.y; l[0 + c] /= h, l[1 + c] /= p; const g = Ae(h, p, .5); return typeof l[2 + c] == "number" && (l[2 + c] /= g), typeof l[3 + c] == "number" && (l[3 + c] /= g), f(l) } }, Pu = { borderRadius: { ...Li, applyTo: ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomLeftRadius", "borderBottomRightRadius"] }, borderTopLeftRadius: Li, borderTopRightRadius: Li, borderBottomLeftRadius: Li, borderBottomRightRadius: Li, boxShadow: TS }; function gg(n, { layout: r, layoutId: o }) { return Or.has(n) || n.startsWith("origin") || (r || o !== void 0) && (!!Pu[n] || n === "opacity") } function fc(n, r, o) { var c; const s = n.style, l = r == null ? void 0 : r.style, f = {}; if (!s) return f; for (const h in s) (rt(s[h]) || l && rt(l[h]) || gg(h, n) || ((c = o == null ? void 0 : o.getValue(h)) == null ? void 0 : c.liveStyle) !== void 0) && (f[h] = s[h]); return f } function PS(n) { return window.getComputedStyle(n) } class RS extends cg { constructor() { super(...arguments), this.type = "html", this.renderInstance = mg } readValueFromInstance(r, o) { var s; if (Or.has(o)) return (s = this.projection) != null && s.isProjecting ? hu(o) : Hw(r, o); { const l = PS(r), f = (Pm(o) ? l.getPropertyValue(o) : l[o]) || 0; return typeof f == "string" ? f.trim() : f } } measureInstanceViewportBox(r, { transformPagePoint: o }) { return pg(r, o) } build(r, o, s) { cc(r, o, s.transformTemplate) } scrapeMotionValuesFromProps(r, o, s) { return fc(r, o, s) } } const MS = { offset: "stroke-dashoffset", array: "stroke-dasharray" }, AS = { offset: "strokeDashoffset", array: "strokeDasharray" }; function LS(n, r, o = 1, s = 0, l = !0) { n.pathLength = 1; const f = l ? MS : AS; n[f.offset] = `${-s}`, n[f.array] = `${r} ${o}` } const NS = ["offsetDistance", "offsetPath", "offsetRotate", "offsetAnchor"]; function yg(n, { attrX: r, attrY: o, attrScale: s, pathLength: l, pathSpacing: f = 1, pathOffset: c = 0, ...h }, p, g, y) { if (cc(n, h, g), p) { n.style.viewBox && (n.attrs.viewBox = n.style.viewBox); return } n.attrs = n.style, n.style = {}; const { attrs: v, style: x } = n; v.transform && (x.transform = v.transform, delete v.transform), (x.transform || v.transformOrigin) && (x.transformOrigin = v.transformOrigin ?? "50% 50%", delete v.transformOrigin), x.transform && (x.transformBox = (y == null ? void 0 : y.transformBox) ?? "fill-box", delete v.transformBox); for (const C of NS) v[C] !== void 0 && (x[C] = v[C], delete v[C]); r !== void 0 && (v.x = r), o !== void 0 && (v.y = o), s !== void 0 && (v.scale = s), l !== void 0 && LS(v, l, f, c, !1) } const vg = new Set(["baseFrequency", "diffuseConstant", "kernelMatrix", "kernelUnitLength", "keySplines", "keyTimes", "limitingConeAngle", "markerHeight", "markerWidth", "numOctaves", "targetX", "targetY", "surfaceScale", "specularConstant", "specularExponent", "stdDeviation", "tableValues", "viewBox", "gradientTransform", "pathLength", "startOffset", "textLength", "lengthAdjust"]), xg = n => typeof n == "string" && n.toLowerCase() === "svg"; function DS(n, r, o, s) { mg(n, r, void 0, s); for (const l in r.attrs) n.setAttribute(vg.has(l) ? l : rc(l), r.attrs[l]) } function wg(n, r, o) { const s = fc(n, r, o); for (const l in n) if (rt(n[l]) || rt(r[l])) { const f = zr.indexOf(l) !== -1 ? "attr" + l.charAt(0).toUpperCase() + l.substring(1) : l; s[f] = n[l] } return s } class jS extends cg { constructor() { super(...arguments), this.type = "svg", this.isSVGTag = !1, this.measureInstanceViewportBox = Be } getBaseTargetFromProps(r, o) { return r[o] } readValueFromInstance(r, o) { if (Or.has(o)) { const s = Jm(o); return s && s.default || 0 } return o = vg.has(o) ? o : rc(o), r.getAttribute(o) } scrapeMotionValuesFromProps(r, o, s) { return wg(r, o, s) } build(r, o, s) { yg(r, o, this.isSVGTag, s.transformTemplate, s.style) } renderInstance(r, o, s, l) { DS(r, o, s, l) } mount(r) { this.isSVGTag = xg(r.tagName), super.mount(r) } } const VS = uc.length; function Sg(n) { if (!n) return; if (!n.isControllingVariants) { const o = n.parent ? Sg(n.parent) || {} : {}; return n.props.initial !== void 0 && (o.initial = n.props.initial), o } const r = {}; for (let o = 0; o < VS; o++) { const s = uc[o], l = n.props[s]; (Ui(l) || l === !1) && (r[s] = l) } return r } function kg(n, r) { if (!Array.isArray(r)) return !1; const o = r.length; if (o !== n.length) return !1; for (let s = 0; s < o; s++)if (r[s] !== n[s]) return !1; return !0 } const _S = [...lc].reverse(), bS = lc.length; function IS(n) { return r => Promise.all(r.map(({ animation: o, options: s }) => j1(n, o, s))) } function FS(n) { let r = IS(n), o = ep(), s = !0; const l = p => (g, y) => { var x; const v = Vr(n, y, p === "exit" ? (x = n.presenceContext) == null ? void 0 : x.custom : void 0); if (v) { const { transition: C, transitionEnd: M, ...N } = v; g = { ...g, ...N, ...M } } return g }; function f(p) { r = p(n) } function c(p) { const { props: g } = n, y = Sg(n.parent) || {}, v = [], x = new Set; let C = {}, M = 1 / 0; for (let A = 0; A < bS; A++) { const V = _S[A], b = o[V], j = g[V] !== void 0 ? g[V] : y[V], W = Ui(j), U = V === p ? b.isActive : null; U === !1 && (M = A); let J = j === y[V] && j !== g[V] && W; if (J && s && n.manuallyAnimateOnMount && (J = !1), b.protectedKeys = { ...C }, !b.isActive && U === null || !j && !b.prevProp || Vs(j) || typeof j == "boolean") continue; if (V === "exit" && b.isActive && U !== !0) { b.prevResolvedValues && (C = { ...C, ...b.prevResolvedValues }); continue } const se = zS(b.prevProp, j); let O = se || V === p && b.isActive && !J && W || A > M && W, ce = !1; const ve = Array.isArray(j) ? j : [j]; let Xe = ve.reduce(l(V), {}); U === !1 && (Xe = {}); const { prevResolvedValues: Ue = {} } = b, $e = { ...Ue, ...Xe }, We = ae => { O = !0, x.has(ae) && (ce = !0, x.delete(ae)), b.needsAnimating[ae] = !0; const _ = n.getValue(ae); _ && (_.liveStyle = !1) }; for (const ae in $e) { const _ = Xe[ae], ee = Ue[ae]; if (C.hasOwnProperty(ae)) continue; let H = !1; xu(_) && xu(ee) ? H = !kg(_, ee) : H = _ !== ee, H ? _ != null ? We(ae) : x.add(ae) : _ !== void 0 && x.has(ae) ? We(ae) : b.protectedKeys[ae] = !0 } b.prevProp = j, b.prevResolvedValues = Xe, b.isActive && (C = { ...C, ...Xe }), s && n.blockInitialAnimation && (O = !1); const _e = J && se; O && (!_e || ce) && v.push(...ve.map(ae => { const _ = { type: V }; if (typeof ae == "string" && s && !_e && n.manuallyAnimateOnMount && n.parent) { const { parent: ee } = n, H = Vr(ee, ae); if (ee.enteringChildren && H) { const { delayChildren: T } = H.transition || {}; _.delay = Wm(ee.enteringChildren, n, T) } } return { animation: ae, options: _ } })) } if (x.size) { const A = {}; if (typeof g.initial != "boolean") { const V = Vr(n, Array.isArray(g.initial) ? g.initial[0] : g.initial); V && V.transition && (A.transition = V.transition) } x.forEach(V => { const b = n.getBaseTarget(V), j = n.getValue(V); j && (j.liveStyle = !0), A[V] = b ?? null }), v.push({ animation: A }) } let N = !!v.length; return s && (g.initial === !1 || g.initial === g.animate) && !n.manuallyAnimateOnMount && (N = !1), s = !1, N ? r(v) : Promise.resolve() } function h(p, g) { var v; if (o[p].isActive === g) return Promise.resolve(); (v = n.variantChildren) == null || v.forEach(x => { var C; return (C = x.animationState) == null ? void 0 : C.setActive(p, g) }), o[p].isActive = g; const y = c(p); for (const x in o) o[x].protectedKeys = {}; return y } return { animateChanges: c, setActive: h, setAnimateFunction: f, getState: () => o, reset: () => { o = ep() } } } function zS(n, r) { return typeof r == "string" ? r !== n : Array.isArray(r) ? !kg(r, n) : !1 } function Xn(n = !1) { return { isActive: n, protectedKeys: {}, needsAnimating: {}, prevResolvedValues: {} } } function ep() { return { animate: Xn(!0), whileInView: Xn(), whileHover: Xn(), whileTap: Xn(), whileDrag: Xn(), whileFocus: Xn(), exit: Xn() } } function tp(n, r) { n.min = r.min, n.max = r.max } function Vt(n, r) { tp(n.x, r.x), tp(n.y, r.y) } function np(n, r) { n.translate = r.translate, n.scale = r.scale, n.originPoint = r.originPoint, n.origin = r.origin } const Cg = 1e-4, OS = 1 - Cg, BS = 1 + Cg, Eg = .01, US = 0 - Eg, $S = 0 + Eg; function at(n) { return n.max - n.min } function WS(n, r, o) { return Math.abs(n - r) <= o } function rp(n, r, o, s = .5) { n.origin = s, n.originPoint = Ae(r.min, r.max, n.origin), n.scale = at(o) / at(r), n.translate = Ae(o.min, o.max, n.origin) - n.originPoint, (n.scale >= OS && n.scale <= BS || isNaN(n.scale)) && (n.scale = 1), (n.translate >= US && n.translate <= $S || isNaN(n.translate)) && (n.translate = 0) } function _i(n, r, o, s) { rp(n.x, r.x, o.x, s ? s.originX : void 0), rp(n.y, r.y, o.y, s ? s.originY : void 0) } function ip(n, r, o) { n.min = o.min + r.min, n.max = n.min + at(r) } function HS(n, r, o) { ip(n.x, r.x, o.x), ip(n.y, r.y, o.y) } function op(n, r, o) { n.min = r.min - o.min, n.max = n.min + at(r) } function As(n, r, o) { op(n.x, r.x, o.x), op(n.y, r.y, o.y) } function sp(n, r, o, s, l) { return n -= r, n = Ms(n, 1 / o, s), l !== void 0 && (n = Ms(n, 1 / l, s)), n } function KS(n, r = 0, o = 1, s = .5, l, f = n, c = n) { if (Wt.test(r) && (r = parseFloat(r), r = Ae(c.min, c.max, r / 100) - c.min), typeof r != "number") return; let h = Ae(f.min, f.max, s); n === f && (h -= r), n.min = sp(n.min, r, o, h, l), n.max = sp(n.max, r, o, h, l) } function ap(n, r, [o, s, l], f, c) { KS(n, r[o], r[s], r[l], r.scale, f, c) } const GS = ["x", "scaleX", "originX"], YS = ["y", "scaleY", "originY"]; function lp(n, r, o, s) { ap(n.x, r, GS, o ? o.x : void 0, s ? s.x : void 0), ap(n.y, r, YS, o ? o.y : void 0, s ? s.y : void 0) } function up(n) { return n.translate === 0 && n.scale === 1 } function Tg(n) { return up(n.x) && up(n.y) } function cp(n, r) { return n.min === r.min && n.max === r.max } function XS(n, r) { return cp(n.x, r.x) && cp(n.y, r.y) } function fp(n, r) { return Math.round(n.min) === Math.round(r.min) && Math.round(n.max) === Math.round(r.max) } function Pg(n, r) { return fp(n.x, r.x) && fp(n.y, r.y) } function dp(n) { return at(n.x) / at(n.y) } function hp(n, r) { return n.translate === r.translate && n.scale === r.scale && n.originPoint === r.originPoint } function $t(n) { return [n("x"), n("y")] } function QS(n, r, o) { let s = ""; const l = n.x.translate / r.x, f = n.y.translate / r.y, c = (o == null ? void 0 : o.z) || 0; if ((l || f || c) && (s = `translate3d(${l}px, ${f}px, ${c}px) `), (r.x !== 1 || r.y !== 1) && (s += `scale(${1 / r.x}, ${1 / r.y}) `), o) { const { transformPerspective: g, rotate: y, rotateX: v, rotateY: x, skewX: C, skewY: M } = o; g && (s = `perspective(${g}px) ${s}`), y && (s += `rotate(${y}deg) `), v && (s += `rotateX(${v}deg) `), x && (s += `rotateY(${x}deg) `), C && (s += `skewX(${C}deg) `), M && (s += `skewY(${M}deg) `) } const h = n.x.scale * r.x, p = n.y.scale * r.y; return (h !== 1 || p !== 1) && (s += `scale(${h}, ${p})`), s || "none" } const Rg = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"], ZS = Rg.length, pp = n => typeof n == "string" ? parseFloat(n) : n, mp = n => typeof n == "number" || Z.test(n); function qS(n, r, o, s, l, f) { l ? (n.opacity = Ae(0, o.opacity ?? 1, JS(s)), n.opacityExit = Ae(r.opacity ?? 1, 0, ek(s))) : f && (n.opacity = Ae(r.opacity ?? 1, o.opacity ?? 1, s)); for (let c = 0; c < ZS; c++) { const h = `border${Rg[c]}Radius`; let p = gp(r, h), g = gp(o, h); if (p === void 0 && g === void 0) continue; p || (p = 0), g || (g = 0), p === 0 || g === 0 || mp(p) === mp(g) ? (n[h] = Math.max(Ae(pp(p), pp(g), s), 0), (Wt.test(g) || Wt.test(p)) && (n[h] += "%")) : n[h] = g } (r.rotate || o.rotate) && (n.rotate = Ae(r.rotate || 0, o.rotate || 0, s)) } function gp(n, r) { return n[r] !== void 0 ? n[r] : n.borderRadius } const JS = Mg(0, .5, wm), ek = Mg(.5, .95, Tt); function Mg(n, r, o) { return s => s < n ? 0 : s > r ? 1 : o(zi(n, r, s)) } function tk(n, r, o) { const s = rt(n) ? n : _r(n); return s.start(tc("", s, r, o)), s.animation } function $i(n, r, o, s = { passive: !0 }) { return n.addEventListener(r, o, s), () => n.removeEventListener(r, o) } const nk = (n, r) => n.depth - r.depth; class rk { constructor() { this.children = [], this.isDirty = !1 } add(r) { zu(this.children, r), this.isDirty = !0 } remove(r) { Cs(this.children, r), this.isDirty = !0 } forEach(r) { this.isDirty && this.children.sort(nk), this.isDirty = !1, this.children.forEach(r) } } function ik(n, r) { const o = st.now(), s = ({ timestamp: l }) => { const f = l - o; f >= r && (Nn(s), n(f - r)) }; return ke.setup(s, !0), () => Nn(s) } function ws(n) { return rt(n) ? n.get() : n } class ok { constructor() { this.members = [] } add(r) { zu(this.members, r); for (let o = this.members.length - 1; o >= 0; o--) { const s = this.members[o]; if (s === r || s === this.lead || s === this.prevLead) continue; const l = s.instance; l && l.isConnected === !1 && s.isPresent !== !1 && !s.snapshot && Cs(this.members, s) } r.scheduleRender() } remove(r) { if (Cs(this.members, r), r === this.prevLead && (this.prevLead = void 0), r === this.lead) { const o = this.members[this.members.length - 1]; o && this.promote(o) } } relegate(r) { const o = this.members.findIndex(l => r === l); if (o === 0) return !1; let s; for (let l = o; l >= 0; l--) { const f = this.members[l], c = f.instance; if (f.isPresent !== !1 && (!c || c.isConnected !== !1)) { s = f; break } } return s ? (this.promote(s), !0) : !1 } promote(r, o) { const s = this.lead; if (r !== s && (this.prevLead = s, this.lead = r, r.show(), s)) { s.instance && s.scheduleRender(), r.scheduleRender(); const l = s.options.layoutDependency, f = r.options.layoutDependency; if (!(l !== void 0 && f !== void 0 && l === f)) { const p = s.instance; p && p.isConnected === !1 && !s.snapshot || (r.resumeFrom = s, o && (r.resumeFrom.preserveOpacity = !0), s.snapshot && (r.snapshot = s.snapshot, r.snapshot.latestValues = s.animationValues || s.latestValues), r.root && r.root.isUpdating && (r.isLayoutDirty = !0)) } const { crossfade: h } = r.options; h === !1 && s.hide() } } exitAnimationComplete() { this.members.forEach(r => { const { options: o, resumingFrom: s } = r; o.onExitComplete && o.onExitComplete(), s && s.options.onExitComplete && s.options.onExitComplete() }) } scheduleRender() { this.members.forEach(r => { r.instance && r.scheduleRender(!1) }) } removeLeadSnapshot() { this.lead && this.lead.snapshot && (this.lead.snapshot = void 0) } } const Ss = { hasAnimatedSinceResize: !0, hasEverUpdated: !1 }, Gl = ["", "X", "Y", "Z"], sk = 1e3; let ak = 0; function Yl(n, r, o, s) { const { latestValues: l } = r; l[n] && (o[n] = l[n], r.setStaticValue(n, 0), s && (s[n] = 0)) } function Ag(n) { if (n.hasCheckedOptimisedAppear = !0, n.root === n) return; const { visualElement: r } = n.options; if (!r) return; const o = Xm(r); if (window.MotionHasOptimisedAnimation(o, "transform")) { const { layout: l, layoutId: f } = n.options; window.MotionCancelOptimisedAnimation(o, "transform", ke, !(l || f)) } const { parent: s } = n; s && !s.hasCheckedOptimisedAppear && Ag(s) } function Lg({ attachResizeListener: n, defaultParent: r, measureScroll: o, checkIsScrollRoot: s, resetTransform: l }) { return class { constructor(c = {}, h = r == null ? void 0 : r()) { this.id = ak++, this.animationId = 0, this.animationCommitId = 0, this.children = new Set, this.options = {}, this.isTreeAnimating = !1, this.isAnimationBlocked = !1, this.isLayoutDirty = !1, this.isProjectionDirty = !1, this.isSharedProjectionDirty = !1, this.isTransformDirty = !1, this.updateManuallyBlocked = !1, this.updateBlockedByResize = !1, this.isUpdating = !1, this.isSVG = !1, this.needsReset = !1, this.shouldResetTransform = !1, this.hasCheckedOptimisedAppear = !1, this.treeScale = { x: 1, y: 1 }, this.eventHandlers = new Map, this.hasTreeAnimated = !1, this.layoutVersion = 0, this.updateScheduled = !1, this.scheduleUpdate = () => this.update(), this.projectionUpdateScheduled = !1, this.checkUpdateFailed = () => { this.isUpdating && (this.isUpdating = !1, this.clearAllSnapshots()) }, this.updateProjection = () => { this.projectionUpdateScheduled = !1, this.nodes.forEach(ck), this.nodes.forEach(pk), this.nodes.forEach(mk), this.nodes.forEach(fk) }, this.resolvedRelativeTargetAt = 0, this.linkedParentVersion = 0, this.hasProjected = !1, this.isVisible = !0, this.animationProgress = 0, this.sharedNodes = new Map, this.latestValues = c, this.root = h ? h.root || h : this, this.path = h ? [...h.path, h] : [], this.parent = h, this.depth = h ? h.depth + 1 : 0; for (let p = 0; p < this.path.length; p++)this.path[p].shouldResetTransform = !0; this.root === this && (this.nodes = new rk) } addEventListener(c, h) { return this.eventHandlers.has(c) || this.eventHandlers.set(c, new Uu), this.eventHandlers.get(c).add(h) } notifyListeners(c, ...h) { const p = this.eventHandlers.get(c); p && p.notify(...h) } hasListeners(c) { return this.eventHandlers.has(c) } mount(c) { if (this.instance) return; this.isSVG = ac(c) && !uS(c), this.instance = c; const { layoutId: h, layout: p, visualElement: g } = this.options; if (g && !g.current && g.mount(c), this.root.nodes.add(this), this.parent && this.parent.children.add(this), this.root.hasTreeAnimated && (p || h) && (this.isLayoutDirty = !0), n) { let y, v = 0; const x = () => this.root.updateBlockedByResize = !1; ke.read(() => { v = window.innerWidth }), n(c, () => { const C = window.innerWidth; C !== v && (v = C, this.root.updateBlockedByResize = !0, y && y(), y = ik(x, 250), Ss.hasAnimatedSinceResize && (Ss.hasAnimatedSinceResize = !1, this.nodes.forEach(xp))) }) } h && this.root.registerSharedNode(h, this), this.options.animate !== !1 && g && (h || p) && this.addEventListener("didUpdate", ({ delta: y, hasLayoutChanged: v, hasRelativeLayoutChanged: x, layout: C }) => { if (this.isTreeAnimationBlocked()) { this.target = void 0, this.relativeTarget = void 0; return } const M = this.options.transition || g.getDefaultTransition() || wk, { onLayoutAnimationStart: N, onLayoutAnimationComplete: A } = g.getProps(), V = !this.targetLayout || !Pg(this.targetLayout, C), b = !v && x; if (this.options.layoutRoot || this.resumeFrom || b || v && (V || !this.currentAnimation)) { this.resumeFrom && (this.resumingFrom = this.resumeFrom, this.resumingFrom.resumingFrom = void 0); const j = { ...ec(M, "layout"), onPlay: N, onComplete: A }; (g.shouldReduceMotion || this.options.layoutRoot) && (j.delay = 0, j.type = !1), this.startAnimation(j), this.setAnimationOrigin(y, b) } else v || xp(this), this.isLead() && this.options.onExitComplete && this.options.onExitComplete(); this.targetLayout = C }) } unmount() { this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this); const c = this.getStack(); c && c.remove(this), this.parent && this.parent.children.delete(this), this.instance = void 0, this.eventHandlers.clear(), Nn(this.updateProjection) } blockUpdate() { this.updateManuallyBlocked = !0 } unblockUpdate() { this.updateManuallyBlocked = !1 } isUpdateBlocked() { return this.updateManuallyBlocked || this.updateBlockedByResize } isTreeAnimationBlocked() { return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || !1 } startUpdate() { this.isUpdateBlocked() || (this.isUpdating = !0, this.nodes && this.nodes.forEach(gk), this.animationId++) } getTransformTemplate() { const { visualElement: c } = this.options; return c && c.getProps().transformTemplate } willUpdate(c = !0) { if (this.root.hasTreeAnimated = !0, this.root.isUpdateBlocked()) { this.options.onExitComplete && this.options.onExitComplete(); return } if (window.MotionCancelOptimisedAnimation && !this.hasCheckedOptimisedAppear && Ag(this), !this.root.isUpdating && this.root.startUpdate(), this.isLayoutDirty) return; this.isLayoutDirty = !0; for (let y = 0; y < this.path.length; y++) { const v = this.path[y]; v.shouldResetTransform = !0, v.updateScroll("snapshot"), v.options.layoutRoot && v.willUpdate(!1) } const { layoutId: h, layout: p } = this.options; if (h === void 0 && !p) return; const g = this.getTransformTemplate(); this.prevTransformTemplateValue = g ? g(this.latestValues, "") : void 0, this.updateSnapshot(), c && this.notifyListeners("willUpdate") } update() { if (this.updateScheduled = !1, this.isUpdateBlocked()) { this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach(yp); return } if (this.animationId <= this.animationCommitId) { this.nodes.forEach(vp); return } this.animationCommitId = this.animationId, this.isUpdating ? (this.isUpdating = !1, this.nodes.forEach(hk), this.nodes.forEach(lk), this.nodes.forEach(uk)) : this.nodes.forEach(vp), this.clearAllSnapshots(); const h = st.now(); qe.delta = Kt(0, 1e3 / 60, h - qe.timestamp), qe.timestamp = h, qe.isProcessing = !0, zl.update.process(qe), zl.preRender.process(qe), zl.render.process(qe), qe.isProcessing = !1 } didUpdate() { this.updateScheduled || (this.updateScheduled = !0, oc.read(this.scheduleUpdate)) } clearAllSnapshots() { this.nodes.forEach(dk), this.sharedNodes.forEach(yk) } scheduleUpdateProjection() { this.projectionUpdateScheduled || (this.projectionUpdateScheduled = !0, ke.preRender(this.updateProjection, !1, !0)) } scheduleCheckAfterUnmount() { ke.postRender(() => { this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed() }) } updateSnapshot() { this.snapshot || !this.instance || (this.snapshot = this.measure(), this.snapshot && !at(this.snapshot.measuredBox.x) && !at(this.snapshot.measuredBox.y) && (this.snapshot = void 0)) } updateLayout() { if (!this.instance || (this.updateScroll(), !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty)) return; if (this.resumeFrom && !this.resumeFrom.instance) for (let p = 0; p < this.path.length; p++)this.path[p].updateScroll(); const c = this.layout; this.layout = this.measure(!1), this.layoutVersion++, this.layoutCorrected = Be(), this.isLayoutDirty = !1, this.projectionDelta = void 0, this.notifyListeners("measure", this.layout.layoutBox); const { visualElement: h } = this.options; h && h.notify("LayoutMeasure", this.layout.layoutBox, c ? c.layoutBox : void 0) } updateScroll(c = "measure") { let h = !!(this.options.layoutScroll && this.instance); if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === c && (h = !1), h && this.instance) { const p = s(this.instance); this.scroll = { animationId: this.root.animationId, phase: c, isRoot: p, offset: o(this.instance), wasRoot: this.scroll ? this.scroll.isRoot : p } } } resetTransform() { if (!l) return; const c = this.isLayoutDirty || this.shouldResetTransform || this.options.alwaysMeasureLayout, h = this.projectionDelta && !Tg(this.projectionDelta), p = this.getTransformTemplate(), g = p ? p(this.latestValues, "") : void 0, y = g !== this.prevTransformTemplateValue; c && this.instance && (h || Zn(this.latestValues) || y) && (l(this.instance, g), this.shouldResetTransform = !1, this.scheduleRender()) } measure(c = !0) { const h = this.measurePageBox(); let p = this.removeElementScroll(h); return c && (p = this.removeTransform(p)), Sk(p), { animationId: this.root.animationId, measuredBox: h, layoutBox: p, latestValues: {}, source: this.id } } measurePageBox() { var g; const { visualElement: c } = this.options; if (!c) return Be(); const h = c.measureViewportBox(); if (!(((g = this.scroll) == null ? void 0 : g.wasRoot) || this.path.some(kk))) { const { scroll: y } = this.root; y && (Dr(h.x, y.offset.x), Dr(h.y, y.offset.y)) } return h } removeElementScroll(c) { var p; const h = Be(); if (Vt(h, c), (p = this.scroll) != null && p.wasRoot) return h; for (let g = 0; g < this.path.length; g++) { const y = this.path[g], { scroll: v, options: x } = y; y !== this.root && v && x.layoutScroll && (v.wasRoot && Vt(h, c), Dr(h.x, v.offset.x), Dr(h.y, v.offset.y)) } return h } applyTransform(c, h = !1) { const p = Be(); Vt(p, c); for (let g = 0; g < this.path.length; g++) { const y = this.path[g]; !h && y.options.layoutScroll && y.scroll && y !== y.root && jr(p, { x: -y.scroll.offset.x, y: -y.scroll.offset.y }), Zn(y.latestValues) && jr(p, y.latestValues) } return Zn(this.latestValues) && jr(p, this.latestValues), p } removeTransform(c) { const h = Be(); Vt(h, c); for (let p = 0; p < this.path.length; p++) { const g = this.path[p]; if (!g.instance || !Zn(g.latestValues)) continue; Eu(g.latestValues) && g.updateSnapshot(); const y = Be(), v = g.measurePageBox(); Vt(y, v), lp(h, g.latestValues, g.snapshot ? g.snapshot.layoutBox : void 0, y) } return Zn(this.latestValues) && lp(h, this.latestValues), h } setTargetDelta(c) { this.targetDelta = c, this.root.scheduleUpdateProjection(), this.isProjectionDirty = !0 } setOptions(c) { this.options = { ...this.options, ...c, crossfade: c.crossfade !== void 0 ? c.crossfade : !0 } } clearMeasurements() { this.scroll = void 0, this.layout = void 0, this.snapshot = void 0, this.prevTransformTemplateValue = void 0, this.targetDelta = void 0, this.target = void 0, this.isLayoutDirty = !1 } forceRelativeParentToResolveTarget() { this.relativeParent && this.relativeParent.resolvedRelativeTargetAt !== qe.timestamp && this.relativeParent.resolveTargetDelta(!0) } resolveTargetDelta(c = !1) { var C; const h = this.getLead(); this.isProjectionDirty || (this.isProjectionDirty = h.isProjectionDirty), this.isTransformDirty || (this.isTransformDirty = h.isTransformDirty), this.isSharedProjectionDirty || (this.isSharedProjectionDirty = h.isSharedProjectionDirty); const p = !!this.resumingFrom || this !== h; if (!(c || p && this.isSharedProjectionDirty || this.isProjectionDirty || (C = this.parent) != null && C.isProjectionDirty || this.attemptToResolveRelativeTarget || this.root.updateBlockedByResize)) return; const { layout: y, layoutId: v } = this.options; if (!this.layout || !(y || v)) return; this.resolvedRelativeTargetAt = qe.timestamp; const x = this.getClosestProjectingParent(); x && this.linkedParentVersion !== x.layoutVersion && !x.options.layoutRoot && this.removeRelativeTarget(), !this.targetDelta && !this.relativeTarget && (x && x.layout ? this.createRelativeTarget(x, this.layout.layoutBox, x.layout.layoutBox) : this.removeRelativeTarget()), !(!this.relativeTarget && !this.targetDelta) && (this.target || (this.target = Be(), this.targetWithTransforms = Be()), this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target ? (this.forceRelativeParentToResolveTarget(), HS(this.target, this.relativeTarget, this.relativeParent.target)) : this.targetDelta ? (this.resumingFrom ? this.target = this.applyTransform(this.layout.layoutBox) : Vt(this.target, this.layout.layoutBox), hg(this.target, this.targetDelta)) : Vt(this.target, this.layout.layoutBox), this.attemptToResolveRelativeTarget && (this.attemptToResolveRelativeTarget = !1, x && !!x.resumingFrom == !!this.resumingFrom && !x.options.layoutScroll && x.target && this.animationProgress !== 1 ? this.createRelativeTarget(x, this.target, x.target) : this.relativeParent = this.relativeTarget = void 0)) } getClosestProjectingParent() { if (!(!this.parent || Eu(this.parent.latestValues) || dg(this.parent.latestValues))) return this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent() } isProjecting() { return !!((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout) } createRelativeTarget(c, h, p) { this.relativeParent = c, this.linkedParentVersion = c.layoutVersion, this.forceRelativeParentToResolveTarget(), this.relativeTarget = Be(), this.relativeTargetOrigin = Be(), As(this.relativeTargetOrigin, h, p), Vt(this.relativeTarget, this.relativeTargetOrigin) } removeRelativeTarget() { this.relativeParent = this.relativeTarget = void 0 } calcProjection() { var M; const c = this.getLead(), h = !!this.resumingFrom || this !== c; let p = !0; if ((this.isProjectionDirty || (M = this.parent) != null && M.isProjectionDirty) && (p = !1), h && (this.isSharedProjectionDirty || this.isTransformDirty) && (p = !1), this.resolvedRelativeTargetAt === qe.timestamp && (p = !1), p) return; const { layout: g, layoutId: y } = this.options; if (this.isTreeAnimating = !!(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation), this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0), !this.layout || !(g || y)) return; Vt(this.layoutCorrected, this.layout.layoutBox); const v = this.treeScale.x, x = this.treeScale.y; wS(this.layoutCorrected, this.treeScale, this.path, h), c.layout && !c.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1) && (c.target = c.layout.layoutBox, c.targetWithTransforms = Be()); const { target: C } = c; if (!C) { this.prevProjectionDelta && (this.createProjectionDeltas(), this.scheduleRender()); return } !this.projectionDelta || !this.prevProjectionDelta ? this.createProjectionDeltas() : (np(this.prevProjectionDelta.x, this.projectionDelta.x), np(this.prevProjectionDelta.y, this.projectionDelta.y)), _i(this.projectionDelta, this.layoutCorrected, C, this.latestValues), (this.treeScale.x !== v || this.treeScale.y !== x || !hp(this.projectionDelta.x, this.prevProjectionDelta.x) || !hp(this.projectionDelta.y, this.prevProjectionDelta.y)) && (this.hasProjected = !0, this.scheduleRender(), this.notifyListeners("projectionUpdate", C)) } hide() { this.isVisible = !1 } show() { this.isVisible = !0 } scheduleRender(c = !0) { var h; if ((h = this.options.visualElement) == null || h.scheduleRender(), c) { const p = this.getStack(); p && p.scheduleRender() } this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0) } createProjectionDeltas() { this.prevProjectionDelta = Nr(), this.projectionDelta = Nr(), this.projectionDeltaWithTransform = Nr() } setAnimationOrigin(c, h = !1) { const p = this.snapshot, g = p ? p.latestValues : {}, y = { ...this.latestValues }, v = Nr(); (!this.relativeParent || !this.relativeParent.options.layoutRoot) && (this.relativeTarget = this.relativeTargetOrigin = void 0), this.attemptToResolveRelativeTarget = !h; const x = Be(), C = p ? p.source : void 0, M = this.layout ? this.layout.source : void 0, N = C !== M, A = this.getStack(), V = !A || A.members.length <= 1, b = !!(N && !V && this.options.crossfade === !0 && !this.path.some(xk)); this.animationProgress = 0; let j; this.mixTargetDelta = W => { const U = W / 1e3; wp(v.x, c.x, U), wp(v.y, c.y, U), this.setTargetDelta(v), this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout && (As(x, this.layout.layoutBox, this.relativeParent.layout.layoutBox), vk(this.relativeTarget, this.relativeTargetOrigin, x, U), j && XS(this.relativeTarget, j) && (this.isProjectionDirty = !1), j || (j = Be()), Vt(j, this.relativeTarget)), N && (this.animationValues = y, qS(y, g, this.latestValues, U, b, V)), this.root.scheduleUpdateProjection(), this.scheduleRender(), this.animationProgress = U }, this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0) } startAnimation(c) { var h, p, g; this.notifyListeners("animationStart"), (h = this.currentAnimation) == null || h.stop(), (g = (p = this.resumingFrom) == null ? void 0 : p.currentAnimation) == null || g.stop(), this.pendingAnimation && (Nn(this.pendingAnimation), this.pendingAnimation = void 0), this.pendingAnimation = ke.update(() => { Ss.hasAnimatedSinceResize = !0, this.motionValue || (this.motionValue = _r(0)), this.currentAnimation = tk(this.motionValue, [0, 1e3], { ...c, velocity: 0, isSync: !0, onUpdate: y => { this.mixTargetDelta(y), c.onUpdate && c.onUpdate(y) }, onStop: () => { }, onComplete: () => { c.onComplete && c.onComplete(), this.completeAnimation() } }), this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation), this.pendingAnimation = void 0 }) } completeAnimation() { this.resumingFrom && (this.resumingFrom.currentAnimation = void 0, this.resumingFrom.preserveOpacity = void 0); const c = this.getStack(); c && c.exitAnimationComplete(), this.resumingFrom = this.currentAnimation = this.animationValues = void 0, this.notifyListeners("animationComplete") } finishAnimation() { this.currentAnimation && (this.mixTargetDelta && this.mixTargetDelta(sk), this.currentAnimation.stop()), this.completeAnimation() } applyTransformsToTarget() { const c = this.getLead(); let { targetWithTransforms: h, target: p, layout: g, latestValues: y } = c; if (!(!h || !p || !g)) { if (this !== c && this.layout && g && Ng(this.options.animationType, this.layout.layoutBox, g.layoutBox)) { p = this.target || Be(); const v = at(this.layout.layoutBox.x); p.x.min = c.target.x.min, p.x.max = p.x.min + v; const x = at(this.layout.layoutBox.y); p.y.min = c.target.y.min, p.y.max = p.y.min + x } Vt(h, p), jr(h, y), _i(this.projectionDeltaWithTransform, this.layoutCorrected, h, y) } } registerSharedNode(c, h) { this.sharedNodes.has(c) || this.sharedNodes.set(c, new ok), this.sharedNodes.get(c).add(h); const g = h.options.initialPromotionConfig; h.promote({ transition: g ? g.transition : void 0, preserveFollowOpacity: g && g.shouldPreserveFollowOpacity ? g.shouldPreserveFollowOpacity(h) : void 0 }) } isLead() { const c = this.getStack(); return c ? c.lead === this : !0 } getLead() { var h; const { layoutId: c } = this.options; return c ? ((h = this.getStack()) == null ? void 0 : h.lead) || this : this } getPrevLead() { var h; const { layoutId: c } = this.options; return c ? (h = this.getStack()) == null ? void 0 : h.prevLead : void 0 } getStack() { const { layoutId: c } = this.options; if (c) return this.root.sharedNodes.get(c) } promote({ needsReset: c, transition: h, preserveFollowOpacity: p } = {}) { const g = this.getStack(); g && g.promote(this, p), c && (this.projectionDelta = void 0, this.needsReset = !0), h && this.setOptions({ transition: h }) } relegate() { const c = this.getStack(); return c ? c.relegate(this) : !1 } resetSkewAndRotation() { const { visualElement: c } = this.options; if (!c) return; let h = !1; const { latestValues: p } = c; if ((p.z || p.rotate || p.rotateX || p.rotateY || p.rotateZ || p.skewX || p.skewY) && (h = !0), !h) return; const g = {}; p.z && Yl("z", c, g, this.animationValues); for (let y = 0; y < Gl.length; y++)Yl(`rotate${Gl[y]}`, c, g, this.animationValues), Yl(`skew${Gl[y]}`, c, g, this.animationValues); c.render(); for (const y in g) c.setStaticValue(y, g[y]), this.animationValues && (this.animationValues[y] = g[y]); c.scheduleRender() } applyProjectionStyles(c, h) { if (!this.instance || this.isSVG) return; if (!this.isVisible) { c.visibility = "hidden"; return } const p = this.getTransformTemplate(); if (this.needsReset) { this.needsReset = !1, c.visibility = "", c.opacity = "", c.pointerEvents = ws(h == null ? void 0 : h.pointerEvents) || "", c.transform = p ? p(this.latestValues, "") : "none"; return } const g = this.getLead(); if (!this.projectionDelta || !this.layout || !g.target) { this.options.layoutId && (c.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1, c.pointerEvents = ws(h == null ? void 0 : h.pointerEvents) || ""), this.hasProjected && !Zn(this.latestValues) && (c.transform = p ? p({}, "") : "none", this.hasProjected = !1); return } c.visibility = ""; const y = g.animationValues || g.latestValues; this.applyTransformsToTarget(); let v = QS(this.projectionDeltaWithTransform, this.treeScale, y); p && (v = p(y, v)), c.transform = v; const { x, y: C } = this.projectionDelta; c.transformOrigin = `${x.origin * 100}% ${C.origin * 100}% 0`, g.animationValues ? c.opacity = g === this ? y.opacity ?? this.latestValues.opacity ?? 1 : this.preserveOpacity ? this.latestValues.opacity : y.opacityExit : c.opacity = g === this ? y.opacity !== void 0 ? y.opacity : "" : y.opacityExit !== void 0 ? y.opacityExit : 0; for (const M in Pu) { if (y[M] === void 0) continue; const { correct: N, applyTo: A, isCSSVariable: V } = Pu[M], b = v === "none" ? y[M] : N(y[M], g); if (A) { const j = A.length; for (let W = 0; W < j; W++)c[A[W]] = b } else V ? this.options.visualElement.renderState.vars[M] = b : c[M] = b } this.options.layoutId && (c.pointerEvents = g === this ? ws(h == null ? void 0 : h.pointerEvents) || "" : "none") } clearSnapshot() { this.resumeFrom = this.snapshot = void 0 } resetTree() { this.root.nodes.forEach(c => { var h; return (h = c.currentAnimation) == null ? void 0 : h.stop() }), this.root.nodes.forEach(yp), this.root.sharedNodes.clear() } } } function lk(n) { n.updateLayout() } function uk(n) { var o; const r = ((o = n.resumeFrom) == null ? void 0 : o.snapshot) || n.snapshot; if (n.isLead() && n.layout && r && n.hasListeners("didUpdate")) { const { layoutBox: s, measuredBox: l } = n.layout, { animationType: f } = n.options, c = r.source !== n.layout.source; f === "size" ? $t(v => { const x = c ? r.measuredBox[v] : r.layoutBox[v], C = at(x); x.min = s[v].min, x.max = x.min + C }) : Ng(f, r.layoutBox, s) && $t(v => { const x = c ? r.measuredBox[v] : r.layoutBox[v], C = at(s[v]); x.max = x.min + C, n.relativeTarget && !n.currentAnimation && (n.isProjectionDirty = !0, n.relativeTarget[v].max = n.relativeTarget[v].min + C) }); const h = Nr(); _i(h, s, r.layoutBox); const p = Nr(); c ? _i(p, n.applyTransform(l, !0), r.measuredBox) : _i(p, s, r.layoutBox); const g = !Tg(h); let y = !1; if (!n.resumeFrom) { const v = n.getClosestProjectingParent(); if (v && !v.resumeFrom) { const { snapshot: x, layout: C } = v; if (x && C) { const M = Be(); As(M, r.layoutBox, x.layoutBox); const N = Be(); As(N, s, C.layoutBox), Pg(M, N) || (y = !0), v.options.layoutRoot && (n.relativeTarget = N, n.relativeTargetOrigin = M, n.relativeParent = v) } } } n.notifyListeners("didUpdate", { layout: s, snapshot: r, delta: p, layoutDelta: h, hasLayoutChanged: g, hasRelativeLayoutChanged: y }) } else if (n.isLead()) { const { onExitComplete: s } = n.options; s && s() } n.options.transition = void 0 } function ck(n) { n.parent && (n.isProjecting() || (n.isProjectionDirty = n.parent.isProjectionDirty), n.isSharedProjectionDirty || (n.isSharedProjectionDirty = !!(n.isProjectionDirty || n.parent.isProjectionDirty || n.parent.isSharedProjectionDirty)), n.isTransformDirty || (n.isTransformDirty = n.parent.isTransformDirty)) } function fk(n) { n.isProjectionDirty = n.isSharedProjectionDirty = n.isTransformDirty = !1 } function dk(n) { n.clearSnapshot() } function yp(n) { n.clearMeasurements() } function vp(n) { n.isLayoutDirty = !1 } function hk(n) { const { visualElement: r } = n.options; r && r.getProps().onBeforeLayoutMeasure && r.notify("BeforeLayoutMeasure"), n.resetTransform() } function xp(n) { n.finishAnimation(), n.targetDelta = n.relativeTarget = n.target = void 0, n.isProjectionDirty = !0 } function pk(n) { n.resolveTargetDelta() } function mk(n) { n.calcProjection() } function gk(n) { n.resetSkewAndRotation() } function yk(n) { n.removeLeadSnapshot() } function wp(n, r, o) { n.translate = Ae(r.translate, 0, o), n.scale = Ae(r.scale, 1, o), n.origin = r.origin, n.originPoint = r.originPoint } function Sp(n, r, o, s) { n.min = Ae(r.min, o.min, s), n.max = Ae(r.max, o.max, s) } function vk(n, r, o, s) { Sp(n.x, r.x, o.x, s), Sp(n.y, r.y, o.y, s) } function xk(n) { return n.animationValues && n.animationValues.opacityExit !== void 0 } const wk = { duration: .45, ease: [.4, 0, .1, 1] }, kp = n => typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().includes(n), Cp = kp("applewebkit/") && !kp("chrome/") ? Math.round : Tt; function Ep(n) { n.min = Cp(n.min), n.max = Cp(n.max) } function Sk(n) { Ep(n.x), Ep(n.y) } function Ng(n, r, o) { return n === "position" || n === "preserve-aspect" && !WS(dp(r), dp(o), .2) } function kk(n) { var r; return n !== n.root && ((r = n.scroll) == null ? void 0 : r.wasRoot) } const Ck = Lg({ attachResizeListener: (n, r) => $i(n, "resize", r), measureScroll: () => { var n, r; return { x: document.documentElement.scrollLeft || ((n = document.body) == null ? void 0 : n.scrollLeft) || 0, y: document.documentElement.scrollTop || ((r = document.body) == null ? void 0 : r.scrollTop) || 0 } }, checkIsScrollRoot: () => !0 }), Xl = { current: void 0 }, Dg = Lg({ measureScroll: n => ({ x: n.scrollLeft, y: n.scrollTop }), defaultParent: () => { if (!Xl.current) { const n = new Ck({}); n.mount(window), n.setOptions({ layoutScroll: !0 }), Xl.current = n } return Xl.current }, resetTransform: (n, r) => { n.style.transform = r !== void 0 ? r : "none" }, checkIsScrollRoot: n => window.getComputedStyle(n).position === "fixed" }), jg = P.createContext({ transformPagePoint: n => n, isStatic: !1, reducedMotion: "never" }); function Ek(n = !0) { const r = P.useContext(Fu); if (r === null) return [!0, null]; const { isPresent: o, onExitComplete: s, register: l } = r, f = P.useId(); P.useEffect(() => { if (n) return l(f) }, [n]); const c = P.useCallback(() => n && s && s(f), [f, s, n]); return !o && s ? [!1, c] : [!0] } const Vg = P.createContext({ strict: !1 }), Tp = { animation: ["animate", "variants", "whileHover", "whileTap", "exit", "whileInView", "whileFocus", "whileDrag"], exit: ["exit"], drag: ["drag", "dragControls"], focus: ["whileFocus"], hover: ["whileHover", "onHoverStart", "onHoverEnd"], tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"], pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"], inView: ["whileInView", "onViewportEnter", "onViewportLeave"], layout: ["layout", "layoutId"] }; let Pp = !1; function Tk() { if (Pp) return; const n = {}; for (const r in Tp) n[r] = { isEnabled: o => Tp[r].some(s => !!o[s]) }; ug(n), Pp = !0 } function _g() { return Tk(), gS() } function Pk(n) { const r = _g(); for (const o in n) r[o] = { ...r[o], ...n[o] }; ug(r) } const Rk = new Set(["animate", "exit", "variants", "initial", "style", "values", "variants", "transition", "transformTemplate", "custom", "inherit", "onBeforeLayoutMeasure", "onAnimationStart", "onAnimationComplete", "onUpdate", "onDragStart", "onDrag", "onDragEnd", "onMeasureDragConstraints", "onDirectionLock", "onDragTransitionEnd", "_dragX", "_dragY", "onHoverStart", "onHoverEnd", "onViewportEnter", "onViewportLeave", "globalTapTarget", "propagate", "ignoreStrict", "viewport"]); function Ls(n) { return n.startsWith("while") || n.startsWith("drag") && n !== "draggable" || n.startsWith("layout") || n.startsWith("onTap") || n.startsWith("onPan") || n.startsWith("onLayout") || Rk.has(n) } let bg = n => !Ls(n); function Mk(n) { typeof n == "function" && (bg = r => r.startsWith("on") ? !Ls(r) : n(r)) } try { Mk(require("@emotion/is-prop-valid").default) } catch { } function Ak(n, r, o) { const s = {}; for (const l in n) l === "values" && typeof n.values == "object" || (bg(l) || o === !0 && Ls(l) || !r && !Ls(l) || n.draggable && l.startsWith("onDrag")) && (s[l] = n[l]); return s } const bs = P.createContext({}); function Lk(n, r) { if (_s(n)) { const { initial: o, animate: s } = n; return { initial: o === !1 || Ui(o) ? o : void 0, animate: Ui(s) ? s : void 0 } } return n.inherit !== !1 ? r : {} } function Nk(n) { const { initial: r, animate: o } = Lk(n, P.useContext(bs)); return P.useMemo(() => ({ initial: r, animate: o }), [Rp(r), Rp(o)]) } function Rp(n) { return Array.isArray(n) ? n.join(" ") : n } const dc = () => ({ style: {}, transform: {}, transformOrigin: {}, vars: {} }); function Ig(n, r, o) { for (const s in r) !rt(r[s]) && !gg(s, o) && (n[s] = r[s]) } function Dk({ transformTemplate: n }, r) { return P.useMemo(() => { const o = dc(); return cc(o, r, n), Object.assign({}, o.vars, o.style) }, [r]) } function jk(n, r) { const o = n.style || {}, s = {}; return Ig(s, o, n), Object.assign(s, Dk(n, r)), s } function Vk(n, r) { const o = {}, s = jk(n, r); return n.drag && n.dragListener !== !1 && (o.draggable = !1, s.userSelect = s.WebkitUserSelect = s.WebkitTouchCallout = "none", s.touchAction = n.drag === !0 ? "none" : `pan-${n.drag === "x" ? "y" : "x"}`), n.tabIndex === void 0 && (n.onTap || n.onTapStart || n.whileTap) && (o.tabIndex = 0), o.style = s, o } const Fg = () => ({ ...dc(), attrs: {} }); function _k(n, r, o, s) { const l = P.useMemo(() => { const f = Fg(); return yg(f, r, xg(s), n.transformTemplate, n.style), { ...f.attrs, style: { ...f.style } } }, [r]); if (n.style) { const f = {}; Ig(f, n.style, n), l.style = { ...f, ...l.style } } return l } const bk = ["animate", "circle", "defs", "desc", "ellipse", "g", "image", "line", "filter", "marker", "mask", "metadata", "path", "pattern", "polygon", "polyline", "rect", "stop", "switch", "symbol", "svg", "text", "tspan", "use", "view"]; function hc(n) { return typeof n != "string" || n.includes("-") ? !1 : !!(bk.indexOf(n) > -1 || /[A-Z]/u.test(n)) } function Ik(n, r, o, { latestValues: s }, l, f = !1, c) { const p = (c ?? hc(n) ? _k : Vk)(r, s, l, n), g = Ak(r, typeof n == "string", f), y = n !== P.Fragment ? { ...g, ...p, ref: o } : {}, { children: v } = r, x = P.useMemo(() => rt(v) ? v.get() : v, [v]); return P.createElement(n, { ...y, children: x }) } function Fk({ scrapeMotionValuesFromProps: n, createRenderState: r }, o, s, l) { return { latestValues: zk(o, s, l, n), renderState: r() } } function zk(n, r, o, s) { const l = {}, f = s(n, {}); for (const x in f) l[x] = ws(f[x]); let { initial: c, animate: h } = n; const p = _s(n), g = ag(n); r && g && !p && n.inherit !== !1 && (c === void 0 && (c = r.initial), h === void 0 && (h = r.animate)); let y = o ? o.initial === !1 : !1; y = y || c === !1; const v = y ? h : c; if (v && typeof v != "boolean" && !Vs(v)) { const x = Array.isArray(v) ? v : [v]; for (let C = 0; C < x.length; C++) { const M = nc(n, x[C]); if (M) { const { transitionEnd: N, transition: A, ...V } = M; for (const b in V) { let j = V[b]; if (Array.isArray(j)) { const W = y ? j.length - 1 : 0; j = j[W] } j !== null && (l[b] = j) } for (const b in N) l[b] = N[b] } } } return l } const zg = n => (r, o) => { const s = P.useContext(bs), l = P.useContext(Fu), f = () => Fk(n, r, s, l); return o ? f() : Bx(f) }, Ok = zg({ scrapeMotionValuesFromProps: fc, createRenderState: dc }), Bk = zg({ scrapeMotionValuesFromProps: wg, createRenderState: Fg }), Uk = Symbol.for("motionComponentSymbol"); function $k(n, r, o) { const s = P.useRef(o); P.useInsertionEffect(() => { s.current = o }); const l = P.useRef(null); return P.useCallback(f => { var h; f && ((h = n.onMount) == null || h.call(n, f)), r && (f ? r.mount(f) : r.unmount()); const c = s.current; if (typeof c == "function") if (f) { const p = c(f); typeof p == "function" && (l.current = p) } else l.current ? (l.current(), l.current = null) : c(f); else c && (c.current = f) }, [r]) } const Og = P.createContext({}); function Mr(n) { return n && typeof n == "object" && Object.prototype.hasOwnProperty.call(n, "current") } function Wk(n, r, o, s, l, f) { var j, W; const { visualElement: c } = P.useContext(bs), h = P.useContext(Vg), p = P.useContext(Fu), g = P.useContext(jg), y = g.reducedMotion, v = g.skipAnimations, x = P.useRef(null), C = P.useRef(!1); s = s || h.renderer, !x.current && s && (x.current = s(n, { visualState: r, parent: c, props: o, presenceContext: p, blockInitialAnimation: p ? p.initial === !1 : !1, reducedMotionConfig: y, skipAnimations: v, isSVG: f }), C.current && x.current && (x.current.manuallyAnimateOnMount = !0)); const M = x.current, N = P.useContext(Og); M && !M.projection && l && (M.type === "html" || M.type === "svg") && Hk(x.current, o, l, N); const A = P.useRef(!1); P.useInsertionEffect(() => { M && A.current && M.update(o, p) }); const V = o[Ym], b = P.useRef(!!V && !((j = window.MotionHandoffIsComplete) != null && j.call(window, V)) && ((W = window.MotionHasOptimisedAnimation) == null ? void 0 : W.call(window, V))); return Ux(() => { C.current = !0, M && (A.current = !0, window.MotionIsMounted = !0, M.updateFeatures(), M.scheduleRenderMicrotask(), b.current && M.animationState && M.animationState.animateChanges()) }), P.useEffect(() => { M && (!b.current && M.animationState && M.animationState.animateChanges(), b.current && (queueMicrotask(() => { var U; (U = window.MotionHandoffMarkAsComplete) == null || U.call(window, V) }), b.current = !1), M.enteringChildren = void 0) }), M } function Hk(n, r, o, s) { const { layoutId: l, layout: f, drag: c, dragConstraints: h, layoutScroll: p, layoutRoot: g, layoutCrossfade: y } = r; n.projection = new o(n.latestValues, r["data-framer-portal-id"] ? void 0 : Bg(n.parent)), n.projection.setOptions({ layoutId: l, layout: f, alwaysMeasureLayout: !!c || h && Mr(h), visualElement: n, animationType: typeof f == "string" ? f : "both", initialPromotionConfig: s, crossfade: y, layoutScroll: p, layoutRoot: g }) } function Bg(n) { if (n) return n.options.allowProjection !== !1 ? n.projection : Bg(n.parent) } function Ql(n, { forwardMotionProps: r = !1, type: o } = {}, s, l) { s && Pk(s); const f = o ? o === "svg" : hc(n), c = f ? Bk : Ok; function h(g, y) { let v; const x = { ...P.useContext(jg), ...g, layoutId: Kk(g) }, { isStatic: C } = x, M = Nk(g), N = c(g, C); if (!C && um) { Gk(); const A = Yk(x); v = A.MeasureLayout, M.visualElement = Wk(n, N, x, l, A.ProjectionNode, f) } return E.jsxs(bs.Provider, { value: M, children: [v && M.visualElement ? E.jsx(v, { visualElement: M.visualElement, ...x }) : null, Ik(n, g, $k(N, M.visualElement, y), N, C, r, f)] }) } h.displayName = `motion.${typeof n == "string" ? n : `create(${n.displayName ?? n.name ?? ""})`}`; const p = P.forwardRef(h); return p[Uk] = n, p } function Kk({ layoutId: n }) { const r = P.useContext(lm).id; return r && n !== void 0 ? r + "-" + n : n } function Gk(n, r) { P.useContext(Vg).strict } function Yk(n) { const r = _g(), { drag: o, layout: s } = r; if (!o && !s) return {}; const l = { ...o, ...s }; return { MeasureLayout: o != null && o.isEnabled(n) || s != null && s.isEnabled(n) ? l.MeasureLayout : void 0, ProjectionNode: l.ProjectionNode } } function Xk(n, r) { if (typeof Proxy > "u") return Ql; const o = new Map, s = (f, c) => Ql(f, c, n, r), l = (f, c) => s(f, c); return new Proxy(l, { get: (f, c) => c === "create" ? s : (o.has(c) || o.set(c, Ql(c, void 0, n, r)), o.get(c)) }) } const Qk = (n, r) => r.isSVG ?? hc(n) ? new jS(r) : new RS(r, { allowProjection: n !== P.Fragment }); class Zk extends jn { constructor(r) { super(r), r.animationState || (r.animationState = FS(r)) } updateAnimationControlsSubscription() { const { animate: r } = this.node.getProps(); Vs(r) && (this.unmountControls = r.subscribe(this.node)) } mount() { this.updateAnimationControlsSubscription() } update() { const { animate: r } = this.node.getProps(), { animate: o } = this.node.prevProps || {}; r !== o && this.updateAnimationControlsSubscription() } unmount() { var r; this.node.animationState.reset(), (r = this.unmountControls) == null || r.call(this) } } let qk = 0; class Jk extends jn { constructor() { super(...arguments), this.id = qk++ } update() { if (!this.node.presenceContext) return; const { isPresent: r, onExitComplete: o } = this.node.presenceContext, { isPresent: s } = this.node.prevPresenceContext || {}; if (!this.node.animationState || r === s) return; const l = this.node.animationState.setActive("exit", !r); o && !r && l.then(() => { o(this.id) }) } mount() { const { register: r, onExitComplete: o } = this.node.presenceContext || {}; o && o(this.id), r && (this.unmount = r(this.id)) } unmount() { } } const eC = { animation: { Feature: Zk }, exit: { Feature: Jk } }; function Qi(n) { return { point: { x: n.pageX, y: n.pageY } } } const tC = n => r => sc(r) && n(r, Qi(r)); function bi(n, r, o, s) { return $i(n, r, tC(o), s) } const Ug = ({ current: n }) => n ? n.ownerDocument.defaultView : null, Mp = (n, r) => Math.abs(n - r); function nC(n, r) { const o = Mp(n.x, r.x), s = Mp(n.y, r.y); return Math.sqrt(o ** 2 + s ** 2) } const Ap = new Set(["auto", "scroll"]); class $g { constructor(r, o, { transformPagePoint: s, contextWindow: l = window, dragSnapToOrigin: f = !1, distanceThreshold: c = 3, element: h } = {}) { if (this.startEvent = null, this.lastMoveEvent = null, this.lastMoveEventInfo = null, this.handlers = {}, this.contextWindow = window, this.scrollPositions = new Map, this.removeScrollListeners = null, this.onElementScroll = C => { this.handleScroll(C.target) }, this.onWindowScroll = () => { this.handleScroll(window) }, this.updatePoint = () => { if (!(this.lastMoveEvent && this.lastMoveEventInfo)) return; const C = ql(this.lastMoveEventInfo, this.history), M = this.startEvent !== null, N = nC(C.offset, { x: 0, y: 0 }) >= this.distanceThreshold; if (!M && !N) return; const { point: A } = C, { timestamp: V } = qe; this.history.push({ ...A, timestamp: V }); const { onStart: b, onMove: j } = this.handlers; M || (b && b(this.lastMoveEvent, C), this.startEvent = this.lastMoveEvent), j && j(this.lastMoveEvent, C) }, this.handlePointerMove = (C, M) => { this.lastMoveEvent = C, this.lastMoveEventInfo = Zl(M, this.transformPagePoint), ke.update(this.updatePoint, !0) }, this.handlePointerUp = (C, M) => { this.end(); const { onEnd: N, onSessionEnd: A, resumeAnimation: V } = this.handlers; if ((this.dragSnapToOrigin || !this.startEvent) && V && V(), !(this.lastMoveEvent && this.lastMoveEventInfo)) return; const b = ql(C.type === "pointercancel" ? this.lastMoveEventInfo : Zl(M, this.transformPagePoint), this.history); this.startEvent && N && N(C, b), A && A(C, b) }, !sc(r)) return; this.dragSnapToOrigin = f, this.handlers = o, this.transformPagePoint = s, this.distanceThreshold = c, this.contextWindow = l || window; const p = Qi(r), g = Zl(p, this.transformPagePoint), { point: y } = g, { timestamp: v } = qe; this.history = [{ ...y, timestamp: v }]; const { onSessionStart: x } = o; x && x(r, ql(g, this.history)), this.removeListeners = Gi(bi(this.contextWindow, "pointermove", this.handlePointerMove), bi(this.contextWindow, "pointerup", this.handlePointerUp), bi(this.contextWindow, "pointercancel", this.handlePointerUp)), h && this.startScrollTracking(h) } startScrollTracking(r) { let o = r.parentElement; for (; o;) { const s = getComputedStyle(o); (Ap.has(s.overflowX) || Ap.has(s.overflowY)) && this.scrollPositions.set(o, { x: o.scrollLeft, y: o.scrollTop }), o = o.parentElement } this.scrollPositions.set(window, { x: window.scrollX, y: window.scrollY }), window.addEventListener("scroll", this.onElementScroll, { capture: !0, passive: !0 }), window.addEventListener("scroll", this.onWindowScroll, { passive: !0 }), this.removeScrollListeners = () => { window.removeEventListener("scroll", this.onElementScroll, { capture: !0 }), window.removeEventListener("scroll", this.onWindowScroll) } } handleScroll(r) { const o = this.scrollPositions.get(r); if (!o) return; const s = r === window, l = s ? { x: window.scrollX, y: window.scrollY } : { x: r.scrollLeft, y: r.scrollTop }, f = { x: l.x - o.x, y: l.y - o.y }; f.x === 0 && f.y === 0 || (s ? this.lastMoveEventInfo && (this.lastMoveEventInfo.point.x += f.x, this.lastMoveEventInfo.point.y += f.y) : this.history.length > 0 && (this.history[0].x -= f.x, this.history[0].y -= f.y), this.scrollPositions.set(r, l), ke.update(this.updatePoint, !0)) } updateHandlers(r) { this.handlers = r } end() { this.removeListeners && this.removeListeners(), this.removeScrollListeners && this.removeScrollListeners(), this.scrollPositions.clear(), Nn(this.updatePoint) } } function Zl(n, r) { return r ? { point: r(n.point) } : n } function Lp(n, r) { return { x: n.x - r.x, y: n.y - r.y } } function ql({ point: n }, r) { return { point: n, delta: Lp(n, Wg(r)), offset: Lp(n, rC(r)), velocity: iC(r, .1) } } function rC(n) { return n[0] } function Wg(n) { return n[n.length - 1] } function iC(n, r) { if (n.length < 2) return { x: 0, y: 0 }; let o = n.length - 1, s = null; const l = Wg(n); for (; o >= 0 && (s = n[o], !(l.timestamp - s.timestamp > bt(r)));)o--; if (!s) return { x: 0, y: 0 }; s === n[0] && n.length > 2 && l.timestamp - s.timestamp > bt(r) * 2 && (s = n[1]); const f = Et(l.timestamp - s.timestamp); if (f === 0) return { x: 0, y: 0 }; const c = { x: (l.x - s.x) / f, y: (l.y - s.y) / f }; return c.x === 1 / 0 && (c.x = 0), c.y === 1 / 0 && (c.y = 0), c } function oC(n, { min: r, max: o }, s) { return r !== void 0 && n < r ? n = s ? Ae(r, n, s.min) : Math.max(n, r) : o !== void 0 && n > o && (n = s ? Ae(o, n, s.max) : Math.min(n, o)), n } function Np(n, r, o) { return { min: r !== void 0 ? n.min + r : void 0, max: o !== void 0 ? n.max + o - (n.max - n.min) : void 0 } } function sC(n, { top: r, left: o, bottom: s, right: l }) { return { x: Np(n.x, o, l), y: Np(n.y, r, s) } } function Dp(n, r) { let o = r.min - n.min, s = r.max - n.max; return r.max - r.min < n.max - n.min && ([o, s] = [s, o]), { min: o, max: s } } function aC(n, r) { return { x: Dp(n.x, r.x), y: Dp(n.y, r.y) } } function lC(n, r) { let o = .5; const s = at(n), l = at(r); return l > s ? o = zi(r.min, r.max - s, n.min) : s > l && (o = zi(n.min, n.max - l, r.min)), Kt(0, 1, o) } function uC(n, r) { const o = {}; return r.min !== void 0 && (o.min = r.min - n.min), r.max !== void 0 && (o.max = r.max - n.min), o } const Ru = .35; function cC(n = Ru) { return n === !1 ? n = 0 : n === !0 && (n = Ru), { x: jp(n, "left", "right"), y: jp(n, "top", "bottom") } } function jp(n, r, o) { return { min: Vp(n, r), max: Vp(n, o) } } function Vp(n, r) { return typeof n == "number" ? n : n[r] || 0 } const fC = new WeakMap; class dC { constructor(r) { this.openDragLock = null, this.isDragging = !1, this.currentDirection = null, this.originPoint = { x: 0, y: 0 }, this.constraints = !1, this.hasMutatedConstraints = !1, this.elastic = Be(), this.latestPointerEvent = null, this.latestPanInfo = null, this.visualElement = r } start(r, { snapToCursor: o = !1, distanceThreshold: s } = {}) { const { presenceContext: l } = this.visualElement; if (l && l.isPresent === !1) return; const f = v => { o && this.snapToCursor(Qi(v).point), this.stopAnimation() }, c = (v, x) => { const { drag: C, dragPropagation: M, onDragStart: N } = this.getProps(); if (C && !M && (this.openDragLock && this.openDragLock(), this.openDragLock = K1(C), !this.openDragLock)) return; this.latestPointerEvent = v, this.latestPanInfo = x, this.isDragging = !0, this.currentDirection = null, this.resolveConstraints(), this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !0, this.visualElement.projection.target = void 0), $t(V => { let b = this.getAxisMotionValue(V).get() || 0; if (Wt.test(b)) { const { projection: j } = this.visualElement; if (j && j.layout) { const W = j.layout.layoutBox[V]; W && (b = at(W) * (parseFloat(b) / 100)) } } this.originPoint[V] = b }), N && ke.update(() => N(v, x), !1, !0), wu(this.visualElement, "transform"); const { animationState: A } = this.visualElement; A && A.setActive("whileDrag", !0) }, h = (v, x) => { this.latestPointerEvent = v, this.latestPanInfo = x; const { dragPropagation: C, dragDirectionLock: M, onDirectionLock: N, onDrag: A } = this.getProps(); if (!C && !this.openDragLock) return; const { offset: V } = x; if (M && this.currentDirection === null) { this.currentDirection = pC(V), this.currentDirection !== null && N && N(this.currentDirection); return } this.updateAxis("x", x.point, V), this.updateAxis("y", x.point, V), this.visualElement.render(), A && ke.update(() => A(v, x), !1, !0) }, p = (v, x) => { this.latestPointerEvent = v, this.latestPanInfo = x, this.stop(v, x), this.latestPointerEvent = null, this.latestPanInfo = null }, g = () => { const { dragSnapToOrigin: v } = this.getProps(); (v || this.constraints) && this.startAnimation({ x: 0, y: 0 }) }, { dragSnapToOrigin: y } = this.getProps(); this.panSession = new $g(r, { onSessionStart: f, onStart: c, onMove: h, onSessionEnd: p, resumeAnimation: g }, { transformPagePoint: this.visualElement.getTransformPagePoint(), dragSnapToOrigin: y, distanceThreshold: s, contextWindow: Ug(this.visualElement), element: this.visualElement.current }) } stop(r, o) { const s = r || this.latestPointerEvent, l = o || this.latestPanInfo, f = this.isDragging; if (this.cancel(), !f || !l || !s) return; const { velocity: c } = l; this.startAnimation(c); const { onDragEnd: h } = this.getProps(); h && ke.postRender(() => h(s, l)) } cancel() { this.isDragging = !1; const { projection: r, animationState: o } = this.visualElement; r && (r.isAnimationBlocked = !1), this.endPanSession(); const { dragPropagation: s } = this.getProps(); !s && this.openDragLock && (this.openDragLock(), this.openDragLock = null), o && o.setActive("whileDrag", !1) } endPanSession() { this.panSession && this.panSession.end(), this.panSession = void 0 } updateAxis(r, o, s) { const { drag: l } = this.getProps(); if (!s || !fs(r, l, this.currentDirection)) return; const f = this.getAxisMotionValue(r); let c = this.originPoint[r] + s[r]; this.constraints && this.constraints[r] && (c = oC(c, this.constraints[r], this.elastic[r])), f.set(c) } resolveConstraints() { var f; const { dragConstraints: r, dragElastic: o } = this.getProps(), s = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(!1) : (f = this.visualElement.projection) == null ? void 0 : f.layout, l = this.constraints; r && Mr(r) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : r && s ? this.constraints = sC(s.layoutBox, r) : this.constraints = !1, this.elastic = cC(o), l !== this.constraints && !Mr(r) && s && this.constraints && !this.hasMutatedConstraints && $t(c => { this.constraints !== !1 && this.getAxisMotionValue(c) && (this.constraints[c] = uC(s.layoutBox[c], this.constraints[c])) }) } resolveRefConstraints() { const { dragConstraints: r, onMeasureDragConstraints: o } = this.getProps(); if (!r || !Mr(r)) return !1; const s = r.current, { projection: l } = this.visualElement; if (!l || !l.layout) return !1; const f = SS(s, l.root, this.visualElement.getTransformPagePoint()); let c = aC(l.layout.layoutBox, f); if (o) { const h = o(vS(c)); this.hasMutatedConstraints = !!h, h && (c = fg(h)) } return c } startAnimation(r) { const { drag: o, dragMomentum: s, dragElastic: l, dragTransition: f, dragSnapToOrigin: c, onDragTransitionEnd: h } = this.getProps(), p = this.constraints || {}, g = $t(y => { if (!fs(y, o, this.currentDirection)) return; let v = p && p[y] || {}; c && (v = { min: 0, max: 0 }); const x = l ? 200 : 1e6, C = l ? 40 : 1e7, M = { type: "inertia", velocity: s ? r[y] : 0, bounceStiffness: x, bounceDamping: C, timeConstant: 750, restDelta: 1, restSpeed: 10, ...f, ...v }; return this.startAxisValueAnimation(y, M) }); return Promise.all(g).then(h) } startAxisValueAnimation(r, o) { const s = this.getAxisMotionValue(r); return wu(this.visualElement, r), s.start(tc(r, s, 0, o, this.visualElement, !1)) } stopAnimation() { $t(r => this.getAxisMotionValue(r).stop()) } getAxisMotionValue(r) { const o = `_drag${r.toUpperCase()}`, s = this.visualElement.getProps(), l = s[o]; return l || this.visualElement.getValue(r, (s.initial ? s.initial[r] : void 0) || 0) } snapToCursor(r) { $t(o => { const { drag: s } = this.getProps(); if (!fs(o, s, this.currentDirection)) return; const { projection: l } = this.visualElement, f = this.getAxisMotionValue(o); if (l && l.layout) { const { min: c, max: h } = l.layout.layoutBox[o], p = f.get() || 0; f.set(r[o] - Ae(c, h, .5) + p) } }) } scalePositionWithinConstraints() { if (!this.visualElement.current) return; const { drag: r, dragConstraints: o } = this.getProps(), { projection: s } = this.visualElement; if (!Mr(o) || !s || !this.constraints) return; this.stopAnimation(); const l = { x: 0, y: 0 }; $t(c => { const h = this.getAxisMotionValue(c); if (h && this.constraints !== !1) { const p = h.get(); l[c] = lC({ min: p, max: p }, this.constraints[c]) } }); const { transformTemplate: f } = this.visualElement.getProps(); this.visualElement.current.style.transform = f ? f({}, "") : "none", s.root && s.root.updateScroll(), s.updateLayout(), this.constraints = !1, this.resolveConstraints(), $t(c => { if (!fs(c, r, null)) return; const h = this.getAxisMotionValue(c), { min: p, max: g } = this.constraints[c]; h.set(Ae(p, g, l[c])) }), this.visualElement.render() } addListeners() { if (!this.visualElement.current) return; fC.set(this.visualElement, this); const r = this.visualElement.current, o = bi(r, "pointerdown", g => { const { drag: y, dragListener: v = !0 } = this.getProps(), x = g.target, C = x !== r && q1(x); y && v && !C && this.start(g) }); let s; const l = () => { const { dragConstraints: g } = this.getProps(); Mr(g) && g.current && (this.constraints = this.resolveRefConstraints(), s || (s = hC(r, g.current, () => this.scalePositionWithinConstraints()))) }, { projection: f } = this.visualElement, c = f.addEventListener("measure", l); f && !f.layout && (f.root && f.root.updateScroll(), f.updateLayout()), ke.read(l); const h = $i(window, "resize", () => this.scalePositionWithinConstraints()), p = f.addEventListener("didUpdate", (({ delta: g, hasLayoutChanged: y }) => { this.isDragging && y && ($t(v => { const x = this.getAxisMotionValue(v); x && (this.originPoint[v] += g[v].translate, x.set(x.get() + g[v].translate)) }), this.visualElement.render()) })); return () => { h(), o(), c(), p && p(), s && s() } } getProps() { const r = this.visualElement.getProps(), { drag: o = !1, dragDirectionLock: s = !1, dragPropagation: l = !1, dragConstraints: f = !1, dragElastic: c = Ru, dragMomentum: h = !0 } = r; return { ...r, drag: o, dragDirectionLock: s, dragPropagation: l, dragConstraints: f, dragElastic: c, dragMomentum: h } } } function _p(n) { let r = !0; return () => { if (r) { r = !1; return } n() } } function hC(n, r, o) { const s = Wh(n, _p(o)), l = Wh(r, _p(o)); return () => { s(), l() } } function fs(n, r, o) { return (r === !0 || r === n) && (o === null || o === n) } function pC(n, r = 10) { let o = null; return Math.abs(n.y) > r ? o = "y" : Math.abs(n.x) > r && (o = "x"), o } class mC extends jn { constructor(r) { super(r), this.removeGroupControls = Tt, this.removeListeners = Tt, this.controls = new dC(r) } mount() { const { dragControls: r } = this.node.getProps(); r && (this.removeGroupControls = r.subscribe(this.controls)), this.removeListeners = this.controls.addListeners() || Tt } update() { const { dragControls: r } = this.node.getProps(), { dragControls: o } = this.node.prevProps || {}; r !== o && (this.removeGroupControls(), r && (this.removeGroupControls = r.subscribe(this.controls))) } unmount() { this.removeGroupControls(), this.removeListeners(), this.controls.isDragging || this.controls.endPanSession() } } const Jl = n => (r, o) => { n && ke.update(() => n(r, o), !1, !0) }; class gC extends jn { constructor() { super(...arguments), this.removePointerDownListener = Tt } onPointerDown(r) { this.session = new $g(r, this.createPanHandlers(), { transformPagePoint: this.node.getTransformPagePoint(), contextWindow: Ug(this.node) }) } createPanHandlers() { const { onPanSessionStart: r, onPanStart: o, onPan: s, onPanEnd: l } = this.node.getProps(); return { onSessionStart: Jl(r), onStart: Jl(o), onMove: Jl(s), onEnd: (f, c) => { delete this.session, l && ke.postRender(() => l(f, c)) } } } mount() { this.removePointerDownListener = bi(this.node.current, "pointerdown", r => this.onPointerDown(r)) } update() { this.session && this.session.updateHandlers(this.createPanHandlers()) } unmount() { this.removePointerDownListener(), this.session && this.session.end() } } let eu = !1; class yC extends P.Component { componentDidMount() { const { visualElement: r, layoutGroup: o, switchLayoutGroup: s, layoutId: l } = this.props, { projection: f } = r; f && (o.group && o.group.add(f), s && s.register && l && s.register(f), eu && f.root.didUpdate(), f.addEventListener("animationComplete", () => { this.safeToRemove() }), f.setOptions({ ...f.options, layoutDependency: this.props.layoutDependency, onExitComplete: () => this.safeToRemove() })), Ss.hasEverUpdated = !0 } getSnapshotBeforeUpdate(r) { const { layoutDependency: o, visualElement: s, drag: l, isPresent: f } = this.props, { projection: c } = s; return c && (c.isPresent = f, r.layoutDependency !== o && c.setOptions({ ...c.options, layoutDependency: o }), eu = !0, l || r.layoutDependency !== o || o === void 0 || r.isPresent !== f ? c.willUpdate() : this.safeToRemove(), r.isPresent !== f && (f ? c.promote() : c.relegate() || ke.postRender(() => { const h = c.getStack(); (!h || !h.members.length) && this.safeToRemove() }))), null } componentDidUpdate() { const { projection: r } = this.props.visualElement; r && (r.root.didUpdate(), oc.postRender(() => { !r.currentAnimation && r.isLead() && this.safeToRemove() })) } componentWillUnmount() { const { visualElement: r, layoutGroup: o, switchLayoutGroup: s } = this.props, { projection: l } = r; eu = !0, l && (l.scheduleCheckAfterUnmount(), o && o.group && o.group.remove(l), s && s.deregister && s.deregister(l)) } safeToRemove() { const { safeToRemove: r } = this.props; r && r() } render() { return null } } function Hg(n) { const [r, o] = Ek(), s = P.useContext(lm); return E.jsx(yC, { ...n, layoutGroup: s, switchLayoutGroup: P.useContext(Og), isPresent: r, safeToRemove: o }) } const vC = { pan: { Feature: gC }, drag: { Feature: mC, ProjectionNode: Dg, MeasureLayout: Hg } }; function bp(n, r, o) { const { props: s } = n; n.animationState && s.whileHover && n.animationState.setActive("whileHover", o === "Start"); const l = "onHover" + o, f = s[l]; f && ke.postRender(() => f(r, Qi(r))) } class xC extends jn { mount() { const { current: r } = this.node; r && (this.unmount = Y1(r, (o, s) => (bp(this.node, s, "Start"), l => bp(this.node, l, "End")))) } unmount() { } } class wC extends jn { constructor() { super(...arguments), this.isActive = !1 } onFocus() { let r = !1; try { r = this.node.current.matches(":focus-visible") } catch { r = !0 } !r || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !0), this.isActive = !0) } onBlur() { !this.isActive || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !1), this.isActive = !1) } mount() { this.unmount = Gi($i(this.node.current, "focus", () => this.onFocus()), $i(this.node.current, "blur", () => this.onBlur())) } unmount() { } } function Ip(n, r, o) { const { props: s } = n; if (n.current instanceof HTMLButtonElement && n.current.disabled) return; n.animationState && s.whileTap && n.animationState.setActive("whileTap", o === "Start"); const l = "onTap" + (o === "End" ? "" : o), f = s[l]; f && ke.postRender(() => f(r, Qi(r))) } class SC extends jn { mount() { const { current: r } = this.node; if (!r) return; const { globalTapTarget: o, propagate: s } = this.node.props; this.unmount = eS(r, (l, f) => (Ip(this.node, f, "Start"), (c, { success: h }) => Ip(this.node, c, h ? "End" : "Cancel")), { useGlobalTarget: o, stopPropagation: (s == null ? void 0 : s.tap) === !1 }) } unmount() { } } const Mu = new WeakMap, tu = new WeakMap, kC = n => { const r = Mu.get(n.target); r && r(n) }, CC = n => { n.forEach(kC) }; function EC({ root: n, ...r }) { const o = n || document; tu.has(o) || tu.set(o, {}); const s = tu.get(o), l = JSON.stringify(r); return s[l] || (s[l] = new IntersectionObserver(CC, { root: n, ...r })), s[l] } function TC(n, r, o) { const s = EC(r); return Mu.set(n, o), s.observe(n), () => { Mu.delete(n), s.unobserve(n) } } const PC = { some: 0, all: 1 }; class RC extends jn { constructor() { super(...arguments), this.hasEnteredView = !1, this.isInView = !1 } startObserver() { this.unmount(); const { viewport: r = {} } = this.node.getProps(), { root: o, margin: s, amount: l = "some", once: f } = r, c = { root: o ? o.current : void 0, rootMargin: s, threshold: typeof l == "number" ? l : PC[l] }, h = p => { const { isIntersecting: g } = p; if (this.isInView === g || (this.isInView = g, f && !g && this.hasEnteredView)) return; g && (this.hasEnteredView = !0), this.node.animationState && this.node.animationState.setActive("whileInView", g); const { onViewportEnter: y, onViewportLeave: v } = this.node.getProps(), x = g ? y : v; x && x(p) }; return TC(this.node.current, c, h) } mount() { this.startObserver() } update() { if (typeof IntersectionObserver > "u") return; const { props: r, prevProps: o } = this.node;["amount", "margin", "root"].some(MC(r, o)) && this.startObserver() } unmount() { } } function MC({ viewport: n = {} }, { viewport: r = {} } = {}) { return o => n[o] !== r[o] } const AC = { inView: { Feature: RC }, tap: { Feature: SC }, focus: { Feature: wC }, hover: { Feature: xC } }, LC = { layout: { ProjectionNode: Dg, MeasureLayout: Hg } }, NC = { ...eC, ...AC, ...vC, ...LC }, Ns = Xk(NC, Qk); function Kg(n) { var r, o, s = ""; if (typeof n == "string" || typeof n == "number") s += n; else if (typeof n == "object") if (Array.isArray(n)) { var l = n.length; for (r = 0; r < l; r++)n[r] && (o = Kg(n[r])) && (s && (s += " "), s += o) } else for (o in n) n[o] && (s && (s += " "), s += o); return s } function DC() { for (var n, r, o = 0, s = "", l = arguments.length; o < l; o++)(n = arguments[o]) && (r = Kg(n)) && (s && (s += " "), s += r); return s } const pc = "-", jC = n => { const r = _C(n), { conflictingClassGroups: o, conflictingClassGroupModifiers: s } = n; return { getClassGroupId: c => { const h = c.split(pc); return h[0] === "" && h.length !== 1 && h.shift(), Gg(h, r) || VC(c) }, getConflictingClassGroupIds: (c, h) => { const p = o[c] || []; return h && s[c] ? [...p, ...s[c]] : p } } }, Gg = (n, r) => { var c; if (n.length === 0) return r.classGroupId; const o = n[0], s = r.nextPart.get(o), l = s ? Gg(n.slice(1), s) : void 0; if (l) return l; if (r.validators.length === 0) return; const f = n.join(pc); return (c = r.validators.find(({ validator: h }) => h(f))) == null ? void 0 : c.classGroupId }, Fp = /^\[(.+)\]$/, VC = n => { if (Fp.test(n)) { const r = Fp.exec(n)[1], o = r == null ? void 0 : r.substring(0, r.indexOf(":")); if (o) return "arbitrary.." + o } }, _C = n => { const { theme: r, classGroups: o } = n, s = { nextPart: new Map, validators: [] }; for (const l in o) Au(o[l], s, l, r); return s }, Au = (n, r, o, s) => { n.forEach(l => { if (typeof l == "string") { const f = l === "" ? r : zp(r, l); f.classGroupId = o; return } if (typeof l == "function") { if (bC(l)) { Au(l(s), r, o, s); return } r.validators.push({ validator: l, classGroupId: o }); return } Object.entries(l).forEach(([f, c]) => { Au(c, zp(r, f), o, s) }) }) }, zp = (n, r) => { let o = n; return r.split(pc).forEach(s => { o.nextPart.has(s) || o.nextPart.set(s, { nextPart: new Map, validators: [] }), o = o.nextPart.get(s) }), o }, bC = n => n.isThemeGetter, IC = n => { if (n < 1) return { get: () => { }, set: () => { } }; let r = 0, o = new Map, s = new Map; const l = (f, c) => { o.set(f, c), r++, r > n && (r = 0, s = o, o = new Map) }; return { get(f) { let c = o.get(f); if (c !== void 0) return c; if ((c = s.get(f)) !== void 0) return l(f, c), c }, set(f, c) { o.has(f) ? o.set(f, c) : l(f, c) } } }, Lu = "!", Nu = ":", FC = Nu.length, zC = n => { const { prefix: r, experimentalParseClassName: o } = n; let s = l => { const f = []; let c = 0, h = 0, p = 0, g; for (let M = 0; M < l.length; M++) { let N = l[M]; if (c === 0 && h === 0) { if (N === Nu) { f.push(l.slice(p, M)), p = M + FC; continue } if (N === "/") { g = M; continue } } N === "[" ? c++ : N === "]" ? c-- : N === "(" ? h++ : N === ")" && h-- } const y = f.length === 0 ? l : l.substring(p), v = OC(y), x = v !== y, C = g && g > p ? g - p : void 0; return { modifiers: f, hasImportantModifier: x, baseClassName: v, maybePostfixModifierPosition: C } }; if (r) { const l = r + Nu, f = s; s = c => c.startsWith(l) ? f(c.substring(l.length)) : { isExternal: !0, modifiers: [], hasImportantModifier: !1, baseClassName: c, maybePostfixModifierPosition: void 0 } } if (o) { const l = s; s = f => o({ className: f, parseClassName: l }) } return s }, OC = n => n.endsWith(Lu) ? n.substring(0, n.length - 1) : n.startsWith(Lu) ? n.substring(1) : n, BC = n => { const r = Object.fromEntries(n.orderSensitiveModifiers.map(s => [s, !0])); return s => { if (s.length <= 1) return s; const l = []; let f = []; return s.forEach(c => { c[0] === "[" || r[c] ? (l.push(...f.sort(), c), f = []) : f.push(c) }), l.push(...f.sort()), l } }, UC = n => ({ cache: IC(n.cacheSize), parseClassName: zC(n), sortModifiers: BC(n), ...jC(n) }), $C = /\s+/, WC = (n, r) => { const { parseClassName: o, getClassGroupId: s, getConflictingClassGroupIds: l, sortModifiers: f } = r, c = [], h = n.trim().split($C); let p = ""; for (let g = h.length - 1; g >= 0; g -= 1) { const y = h[g], { isExternal: v, modifiers: x, hasImportantModifier: C, baseClassName: M, maybePostfixModifierPosition: N } = o(y); if (v) { p = y + (p.length > 0 ? " " + p : p); continue } let A = !!N, V = s(A ? M.substring(0, N) : M); if (!V) { if (!A) { p = y + (p.length > 0 ? " " + p : p); continue } if (V = s(M), !V) { p = y + (p.length > 0 ? " " + p : p); continue } A = !1 } const b = f(x).join(":"), j = C ? b + Lu : b, W = j + V; if (c.includes(W)) continue; c.push(W); const U = l(V, A); for (let J = 0; J < U.length; ++J) { const se = U[J]; c.push(j + se) } p = y + (p.length > 0 ? " " + p : p) } return p }; function HC() { let n = 0, r, o, s = ""; for (; n < arguments.length;)(r = arguments[n++]) && (o = Yg(r)) && (s && (s += " "), s += o); return s } const Yg = n => { if (typeof n == "string") return n; let r, o = ""; for (let s = 0; s < n.length; s++)n[s] && (r = Yg(n[s])) && (o && (o += " "), o += r); return o }; function KC(n, ...r) { let o, s, l, f = c; function c(p) { const g = r.reduce((y, v) => v(y), n()); return o = UC(g), s = o.cache.get, l = o.cache.set, f = h, h(p) } function h(p) { const g = s(p); if (g) return g; const y = WC(p, o); return l(p, y), y } return function () { return f(HC.apply(null, arguments)) } } const Oe = n => { const r = o => o[n] || []; return r.isThemeGetter = !0, r }, Xg = /^\[(?:(\w[\w-]*):)?(.+)\]$/i, Qg = /^\((?:(\w[\w-]*):)?(.+)\)$/i, GC = /^\d+\/\d+$/, YC = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/, XC = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/, QC = /^(rgba?|hsla?|hwb|(ok)?(lab|lch))\(.+\)$/, ZC = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/, qC = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/, Rr = n => GC.test(n), fe = n => !!n && !Number.isNaN(Number(n)), Rn = n => !!n && Number.isInteger(Number(n)), nu = n => n.endsWith("%") && fe(n.slice(0, -1)), tn = n => YC.test(n), JC = () => !0, eE = n => XC.test(n) && !QC.test(n), Zg = () => !1, tE = n => ZC.test(n), nE = n => qC.test(n), rE = n => !X(n) && !Q(n), iE = n => Br(n, ey, Zg), X = n => Xg.test(n), Qn = n => Br(n, ty, eE), ru = n => Br(n, uE, fe), Op = n => Br(n, qg, Zg), oE = n => Br(n, Jg, nE), ds = n => Br(n, ny, tE), Q = n => Qg.test(n), Ni = n => Ur(n, ty), sE = n => Ur(n, cE), Bp = n => Ur(n, qg), aE = n => Ur(n, ey), lE = n => Ur(n, Jg), hs = n => Ur(n, ny, !0), Br = (n, r, o) => { const s = Xg.exec(n); return s ? s[1] ? r(s[1]) : o(s[2]) : !1 }, Ur = (n, r, o = !1) => { const s = Qg.exec(n); return s ? s[1] ? r(s[1]) : o : !1 }, qg = n => n === "position" || n === "percentage", Jg = n => n === "image" || n === "url", ey = n => n === "length" || n === "size" || n === "bg-size", ty = n => n === "length", uE = n => n === "number", cE = n => n === "family-name", ny = n => n === "shadow", fE = () => { const n = Oe("color"), r = Oe("font"), o = Oe("text"), s = Oe("font-weight"), l = Oe("tracking"), f = Oe("leading"), c = Oe("breakpoint"), h = Oe("container"), p = Oe("spacing"), g = Oe("radius"), y = Oe("shadow"), v = Oe("inset-shadow"), x = Oe("text-shadow"), C = Oe("drop-shadow"), M = Oe("blur"), N = Oe("perspective"), A = Oe("aspect"), V = Oe("ease"), b = Oe("animate"), j = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"], W = () => ["center", "top", "bottom", "left", "right", "top-left", "left-top", "top-right", "right-top", "bottom-right", "right-bottom", "bottom-left", "left-bottom"], U = () => [...W(), Q, X], J = () => ["auto", "hidden", "clip", "visible", "scroll"], se = () => ["auto", "contain", "none"], O = () => [Q, X, p], ce = () => [Rr, "full", "auto", ...O()], ve = () => [Rn, "none", "subgrid", Q, X], Xe = () => ["auto", { span: ["full", Rn, Q, X] }, Rn, Q, X], Ue = () => [Rn, "auto", Q, X], $e = () => ["auto", "min", "max", "fr", Q, X], We = () => ["start", "end", "center", "between", "around", "evenly", "stretch", "baseline", "center-safe", "end-safe"], _e = () => ["start", "end", "center", "stretch", "center-safe", "end-safe"], Ce = () => ["auto", ...O()], ae = () => [Rr, "auto", "full", "dvw", "dvh", "lvw", "lvh", "svw", "svh", "min", "max", "fit", ...O()], _ = () => [n, Q, X], ee = () => [...W(), Bp, Op, { position: [Q, X] }], H = () => ["no-repeat", { repeat: ["", "x", "y", "space", "round"] }], T = () => ["auto", "cover", "contain", aE, iE, { size: [Q, X] }], I = () => [nu, Ni, Qn], ne = () => ["", "none", "full", g, Q, X], oe = () => ["", fe, Ni, Qn], he = () => ["solid", "dashed", "dotted", "double"], pe = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"], ue = () => [fe, nu, Bp, Op], ge = () => ["", "none", M, Q, X], xe = () => ["none", fe, Q, X], He = () => ["none", fe, Q, X], an = () => [fe, Q, X], _n = () => [Rr, "full", ...O()]; return { cacheSize: 500, theme: { animate: ["spin", "ping", "pulse", "bounce"], aspect: ["video"], blur: [tn], breakpoint: [tn], color: [JC], container: [tn], "drop-shadow": [tn], ease: ["in", "out", "in-out"], font: [rE], "font-weight": ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black"], "inset-shadow": [tn], leading: ["none", "tight", "snug", "normal", "relaxed", "loose"], perspective: ["dramatic", "near", "normal", "midrange", "distant", "none"], radius: [tn], shadow: [tn], spacing: ["px", fe], text: [tn], "text-shadow": [tn], tracking: ["tighter", "tight", "normal", "wide", "wider", "widest"] }, classGroups: { aspect: [{ aspect: ["auto", "square", Rr, X, Q, A] }], container: ["container"], columns: [{ columns: [fe, X, Q, h] }], "break-after": [{ "break-after": j() }], "break-before": [{ "break-before": j() }], "break-inside": [{ "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"] }], "box-decoration": [{ "box-decoration": ["slice", "clone"] }], box: [{ box: ["border", "content"] }], display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"], sr: ["sr-only", "not-sr-only"], float: [{ float: ["right", "left", "none", "start", "end"] }], clear: [{ clear: ["left", "right", "both", "none", "start", "end"] }], isolation: ["isolate", "isolation-auto"], "object-fit": [{ object: ["contain", "cover", "fill", "none", "scale-down"] }], "object-position": [{ object: U() }], overflow: [{ overflow: J() }], "overflow-x": [{ "overflow-x": J() }], "overflow-y": [{ "overflow-y": J() }], overscroll: [{ overscroll: se() }], "overscroll-x": [{ "overscroll-x": se() }], "overscroll-y": [{ "overscroll-y": se() }], position: ["static", "fixed", "absolute", "relative", "sticky"], inset: [{ inset: ce() }], "inset-x": [{ "inset-x": ce() }], "inset-y": [{ "inset-y": ce() }], start: [{ start: ce() }], end: [{ end: ce() }], top: [{ top: ce() }], right: [{ right: ce() }], bottom: [{ bottom: ce() }], left: [{ left: ce() }], visibility: ["visible", "invisible", "collapse"], z: [{ z: [Rn, "auto", Q, X] }], basis: [{ basis: [Rr, "full", "auto", h, ...O()] }], "flex-direction": [{ flex: ["row", "row-reverse", "col", "col-reverse"] }], "flex-wrap": [{ flex: ["nowrap", "wrap", "wrap-reverse"] }], flex: [{ flex: [fe, Rr, "auto", "initial", "none", X] }], grow: [{ grow: ["", fe, Q, X] }], shrink: [{ shrink: ["", fe, Q, X] }], order: [{ order: [Rn, "first", "last", "none", Q, X] }], "grid-cols": [{ "grid-cols": ve() }], "col-start-end": [{ col: Xe() }], "col-start": [{ "col-start": Ue() }], "col-end": [{ "col-end": Ue() }], "grid-rows": [{ "grid-rows": ve() }], "row-start-end": [{ row: Xe() }], "row-start": [{ "row-start": Ue() }], "row-end": [{ "row-end": Ue() }], "grid-flow": [{ "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"] }], "auto-cols": [{ "auto-cols": $e() }], "auto-rows": [{ "auto-rows": $e() }], gap: [{ gap: O() }], "gap-x": [{ "gap-x": O() }], "gap-y": [{ "gap-y": O() }], "justify-content": [{ justify: [...We(), "normal"] }], "justify-items": [{ "justify-items": [..._e(), "normal"] }], "justify-self": [{ "justify-self": ["auto", ..._e()] }], "align-content": [{ content: ["normal", ...We()] }], "align-items": [{ items: [..._e(), { baseline: ["", "last"] }] }], "align-self": [{ self: ["auto", ..._e(), { baseline: ["", "last"] }] }], "place-content": [{ "place-content": We() }], "place-items": [{ "place-items": [..._e(), "baseline"] }], "place-self": [{ "place-self": ["auto", ..._e()] }], p: [{ p: O() }], px: [{ px: O() }], py: [{ py: O() }], ps: [{ ps: O() }], pe: [{ pe: O() }], pt: [{ pt: O() }], pr: [{ pr: O() }], pb: [{ pb: O() }], pl: [{ pl: O() }], m: [{ m: Ce() }], mx: [{ mx: Ce() }], my: [{ my: Ce() }], ms: [{ ms: Ce() }], me: [{ me: Ce() }], mt: [{ mt: Ce() }], mr: [{ mr: Ce() }], mb: [{ mb: Ce() }], ml: [{ ml: Ce() }], "space-x": [{ "space-x": O() }], "space-x-reverse": ["space-x-reverse"], "space-y": [{ "space-y": O() }], "space-y-reverse": ["space-y-reverse"], size: [{ size: ae() }], w: [{ w: [h, "screen", ...ae()] }], "min-w": [{ "min-w": [h, "screen", "none", ...ae()] }], "max-w": [{ "max-w": [h, "screen", "none", "prose", { screen: [c] }, ...ae()] }], h: [{ h: ["screen", ...ae()] }], "min-h": [{ "min-h": ["screen", "none", ...ae()] }], "max-h": [{ "max-h": ["screen", ...ae()] }], "font-size": [{ text: ["base", o, Ni, Qn] }], "font-smoothing": ["antialiased", "subpixel-antialiased"], "font-style": ["italic", "not-italic"], "font-weight": [{ font: [s, Q, ru] }], "font-stretch": [{ "font-stretch": ["ultra-condensed", "extra-condensed", "condensed", "semi-condensed", "normal", "semi-expanded", "expanded", "extra-expanded", "ultra-expanded", nu, X] }], "font-family": [{ font: [sE, X, r] }], "fvn-normal": ["normal-nums"], "fvn-ordinal": ["ordinal"], "fvn-slashed-zero": ["slashed-zero"], "fvn-figure": ["lining-nums", "oldstyle-nums"], "fvn-spacing": ["proportional-nums", "tabular-nums"], "fvn-fraction": ["diagonal-fractions", "stacked-fractions"], tracking: [{ tracking: [l, Q, X] }], "line-clamp": [{ "line-clamp": [fe, "none", Q, ru] }], leading: [{ leading: [f, ...O()] }], "list-image": [{ "list-image": ["none", Q, X] }], "list-style-position": [{ list: ["inside", "outside"] }], "list-style-type": [{ list: ["disc", "decimal", "none", Q, X] }], "text-alignment": [{ text: ["left", "center", "right", "justify", "start", "end"] }], "placeholder-color": [{ placeholder: _() }], "text-color": [{ text: _() }], "text-decoration": ["underline", "overline", "line-through", "no-underline"], "text-decoration-style": [{ decoration: [...he(), "wavy"] }], "text-decoration-thickness": [{ decoration: [fe, "from-font", "auto", Q, Qn] }], "text-decoration-color": [{ decoration: _() }], "underline-offset": [{ "underline-offset": [fe, "auto", Q, X] }], "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"], "text-overflow": ["truncate", "text-ellipsis", "text-clip"], "text-wrap": [{ text: ["wrap", "nowrap", "balance", "pretty"] }], indent: [{ indent: O() }], "vertical-align": [{ align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", Q, X] }], whitespace: [{ whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"] }], break: [{ break: ["normal", "words", "all", "keep"] }], wrap: [{ wrap: ["break-word", "anywhere", "normal"] }], hyphens: [{ hyphens: ["none", "manual", "auto"] }], content: [{ content: ["none", Q, X] }], "bg-attachment": [{ bg: ["fixed", "local", "scroll"] }], "bg-clip": [{ "bg-clip": ["border", "padding", "content", "text"] }], "bg-origin": [{ "bg-origin": ["border", "padding", "content"] }], "bg-position": [{ bg: ee() }], "bg-repeat": [{ bg: H() }], "bg-size": [{ bg: T() }], "bg-image": [{ bg: ["none", { linear: [{ to: ["t", "tr", "r", "br", "b", "bl", "l", "tl"] }, Rn, Q, X], radial: ["", Q, X], conic: [Rn, Q, X] }, lE, oE] }], "bg-color": [{ bg: _() }], "gradient-from-pos": [{ from: I() }], "gradient-via-pos": [{ via: I() }], "gradient-to-pos": [{ to: I() }], "gradient-from": [{ from: _() }], "gradient-via": [{ via: _() }], "gradient-to": [{ to: _() }], rounded: [{ rounded: ne() }], "rounded-s": [{ "rounded-s": ne() }], "rounded-e": [{ "rounded-e": ne() }], "rounded-t": [{ "rounded-t": ne() }], "rounded-r": [{ "rounded-r": ne() }], "rounded-b": [{ "rounded-b": ne() }], "rounded-l": [{ "rounded-l": ne() }], "rounded-ss": [{ "rounded-ss": ne() }], "rounded-se": [{ "rounded-se": ne() }], "rounded-ee": [{ "rounded-ee": ne() }], "rounded-es": [{ "rounded-es": ne() }], "rounded-tl": [{ "rounded-tl": ne() }], "rounded-tr": [{ "rounded-tr": ne() }], "rounded-br": [{ "rounded-br": ne() }], "rounded-bl": [{ "rounded-bl": ne() }], "border-w": [{ border: oe() }], "border-w-x": [{ "border-x": oe() }], "border-w-y": [{ "border-y": oe() }], "border-w-s": [{ "border-s": oe() }], "border-w-e": [{ "border-e": oe() }], "border-w-t": [{ "border-t": oe() }], "border-w-r": [{ "border-r": oe() }], "border-w-b": [{ "border-b": oe() }], "border-w-l": [{ "border-l": oe() }], "divide-x": [{ "divide-x": oe() }], "divide-x-reverse": ["divide-x-reverse"], "divide-y": [{ "divide-y": oe() }], "divide-y-reverse": ["divide-y-reverse"], "border-style": [{ border: [...he(), "hidden", "none"] }], "divide-style": [{ divide: [...he(), "hidden", "none"] }], "border-color": [{ border: _() }], "border-color-x": [{ "border-x": _() }], "border-color-y": [{ "border-y": _() }], "border-color-s": [{ "border-s": _() }], "border-color-e": [{ "border-e": _() }], "border-color-t": [{ "border-t": _() }], "border-color-r": [{ "border-r": _() }], "border-color-b": [{ "border-b": _() }], "border-color-l": [{ "border-l": _() }], "divide-color": [{ divide: _() }], "outline-style": [{ outline: [...he(), "none", "hidden"] }], "outline-offset": [{ "outline-offset": [fe, Q, X] }], "outline-w": [{ outline: ["", fe, Ni, Qn] }], "outline-color": [{ outline: _() }], shadow: [{ shadow: ["", "none", y, hs, ds] }], "shadow-color": [{ shadow: _() }], "inset-shadow": [{ "inset-shadow": ["none", v, hs, ds] }], "inset-shadow-color": [{ "inset-shadow": _() }], "ring-w": [{ ring: oe() }], "ring-w-inset": ["ring-inset"], "ring-color": [{ ring: _() }], "ring-offset-w": [{ "ring-offset": [fe, Qn] }], "ring-offset-color": [{ "ring-offset": _() }], "inset-ring-w": [{ "inset-ring": oe() }], "inset-ring-color": [{ "inset-ring": _() }], "text-shadow": [{ "text-shadow": ["none", x, hs, ds] }], "text-shadow-color": [{ "text-shadow": _() }], opacity: [{ opacity: [fe, Q, X] }], "mix-blend": [{ "mix-blend": [...pe(), "plus-darker", "plus-lighter"] }], "bg-blend": [{ "bg-blend": pe() }], "mask-clip": [{ "mask-clip": ["border", "padding", "content", "fill", "stroke", "view"] }, "mask-no-clip"], "mask-composite": [{ mask: ["add", "subtract", "intersect", "exclude"] }], "mask-image-linear-pos": [{ "mask-linear": [fe] }], "mask-image-linear-from-pos": [{ "mask-linear-from": ue() }], "mask-image-linear-to-pos": [{ "mask-linear-to": ue() }], "mask-image-linear-from-color": [{ "mask-linear-from": _() }], "mask-image-linear-to-color": [{ "mask-linear-to": _() }], "mask-image-t-from-pos": [{ "mask-t-from": ue() }], "mask-image-t-to-pos": [{ "mask-t-to": ue() }], "mask-image-t-from-color": [{ "mask-t-from": _() }], "mask-image-t-to-color": [{ "mask-t-to": _() }], "mask-image-r-from-pos": [{ "mask-r-from": ue() }], "mask-image-r-to-pos": [{ "mask-r-to": ue() }], "mask-image-r-from-color": [{ "mask-r-from": _() }], "mask-image-r-to-color": [{ "mask-r-to": _() }], "mask-image-b-from-pos": [{ "mask-b-from": ue() }], "mask-image-b-to-pos": [{ "mask-b-to": ue() }], "mask-image-b-from-color": [{ "mask-b-from": _() }], "mask-image-b-to-color": [{ "mask-b-to": _() }], "mask-image-l-from-pos": [{ "mask-l-from": ue() }], "mask-image-l-to-pos": [{ "mask-l-to": ue() }], "mask-image-l-from-color": [{ "mask-l-from": _() }], "mask-image-l-to-color": [{ "mask-l-to": _() }], "mask-image-x-from-pos": [{ "mask-x-from": ue() }], "mask-image-x-to-pos": [{ "mask-x-to": ue() }], "mask-image-x-from-color": [{ "mask-x-from": _() }], "mask-image-x-to-color": [{ "mask-x-to": _() }], "mask-image-y-from-pos": [{ "mask-y-from": ue() }], "mask-image-y-to-pos": [{ "mask-y-to": ue() }], "mask-image-y-from-color": [{ "mask-y-from": _() }], "mask-image-y-to-color": [{ "mask-y-to": _() }], "mask-image-radial": [{ "mask-radial": [Q, X] }], "mask-image-radial-from-pos": [{ "mask-radial-from": ue() }], "mask-image-radial-to-pos": [{ "mask-radial-to": ue() }], "mask-image-radial-from-color": [{ "mask-radial-from": _() }], "mask-image-radial-to-color": [{ "mask-radial-to": _() }], "mask-image-radial-shape": [{ "mask-radial": ["circle", "ellipse"] }], "mask-image-radial-size": [{ "mask-radial": [{ closest: ["side", "corner"], farthest: ["side", "corner"] }] }], "mask-image-radial-pos": [{ "mask-radial-at": W() }], "mask-image-conic-pos": [{ "mask-conic": [fe] }], "mask-image-conic-from-pos": [{ "mask-conic-from": ue() }], "mask-image-conic-to-pos": [{ "mask-conic-to": ue() }], "mask-image-conic-from-color": [{ "mask-conic-from": _() }], "mask-image-conic-to-color": [{ "mask-conic-to": _() }], "mask-mode": [{ mask: ["alpha", "luminance", "match"] }], "mask-origin": [{ "mask-origin": ["border", "padding", "content", "fill", "stroke", "view"] }], "mask-position": [{ mask: ee() }], "mask-repeat": [{ mask: H() }], "mask-size": [{ mask: T() }], "mask-type": [{ "mask-type": ["alpha", "luminance"] }], "mask-image": [{ mask: ["none", Q, X] }], filter: [{ filter: ["", "none", Q, X] }], blur: [{ blur: ge() }], brightness: [{ brightness: [fe, Q, X] }], contrast: [{ contrast: [fe, Q, X] }], "drop-shadow": [{ "drop-shadow": ["", "none", C, hs, ds] }], "drop-shadow-color": [{ "drop-shadow": _() }], grayscale: [{ grayscale: ["", fe, Q, X] }], "hue-rotate": [{ "hue-rotate": [fe, Q, X] }], invert: [{ invert: ["", fe, Q, X] }], saturate: [{ saturate: [fe, Q, X] }], sepia: [{ sepia: ["", fe, Q, X] }], "backdrop-filter": [{ "backdrop-filter": ["", "none", Q, X] }], "backdrop-blur": [{ "backdrop-blur": ge() }], "backdrop-brightness": [{ "backdrop-brightness": [fe, Q, X] }], "backdrop-contrast": [{ "backdrop-contrast": [fe, Q, X] }], "backdrop-grayscale": [{ "backdrop-grayscale": ["", fe, Q, X] }], "backdrop-hue-rotate": [{ "backdrop-hue-rotate": [fe, Q, X] }], "backdrop-invert": [{ "backdrop-invert": ["", fe, Q, X] }], "backdrop-opacity": [{ "backdrop-opacity": [fe, Q, X] }], "backdrop-saturate": [{ "backdrop-saturate": [fe, Q, X] }], "backdrop-sepia": [{ "backdrop-sepia": ["", fe, Q, X] }], "border-collapse": [{ border: ["collapse", "separate"] }], "border-spacing": [{ "border-spacing": O() }], "border-spacing-x": [{ "border-spacing-x": O() }], "border-spacing-y": [{ "border-spacing-y": O() }], "table-layout": [{ table: ["auto", "fixed"] }], caption: [{ caption: ["top", "bottom"] }], transition: [{ transition: ["", "all", "colors", "opacity", "shadow", "transform", "none", Q, X] }], "transition-behavior": [{ transition: ["normal", "discrete"] }], duration: [{ duration: [fe, "initial", Q, X] }], ease: [{ ease: ["linear", "initial", V, Q, X] }], delay: [{ delay: [fe, Q, X] }], animate: [{ animate: ["none", b, Q, X] }], backface: [{ backface: ["hidden", "visible"] }], perspective: [{ perspective: [N, Q, X] }], "perspective-origin": [{ "perspective-origin": U() }], rotate: [{ rotate: xe() }], "rotate-x": [{ "rotate-x": xe() }], "rotate-y": [{ "rotate-y": xe() }], "rotate-z": [{ "rotate-z": xe() }], scale: [{ scale: He() }], "scale-x": [{ "scale-x": He() }], "scale-y": [{ "scale-y": He() }], "scale-z": [{ "scale-z": He() }], "scale-3d": ["scale-3d"], skew: [{ skew: an() }], "skew-x": [{ "skew-x": an() }], "skew-y": [{ "skew-y": an() }], transform: [{ transform: [Q, X, "", "none", "gpu", "cpu"] }], "transform-origin": [{ origin: U() }], "transform-style": [{ transform: ["3d", "flat"] }], translate: [{ translate: _n() }], "translate-x": [{ "translate-x": _n() }], "translate-y": [{ "translate-y": _n() }], "translate-z": [{ "translate-z": _n() }], "translate-none": ["translate-none"], accent: [{ accent: _() }], appearance: [{ appearance: ["none", "auto"] }], "caret-color": [{ caret: _() }], "color-scheme": [{ scheme: ["normal", "dark", "light", "light-dark", "only-dark", "only-light"] }], cursor: [{ cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", Q, X] }], "field-sizing": [{ "field-sizing": ["fixed", "content"] }], "pointer-events": [{ "pointer-events": ["auto", "none"] }], resize: [{ resize: ["none", "", "y", "x"] }], "scroll-behavior": [{ scroll: ["auto", "smooth"] }], "scroll-m": [{ "scroll-m": O() }], "scroll-mx": [{ "scroll-mx": O() }], "scroll-my": [{ "scroll-my": O() }], "scroll-ms": [{ "scroll-ms": O() }], "scroll-me": [{ "scroll-me": O() }], "scroll-mt": [{ "scroll-mt": O() }], "scroll-mr": [{ "scroll-mr": O() }], "scroll-mb": [{ "scroll-mb": O() }], "scroll-ml": [{ "scroll-ml": O() }], "scroll-p": [{ "scroll-p": O() }], "scroll-px": [{ "scroll-px": O() }], "scroll-py": [{ "scroll-py": O() }], "scroll-ps": [{ "scroll-ps": O() }], "scroll-pe": [{ "scroll-pe": O() }], "scroll-pt": [{ "scroll-pt": O() }], "scroll-pr": [{ "scroll-pr": O() }], "scroll-pb": [{ "scroll-pb": O() }], "scroll-pl": [{ "scroll-pl": O() }], "snap-align": [{ snap: ["start", "end", "center", "align-none"] }], "snap-stop": [{ snap: ["normal", "always"] }], "snap-type": [{ snap: ["none", "x", "y", "both"] }], "snap-strictness": [{ snap: ["mandatory", "proximity"] }], touch: [{ touch: ["auto", "none", "manipulation"] }], "touch-x": [{ "touch-pan": ["x", "left", "right"] }], "touch-y": [{ "touch-pan": ["y", "up", "down"] }], "touch-pz": ["touch-pinch-zoom"], select: [{ select: ["none", "text", "all", "auto"] }], "will-change": [{ "will-change": ["auto", "scroll", "contents", "transform", Q, X] }], fill: [{ fill: ["none", ..._()] }], "stroke-w": [{ stroke: [fe, Ni, Qn, ru] }], stroke: [{ stroke: ["none", ..._()] }], "forced-color-adjust": [{ "forced-color-adjust": ["auto", "none"] }] }, conflictingClassGroups: { overflow: ["overflow-x", "overflow-y"], overscroll: ["overscroll-x", "overscroll-y"], inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"], "inset-x": ["right", "left"], "inset-y": ["top", "bottom"], flex: ["basis", "grow", "shrink"], gap: ["gap-x", "gap-y"], p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"], px: ["pr", "pl"], py: ["pt", "pb"], m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"], mx: ["mr", "ml"], my: ["mt", "mb"], size: ["w", "h"], "font-size": ["leading"], "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"], "fvn-ordinal": ["fvn-normal"], "fvn-slashed-zero": ["fvn-normal"], "fvn-figure": ["fvn-normal"], "fvn-spacing": ["fvn-normal"], "fvn-fraction": ["fvn-normal"], "line-clamp": ["display", "overflow"], rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"], "rounded-s": ["rounded-ss", "rounded-es"], "rounded-e": ["rounded-se", "rounded-ee"], "rounded-t": ["rounded-tl", "rounded-tr"], "rounded-r": ["rounded-tr", "rounded-br"], "rounded-b": ["rounded-br", "rounded-bl"], "rounded-l": ["rounded-tl", "rounded-bl"], "border-spacing": ["border-spacing-x", "border-spacing-y"], "border-w": ["border-w-x", "border-w-y", "border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"], "border-w-x": ["border-w-r", "border-w-l"], "border-w-y": ["border-w-t", "border-w-b"], "border-color": ["border-color-x", "border-color-y", "border-color-s", "border-color-e", "border-color-t", "border-color-r", "border-color-b", "border-color-l"], "border-color-x": ["border-color-r", "border-color-l"], "border-color-y": ["border-color-t", "border-color-b"], translate: ["translate-x", "translate-y", "translate-none"], "translate-none": ["translate", "translate-x", "translate-y", "translate-z"], "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"], "scroll-mx": ["scroll-mr", "scroll-ml"], "scroll-my": ["scroll-mt", "scroll-mb"], "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"], "scroll-px": ["scroll-pr", "scroll-pl"], "scroll-py": ["scroll-pt", "scroll-pb"], touch: ["touch-x", "touch-y", "touch-pz"], "touch-x": ["touch"], "touch-y": ["touch"], "touch-pz": ["touch"] }, conflictingClassGroupModifiers: { "font-size": ["leading"] }, orderSensitiveModifiers: ["*", "**", "after", "backdrop", "before", "details-content", "file", "first-letter", "first-line", "marker", "placeholder", "selection"] } }, dE = KC(fE); function hE(...n) { return dE(DC(n)) } const Vn = ({ children: n, className: r, href: o, gradient: s }) => { const l = E.jsx(Ns.div, { whileHover: { scale: .98 }, whileTap: { scale: .95 }, className: hE("group relative flex flex-col overflow-hidden rounded-[24px] shadow-sm transition-all hover:shadow-md", r), style: { background: s }, children: n }); return o ? o.startsWith("/") ? E.jsx(Fi, { to: o, className: "block h-full w-full", children: l }) : E.jsx("a", { href: o, target: o.startsWith("http") ? "_blank" : void 0, rel: o.startsWith("http") ? "noopener noreferrer" : void 0, className: "block h-full w-full", children: l }) : l };/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const pE = n => n.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase(), mE = n => n.replace(/^([A-Z])|[\s-_]+(\w)/g, (r, o, s) => s ? s.toUpperCase() : o.toLowerCase()), Up = n => { const r = mE(n); return r.charAt(0).toUpperCase() + r.slice(1) }, ry = (...n) => n.filter((r, o, s) => !!r && r.trim() !== "" && s.indexOf(r) === o).join(" ").trim();/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */var gE = { xmlns: "http://www.w3.org/2000/svg", width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: 2, strokeLinecap: "round", strokeLinejoin: "round" };/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const yE = P.forwardRef(({ color: n = "currentColor", size: r = 24, strokeWidth: o = 2, absoluteStrokeWidth: s, className: l = "", children: f, iconNode: c, ...h }, p) => P.createElement("svg", { ref: p, ...gE, width: r, height: r, stroke: n, strokeWidth: s ? Number(o) * 24 / Number(r) : o, className: ry("lucide", l), ...h }, [...c.map(([g, y]) => P.createElement(g, y)), ...Array.isArray(f) ? f : [f]]));/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const It = (n, r) => { const o = P.forwardRef(({ className: s, ...l }, f) => P.createElement(yE, { ref: f, iconNode: r, className: ry(`lucide-${pE(Up(n))}`, `lucide-${n}`, s), ...l })); return o.displayName = Up(n), o };/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const vE = [["path", { d: "m12 19-7-7 7-7", key: "1l729n" }], ["path", { d: "M19 12H5", key: "x3x0zl" }]], xE = It("arrow-left", vE);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const wE = [["path", { d: "M7 7h10v10", key: "1tivn9" }], ["path", { d: "M7 17 17 7", key: "1vkiza" }]], Is = It("arrow-up-right", wE);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const SE = [["path", { d: "M8 2v4", key: "1cmpym" }], ["path", { d: "M16 2v4", key: "4m81vk" }], ["rect", { width: "18", height: "18", x: "3", y: "4", rx: "2", key: "1hopcy" }], ["path", { d: "M3 10h18", key: "8toen8" }]], kE = It("calendar", SE);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const CE = [["path", { d: "M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4", key: "ih7n3h" }], ["polyline", { points: "7 10 12 15 17 10", key: "2ggqvy" }], ["line", { x1: "12", x2: "12", y1: "15", y2: "3", key: "1vk2je" }]], EE = It("download", CE);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const TE = [["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }], ["path", { d: "M19.13 5.09C15.22 9.14 10 10.44 2.25 10.94", key: "hpej1" }], ["path", { d: "M21.75 12.84c-6.62-1.41-12.14 1-16.38 6.32", key: "1tr44o" }], ["path", { d: "M8.56 2.75c4.37 6 6 9.42 8 17.72", key: "kbh691" }]], PE = It("dribbble", TE);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const RE = [["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }], ["path", { d: "M12 2a14.5 14.5 0 0 0 0 20 14.5 14.5 0 0 0 0-20", key: "13o1zl" }], ["path", { d: "M2 12h20", key: "9i4pu4" }]], ME = It("globe", RE);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const AE = [["path", { d: "M16 8a6 6 0 0 1 6 6v7h-4v-7a2 2 0 0 0-2-2 2 2 0 0 0-2 2v7h-4v-7a6 6 0 0 1 6-6z", key: "c2jq9f" }], ["rect", { width: "4", height: "12", x: "2", y: "9", key: "mk3on5" }], ["circle", { cx: "4", cy: "4", r: "2", key: "bt5ra8" }]], LE = It("linkedin", AE);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const NE = [["rect", { width: "20", height: "16", x: "2", y: "4", rx: "2", key: "18n3k1" }], ["path", { d: "m22 7-8.97 5.7a1.94 1.94 0 0 1-2.06 0L2 7", key: "1ocrg3" }]], DE = It("mail", NE);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const jE = [["path", { d: "M20 10c0 4.993-5.539 10.193-7.399 11.799a1 1 0 0 1-1.202 0C9.539 20.193 4 14.993 4 10a8 8 0 0 1 16 0", key: "1r0f0z" }], ["circle", { cx: "12", cy: "10", r: "3", key: "ilqhr7" }]], VE = It("map-pin", jE);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const _E = [["path", { d: "M12.586 2.586A2 2 0 0 0 11.172 2H4a2 2 0 0 0-2 2v7.172a2 2 0 0 0 .586 1.414l8.704 8.704a2.426 2.426 0 0 0 3.42 0l6.58-6.58a2.426 2.426 0 0 0 0-3.42z", key: "vktsd0" }], ["circle", { cx: "7.5", cy: "7.5", r: ".5", fill: "currentColor", key: "kqv944" }]], bE = It("tag", _E);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const IE = [["path", { d: "M19 21v-2a4 4 0 0 0-4-4H9a4 4 0 0 0-4 4v2", key: "975kel" }], ["circle", { cx: "12", cy: "7", r: "4", key: "17ys0d" }]], FE = It("user", IE), zE = "/assets/profile_photo-DKWgU8Ui.png", OE = () => E.jsx(Vn, { className: "col-span-1 row-span-2 h-full min-h-[400px] lg:col-span-2 lg:min-h-full", gradient: "linear-gradient(142.125deg, rgb(238, 251, 255) 0%, rgb(255, 248, 239) 100%)", children: E.jsxs("div", { className: "flex h-full flex-col justify-between p-6 md:p-8", children: [E.jsx("div", { className: "relative h-24 w-24 overflow-hidden rounded-full border-4 border-white shadow-sm", children: E.jsx("img", { src: zE, alt: "Alex Rivera", className: "h-full w-full object-cover" }) }), E.jsxs("div", { className: "flex flex-col gap-6", children: [E.jsxs("div", { children: [E.jsx("h1", { className: "text-[30px] font-bold tracking-tight text-[#171717] leading-tight", children: "Alex Rivera" }), E.jsxs("p", { className: "text-[18px] font-medium text-[#737373]", children: ["Product Designer ", E.jsx("br", {}), " & Strategist"] })] }), E.jsx("div", { className: "max-w-md", children: E.jsx("p", { className: "text-[16px] leading-[24px] text-neutral-600", children: "Crafting digital experiences that blend aesthetics with functionality. Provided solutions across IoT, AI, fintech, and e-commerce." }) }), E.jsxs("div", { className: "flex items-center gap-2 text-sm text-[#A1A1A1]", children: [E.jsx(VE, { size: 16 }), E.jsx("span", { className: "text-[14px]", children: "Singapore" })] })] })] }) }), BE = "/assets/design_system-BuK9AraL.png", UE = () => E.jsxs(Vn, { className: "col-span-1 lg:h-full bg-white", href: "#", children: [E.jsx("div", { className: "absolute right-4 top-4 z-20 flex h-8 w-8 items-center justify-center rounded-full bg-white/30 backdrop-blur-md transition-transform group-hover:rotate-45", children: E.jsx(Is, { size: 18, className: "text-white" }) }), E.jsxs("div", { className: "absolute inset-0 h-full w-full", children: [E.jsx("img", { src: BE, alt: "Design System", className: "h-full w-full object-cover transition-transform duration-500 group-hover:scale-105" }), E.jsx("div", { className: "absolute inset-0 bg-gradient-to-t from-black/60 to-transparent" })] }), E.jsxs("div", { className: "relative z-10 mt-auto p-6", children: [E.jsx("p", { className: "mb-1 text-sm font-medium text-white/80", children: "Design System" }), E.jsxs("h3", { className: "text-[20px] font-bold leading-tight text-white w-2/3", children: ["Building and scaling ", E.jsx("br", {}), " a design system"] })] })] }), $E = "/assets/workspace-Ds93m92g.png", iy = "/assets/workspace_case_study-DOvrLGcA.png", WE = () => E.jsxs(Vn, { className: "col-span-1 lg:col-span-2 h-[188px] bg-white", href: "/case-studies/saas-dashboard", children: [E.jsx("div", { className: "absolute right-4 top-4 z-20 flex h-8 w-8 items-center justify-center rounded-full bg-white/30 backdrop-blur-md transition-transform group-hover:rotate-45", children: E.jsx(Is, { size: 18, className: "text-white" }) }), E.jsxs("div", { className: "absolute inset-0 h-full w-full bg-[#1e1e1e]", children: [" ", E.jsx("img", { src: $E, alt: "SaaS Platform", className: "h-full w-full object-cover transition-transform duration-500 group-hover:scale-105" }), E.jsx("img", { src: iy, alt: "", className: "absolute inset-0 h-full w-full object-cover opacity-50 mix-blend-overlay pointer-events-none" }), E.jsx("div", { className: "absolute inset-0 bg-gradient-to-t from-black/80 to-transparent" })] }), E.jsxs("div", { className: "relative z-10 mt-auto p-6", children: [E.jsx("p", { className: "mb-1 text-sm font-medium text-white/80", children: "SaaS Platform" }), E.jsx("h3", { className: "text-[20px] font-bold leading-tight text-white", children: "Survey Data Storage and Post-Processing" })] })] }), HE = "/assets/ai_spot-CjUxLjuD.png", KE = () => E.jsxs(Vn, { className: "col-span-1 h-full min-h-[188px] bg-white", href: "#", children: [E.jsx("div", { className: "absolute right-4 top-4 z-20 flex h-8 w-8 items-center justify-center rounded-full bg-white/30 backdrop-blur-md transition-transform group-hover:rotate-45", children: E.jsx(Is, { size: 18, className: "text-white" }) }), E.jsxs("div", { className: "absolute inset-0 h-full w-full", children: [E.jsx("img", { src: HE, alt: "AI Defect Reporting", className: "h-full w-full object-cover transition-transform duration-500 group-hover:scale-105" }), E.jsx("div", { className: "absolute inset-0 bg-gradient-to-t from-black/70 to-transparent" })] }), E.jsxs("div", { className: "relative z-10 mt-auto p-6", children: [E.jsx("p", { className: "mb-1 text-xs font-medium text-white/80", children: "Human-in-the-loop AI" }), E.jsx("h3", { className: "text-[18px] font-bold leading-tight text-white", children: "Defect Reporting" })] })] }), GE = "/assets/icons-CKRBaWef.png", YE = () => E.jsxs(Vn, { className: "col-span-1 h-full bg-[#fafafa]", href: "#", children: [E.jsx("div", { className: "absolute right-4 top-4 z-20 opacity-0 transition-opacity group-hover:opacity-100", children: E.jsx(Is, { size: 18, className: "text-neutral-500" }) }), E.jsx("div", { className: "absolute bottom-0 right-0 w-32 h-24", children: E.jsx("img", { src: GE, alt: "Icons", className: "object-contain w-full h-full object-bottom opacity-80" }) }), E.jsxs("div", { className: "relative z-10 p-6", children: [E.jsx("h3", { className: "text-[18px] font-bold text-[#171717]", children: "Icon Set" }), E.jsx("p", { className: "text-[14px] text-[#737373]", children: "Open Source" })] })] }), XE = () => E.jsx(Vn, { href: "/resume.pdf", className: "h-[188px] bg-[#fdc700] text-black", children: E.jsxs("div", { className: "flex h-full flex-col items-center justify-center gap-3 text-center", children: [E.jsx("div", { className: "flex h-12 w-12 items-center justify-center rounded-full bg-black/10 backdrop-blur-sm transition-colors group-hover:bg-black/20", children: E.jsx(EE, { size: 24, className: "text-black" }) }), E.jsxs("div", { children: [E.jsx("h3", { className: "text-[18px] font-bold text-black", children: "Resume" }), E.jsx("p", { className: "text-[12px] font-medium text-black/70", children: "PDF  2.4 MB" })] })] }) }), QE = () => E.jsxs("svg", { className: "size-6", viewBox: "0 0 24 24", fill: "none", children: [E.jsx("path", { d: "M6 12C6 15.3137 8.68629 18 12 18V12H6Z", fill: "#0ACF83" }), E.jsx("path", { d: "M12 12C15.3137 12 18 9.31371 18 6C18 2.68629 15.3137 0 12 0C8.68629 0 6 2.68629 6 6C6 9.31371 8.68629 12 12 12Z", fill: "#A259FF" }), E.jsx("path", { d: "M6 6C6 9.31371 8.68629 12 12 12V6H6Z", fill: "#F24E1E" }), E.jsx("path", { d: "M6 12C6 15.3137 8.68629 18 12 18V12H6Z", fill: "#FF7262" }), E.jsx("path", { d: "M12 12V18C12 21.3137 9.31371 24 6 24C2.68629 24 0 21.3137 0 18C0 14.6863 2.68629 12 6 12H12Z", fill: "#1ABCFE" })] }), ZE = () => E.jsxs("svg", { className: "size-6", viewBox: "0 0 16 24", fill: "none", children: [E.jsx("path", { d: "M0 0H16V8.5H8.5L0 0Z", fill: "white" }), E.jsx("path", { d: "M0 8.5H16V17H8.5L0 8.5Z", fill: "white", opacity: "0.5" }), " ", E.jsx("path", { d: "M0 17H8.5V24L0 17Z", fill: "white" })] }), qE = () => E.jsxs("svg", { className: "size-6", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [E.jsx("circle", { cx: "12", cy: "12", r: "2", fill: "#61DAFB" }), E.jsx("ellipse", { cx: "12", cy: "12", rx: "10", ry: "4", stroke: "#61DAFB", strokeWidth: "1.5", transform: "rotate(45 12 12)" }), E.jsx("ellipse", { cx: "12", cy: "12", rx: "10", ry: "4", stroke: "#61DAFB", strokeWidth: "1.5", transform: "rotate(-45 12 12)" })] }), JE = () => { const n = [{ icon: E.jsx(QE, {}), name: "Figma" }, { icon: E.jsx(ZE, {}), name: "Framer" }, { icon: E.jsx(qE, {}), name: "React" }, { icon: E.jsx("div", { className: "text-yellow-500 font-bold text-xs", children: "GA" }), name: "Analytics" }, { icon: E.jsx("div", { className: "text-cyan-400 font-bold text-xs", children: "TW" }), name: "Tailwind" }, { icon: E.jsx("div", { className: "text-orange-500 font-bold text-xs", children: "Ai" }), name: "Illustrator" }]; return E.jsx(Vn, { className: "h-[188px] bg-[#171717] p-6 text-white", children: E.jsxs("div", { className: "flex h-full flex-col justify-between", children: [E.jsx("h3", { className: "text-[18px] font-bold text-[#e5e5e5]", children: "Tools" }), E.jsx("div", { className: "grid grid-cols-3 gap-3", children: n.map((r, o) => E.jsx("div", { className: "flex h-10 w-full items-center justify-center rounded-[14px] bg-[#262626]", children: r.icon }, o)) })] }) }) }, eT = () => { const n = [{ icon: E.jsx(PE, { size: 20 }), href: "#" }, { icon: E.jsx(LE, { size: 20 }), href: "#" }, { icon: E.jsx(ME, { size: 20 }), href: "#" }, { icon: E.jsx(DE, { size: 20 }), href: "mailto:hello@example.com" }]; return E.jsx(Vn, { className: "col-span-1 h-full bg-white p-0", children: E.jsx("div", { className: "grid h-full w-full grid-cols-2 grid-rows-2 gap-3 p-4", children: n.map((r, o) => E.jsx("a", { href: r.href, className: "flex h-full w-full items-center justify-center rounded-[14px] bg-[#f5f5f5] text-neutral-600 transition-colors hover:bg-neutral-200 hover:text-black", children: r.icon }, o)) }) }) }, tT = () => E.jsx("div", { className: "min-h-screen bg-[#f5f5f5] px-4 py-8 md:px-8 md:py-12 lg:px-16 lg:py-20 font-['Geist_Sans',sans-serif]", children: E.jsxs("div", { className: "mx-auto max-w-6xl", children: [E.jsxs(Ns.div, { initial: "hidden", animate: "visible", variants: { hidden: { opacity: 0 }, visible: { opacity: 1, transition: { staggerChildren: .1 } } }, className: "grid grid-cols-1 gap-4 md:grid-cols-2 lg:grid-cols-4 lg:auto-rows-[minmax(180px,auto)]", children: [E.jsx("div", { className: "col-span-1 md:col-span-2 md:row-span-2", children: E.jsx(OE, {}) }), E.jsxs("div", { className: "col-span-1 md:col-span-2 flex flex-col justify-center lg:justify-end pb-4", children: [E.jsx("p", { className: "mb-2 text-[14px] uppercase tracking-wider text-[#737373]", children: "Portfolio 2026" }), E.jsxs("h1", { className: "text-[32px] md:text-[40px] lg:text-[48px] font-extrabold leading-[1.1] text-[#171717] tracking-tight", children: ["Good design is", E.jsx("br", {}), E.jsx("span", { className: "text-transparent bg-clip-text bg-gradient-to-r from-[#32B3CD] to-[#FF9A00]", children: "invisible" })] })] }), E.jsx("div", { className: "col-span-1", children: E.jsx(XE, {}) }), E.jsx("div", { className: "col-span-1", children: E.jsx(JE, {}) }), E.jsx("div", { className: "col-span-1", children: E.jsx(YE, {}) }), E.jsx("div", { className: "col-span-1 md:col-span-2", children: E.jsx(WE, {}) }), E.jsx("div", { className: "col-span-1 md:col-span-1 md:row-span-2 h-full", children: E.jsx(KE, {}) }), E.jsx("div", { className: "col-span-1 md:col-span-2", children: E.jsx(UE, {}) }), E.jsx("div", { className: "col-span-1", children: E.jsx(eT, {}) })] }), E.jsx("footer", { className: "mt-16 text-center text-sm text-[#A1A1A1]", children: E.jsx("p", { children: " 2026 Alex Rivera. All rights reserved." }) })] }) }), nT = () => E.jsxs("div", { className: "min-h-screen bg-[#f5f5f5] font-['Geist_Sans',sans-serif] text-[#171717]", children: [E.jsx("nav", { className: "fixed top-0 z-50 w-full bg-[#f5f5f5]/80 backdrop-blur-md", children: E.jsxs("div", { className: "mx-auto flex h-16 max-w-6xl items-center justify-between px-4 md:px-8", children: [E.jsxs(Fi, { to: "/", className: "flex items-center gap-2 rounded-full bg-white px-4 py-2 text-sm font-medium shadow-sm transition-hover hover:bg-neutral-50", children: [E.jsx(xE, { size: 16 }), "Back to Portfolio"] }), E.jsx("div", { className: "hidden text-sm font-bold text-[#737373] sm:block", children: "NEXUS DASHBOARD" })] }) }), E.jsxs("main", { className: "mx-auto max-w-4xl px-4 pt-24 pb-20 md:px-8", children: [E.jsxs(Ns.div, { initial: { opacity: 0, y: 20 }, animate: { opacity: 1, y: 0 }, className: "mb-12", children: [E.jsxs("div", { className: "mb-6 flex flex-wrap gap-4 text-sm font-medium text-[#737373]", children: [E.jsxs("div", { className: "flex items-center gap-1.5 rounded-full bg-white px-3 py-1 shadow-sm", children: [E.jsx(bE, { size: 14 }), E.jsx("span", { children: "SaaS Platform" })] }), E.jsxs("div", { className: "flex items-center gap-1.5 rounded-full bg-white px-3 py-1 shadow-sm", children: [E.jsx(kE, { size: 14 }), E.jsx("span", { children: "2024 - 2025" })] }), E.jsxs("div", { className: "flex items-center gap-1.5 rounded-full bg-white px-3 py-1 shadow-sm", children: [E.jsx(FE, { size: 14 }), E.jsx("span", { children: "Lead Product Designer" })] })] }), E.jsx("h1", { className: "mb-4 text-4xl font-extrabold tracking-tight md:text-5xl lg:text-6xl", children: "Survey Data Storage and Post-Processing" }), E.jsx("p", { className: "text-xl leading-relaxed text-neutral-600 md:text-2xl", children: "Redesigning the core workflow for geotechnical engineers to process massive datasets 40% faster." })] }), E.jsx(Ns.div, { initial: { opacity: 0, scale: .95 }, animate: { opacity: 1, scale: 1 }, transition: { delay: .2 }, className: "mb-16 overflow-hidden rounded-[24px] shadow-lg", children: E.jsx("img", { src: iy, alt: "Nexus Dashboard Interface", className: "w-full object-cover" }) }), E.jsxs("div", { className: "grid gap-16 md:grid-cols-[1fr_2fr]", children: [E.jsx("div", { className: "text-sm font-bold uppercase tracking-wider text-[#A1A1A1] pt-1", children: "The Challenge" }), E.jsxs("div", { className: "text-lg leading-relaxed text-neutral-600", children: [E.jsx("p", { className: "mb-6", children: "Geotechnical engineers were struggling with a fragmented workflow. They used three different legacy tools to upload, validate, and visualize survey data. This resulted in:" }), E.jsxs("ul", { className: "list-disc space-y-2 pl-5 text-[#171717]", children: [E.jsx("li", { children: "High error rates during manual data transfer." }), E.jsx("li", { children: "Wait times of up to 4 hours for simple visualizations." }), E.jsx("li", { children: "Complete lack of collaboration features for remote teams." })] })] }), E.jsx("div", { className: "text-sm font-bold uppercase tracking-wider text-[#A1A1A1] pt-1", children: "The Solution" }), E.jsxs("div", { className: "text-lg leading-relaxed text-neutral-600", children: [E.jsx("p", { className: "mb-6", children: "We unified the workflow into a single cloud-based platform. Key features included:" }), E.jsxs("div", { className: "mb-8 grid gap-6 sm:grid-cols-2", children: [E.jsxs("div", { className: "rounded-2xl bg-white p-6 shadow-sm", children: [E.jsx("h3", { className: "mb-2 font-bold text-[#171717]", children: "Real-time Validation" }), E.jsx("p", { className: "text-sm text-[#737373]", children: "Immediate feedback on data quality upon upload, reducing errors by 90%." })] }), E.jsxs("div", { className: "rounded-2xl bg-white p-6 shadow-sm", children: [E.jsx("h3", { className: "mb-2 font-bold text-[#171717]", children: "Interactive Canvas" }), E.jsx("p", { className: "text-sm text-[#737373]", children: "A drag-and-drop interface for processing layers, replacing CLI commands." })] })] }), E.jsx("p", { children: "I led the design system creation concurrently, ensuring consistency across the new modules while maintaining velocity." })] }), E.jsx("div", { className: "text-sm font-bold uppercase tracking-wider text-[#A1A1A1] pt-1", children: "The Impact" }), E.jsx("div", { className: "text-lg leading-relaxed text-neutral-600", children: E.jsxs("div", { className: "grid grid-cols-3 gap-4 border-t border-neutral-200 pt-6", children: [E.jsxs("div", { children: [E.jsx("div", { className: "text-3xl font-extrabold text-[#32B3CD]", children: "40%" }), E.jsx("div", { className: "text-sm font-medium text-[#737373]", children: "Faster Workflow" })] }), E.jsxs("div", { children: [E.jsx("div", { className: "text-3xl font-extrabold text-[#FF9A00]", children: "90%" }), E.jsx("div", { className: "text-sm font-medium text-[#737373]", children: "Error Reduction" })] }), E.jsxs("div", { children: [E.jsx("div", { className: "text-3xl font-extrabold text-[#171717]", children: "2k+" }), E.jsx("div", { className: "text-sm font-medium text-[#737373]", children: "Active Users" })] })] }) })] }), E.jsx("div", { className: "mt-20 flex justify-center border-t border-neutral-200 pt-12", children: E.jsx(Fi, { to: "/", className: "text-lg font-bold text-[#171717] hover:text-[#32B3CD] hover:underline", children: "Next Project: Defect Reporting " }) })] })] }); function rT() { return E.jsx(Nx, { children: E.jsxs(ax, { children: [E.jsx(ou, { path: "/", element: E.jsx(tT, {}) }), E.jsx(ou, { path: "/case-studies/saas-dashboard", element: E.jsx(nT, {}) })] }) }) } u0.createRoot(document.getElementById("root")).render(E.jsx(rT, {}));
